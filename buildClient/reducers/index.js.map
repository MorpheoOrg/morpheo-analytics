{"version":3,"file":"reducers/index.js","sources":["webpack:///./node_modules/d/auto-bind.js","webpack:///./node_modules/d/index.js","webpack:///./node_modules/debug/src/browser.js","webpack:///./node_modules/debug/src/debug.js","webpack:///./node_modules/direction/index.js","webpack:///./node_modules/es5-ext/array/#/clear.js","webpack:///./node_modules/es5-ext/array/#/e-index-of.js","webpack:///./node_modules/es5-ext/array/from/index.js","webpack:///./node_modules/es5-ext/array/from/is-implemented.js","webpack:///./node_modules/es5-ext/array/from/shim.js","webpack:///./node_modules/es5-ext/function/is-arguments.js","webpack:///./node_modules/es5-ext/function/is-function.js","webpack:///./node_modules/es5-ext/function/noop.js","webpack:///./node_modules/es5-ext/math/sign/index.js","webpack:///./node_modules/es5-ext/math/sign/is-implemented.js","webpack:///./node_modules/es5-ext/math/sign/shim.js","webpack:///./node_modules/es5-ext/number/is-nan/index.js","webpack:///./node_modules/es5-ext/number/is-nan/is-implemented.js","webpack:///./node_modules/es5-ext/number/is-nan/shim.js","webpack:///./node_modules/es5-ext/number/to-integer.js","webpack:///./node_modules/es5-ext/number/to-pos-integer.js","webpack:///./node_modules/es5-ext/object/_iterate.js","webpack:///./node_modules/es5-ext/object/assign/index.js","webpack:///./node_modules/es5-ext/object/assign/is-implemented.js","webpack:///./node_modules/es5-ext/object/assign/shim.js","webpack:///./node_modules/es5-ext/object/copy.js","webpack:///./node_modules/es5-ext/object/create.js","webpack:///./node_modules/es5-ext/object/for-each.js","webpack:///./node_modules/es5-ext/object/is-callable.js","webpack:///./node_modules/es5-ext/object/is-object.js","webpack:///./node_modules/es5-ext/object/is-value.js","webpack:///./node_modules/es5-ext/object/keys/index.js","webpack:///./node_modules/es5-ext/object/keys/is-implemented.js","webpack:///./node_modules/es5-ext/object/keys/shim.js","webpack:///./node_modules/es5-ext/object/map.js","webpack:///./node_modules/es5-ext/object/normalize-options.js","webpack:///./node_modules/es5-ext/object/primitive-set.js","webpack:///./node_modules/es5-ext/object/set-prototype-of/index.js","webpack:///./node_modules/es5-ext/object/set-prototype-of/is-implemented.js","webpack:///./node_modules/es5-ext/object/set-prototype-of/shim.js","webpack:///./node_modules/es5-ext/object/valid-callable.js","webpack:///./node_modules/es5-ext/object/valid-value.js","webpack:///./node_modules/es5-ext/string/#/contains/index.js","webpack:///./node_modules/es5-ext/string/#/contains/is-implemented.js","webpack:///./node_modules/es5-ext/string/#/contains/shim.js","webpack:///./node_modules/es5-ext/string/is-string.js","webpack:///./node_modules/es6-iterator/array.js","webpack:///./node_modules/es6-iterator/for-of.js","webpack:///./node_modules/es6-iterator/get.js","webpack:///./node_modules/es6-iterator/index.js","webpack:///./node_modules/es6-iterator/is-iterable.js","webpack:///./node_modules/es6-iterator/string.js","webpack:///./node_modules/es6-iterator/valid-iterable.js","webpack:///./node_modules/es6-map/index.js","webpack:///./node_modules/es6-map/is-implemented.js","webpack:///./node_modules/es6-map/is-native-implemented.js","webpack:///./node_modules/es6-map/lib/iterator-kinds.js","webpack:///./node_modules/es6-map/lib/iterator.js","webpack:///./node_modules/es6-map/polyfill.js","webpack:///./node_modules/es6-symbol/index.js","webpack:///./node_modules/es6-symbol/is-implemented.js","webpack:///./node_modules/es6-symbol/is-symbol.js","webpack:///./node_modules/es6-symbol/polyfill.js","webpack:///./node_modules/es6-symbol/validate-symbol.js","webpack:///./node_modules/esrever/esrever.js","webpack:///./node_modules/event-emitter/index.js","webpack:///./node_modules/get-document/index.js","webpack:///./node_modules/get-window/index.js","webpack:///./node_modules/get-window/needs-ie-fallback.br.js","webpack:///./node_modules/immutable/dist/immutable.js","webpack:///./node_modules/is-empty/lib/index.js","webpack:///./node_modules/keycode/index.js","webpack:///./node_modules/ms/index.js","webpack:///./node_modules/react-dom/lib/ReactDOMServer.js","webpack:///./node_modules/react-dom/lib/ReactServerBatchingStrategy.js","webpack:///./node_modules/react-dom/lib/ReactServerRendering.js","webpack:///./node_modules/react-dom/server.js","webpack:///./node_modules/react-portal/build/portal.js","webpack:///./node_modules/selection-is-backward/index.js","webpack:///./node_modules/slate/lib/components/content.js","webpack:///./node_modules/slate/lib/components/editor.js","webpack:///./node_modules/slate/lib/components/leaf.js","webpack:///./node_modules/slate/lib/components/node.js","webpack:///./node_modules/slate/lib/components/placeholder.js","webpack:///./node_modules/slate/lib/components/void.js","webpack:///./node_modules/slate/lib/constants/environment.js","webpack:///./node_modules/slate/lib/constants/is-dev.js","webpack:///./node_modules/slate/lib/constants/model-types.js","webpack:///./node_modules/slate/lib/constants/transfer-types.js","webpack:///./node_modules/slate/lib/index.js","webpack:///./node_modules/slate/lib/models/block.js","webpack:///./node_modules/slate/lib/models/character.js","webpack:///./node_modules/slate/lib/models/data.js","webpack:///./node_modules/slate/lib/models/document.js","webpack:///./node_modules/slate/lib/models/inline.js","webpack:///./node_modules/slate/lib/models/mark.js","webpack:///./node_modules/slate/lib/models/node.js","webpack:///./node_modules/slate/lib/models/range.js","webpack:///./node_modules/slate/lib/models/schema.js","webpack:///./node_modules/slate/lib/models/selection.js","webpack:///./node_modules/slate/lib/models/stack.js","webpack:///./node_modules/slate/lib/models/state.js","webpack:///./node_modules/slate/lib/models/text.js","webpack:///./node_modules/slate/lib/models/transform.js","webpack:///./node_modules/slate/lib/plugins/core.js","webpack:///./node_modules/slate/lib/schemas/core.js","webpack:///./node_modules/slate/lib/serializers/base-64.js","webpack:///./node_modules/slate/lib/serializers/html.js","webpack:///./node_modules/slate/lib/serializers/plain.js","webpack:///./node_modules/slate/lib/serializers/raw.js","webpack:///./node_modules/slate/lib/transforms/apply-operation.js","webpack:///./node_modules/slate/lib/transforms/at-current-range.js","webpack:///./node_modules/slate/lib/transforms/at-range.js","webpack:///./node_modules/slate/lib/transforms/by-key.js","webpack:///./node_modules/slate/lib/transforms/call.js","webpack:///./node_modules/slate/lib/transforms/index.js","webpack:///./node_modules/slate/lib/transforms/normalize.js","webpack:///./node_modules/slate/lib/transforms/on-history.js","webpack:///./node_modules/slate/lib/transforms/on-selection.js","webpack:///./node_modules/slate/lib/transforms/operations.js","webpack:///./node_modules/slate/lib/utils/extend-selection.js","webpack:///./node_modules/slate/lib/utils/find-closest-node.js","webpack:///./node_modules/slate/lib/utils/find-deepest-node.js","webpack:///./node_modules/slate/lib/utils/find-dom-node.js","webpack:///./node_modules/slate/lib/utils/generate-key.js","webpack:///./node_modules/slate/lib/utils/get-html-from-native-paste.js","webpack:///./node_modules/slate/lib/utils/get-point.js","webpack:///./node_modules/slate/lib/utils/get-transfer-data.js","webpack:///./node_modules/slate/lib/utils/is-in-range.js","webpack:///./node_modules/slate/lib/utils/is-react-component.js","webpack:///./node_modules/slate/lib/utils/memoize.js","webpack:///./node_modules/slate/lib/utils/noop.js","webpack:///./node_modules/slate/lib/utils/normalize-node-and-offset.js","webpack:///./node_modules/slate/lib/utils/normalize.js","webpack:///./node_modules/slate/lib/utils/offset-key.js","webpack:///./node_modules/slate/lib/utils/prop-types.js","webpack:///./node_modules/slate/lib/utils/scroll-to-selection.js","webpack:///./node_modules/slate/lib/utils/set-transfer-data.js","webpack:///./node_modules/slate/lib/utils/string.js","webpack:///./node_modules/slate/lib/utils/warn.js","webpack:///./node_modules/type-of/index.js","webpack:///src/client/js/business/kernel/actions.js","webpack:///src/client/js/business/notebook/actions.js","webpack:///src/client/js/business/notebook/components/Editor/languages.js","webpack:///src/client/js/business/notebook/reducers/cells.js","webpack:///src/client/js/business/notebook/reducers/index.js","webpack:///src/client/js/business/notebook/reducers/slate.js"],"sourcesContent":["'use strict';\n\nvar copy             = require('es5-ext/object/copy')\n  , normalizeOptions = require('es5-ext/object/normalize-options')\n  , ensureCallable   = require('es5-ext/object/valid-callable')\n  , map              = require('es5-ext/object/map')\n  , callable         = require('es5-ext/object/valid-callable')\n  , validValue       = require('es5-ext/object/valid-value')\n\n  , bind = Function.prototype.bind, defineProperty = Object.defineProperty\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , define;\n\ndefine = function (name, desc, options) {\n\tvar value = validValue(desc) && callable(desc.value), dgs;\n\tdgs = copy(desc);\n\tdelete dgs.writable;\n\tdelete dgs.value;\n\tdgs.get = function () {\n\t\tif (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;\n\t\tdesc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);\n\t\tdefineProperty(this, name, desc);\n\t\treturn this[name];\n\t};\n\treturn dgs;\n};\n\nmodule.exports = function (props/*, options*/) {\n\tvar options = normalizeOptions(arguments[1]);\n\tif (options.resolveContext != null) ensureCallable(options.resolveContext);\n\treturn map(props, function (desc, name) { return define(name, desc, options); });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/d/auto-bind.js\n// module id = ./node_modules/d/auto-bind.js\n// module chunks = 0 2","'use strict';\n\nvar assign        = require('es5-ext/object/assign')\n  , normalizeOpts = require('es5-ext/object/normalize-options')\n  , isCallable    = require('es5-ext/object/is-callable')\n  , contains      = require('es5-ext/string/#/contains')\n\n  , d;\n\nd = module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif ((arguments.length < 2) || (typeof dscr !== 'string')) {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (dscr == null) {\n\t\tc = w = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t\tw = contains.call(dscr, 'w');\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== 'string') {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (get == null) {\n\t\tget = undefined;\n\t} else if (!isCallable(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (set == null) {\n\t\tset = undefined;\n\t} else if (!isCallable(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (dscr == null) {\n\t\tc = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/d/index.js\n// module id = ./node_modules/d/index.js\n// module chunks = 0 2","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/browser.js\n// module id = ./node_modules/debug/src/browser.js\n// module chunks = 0 2","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/debug/src/debug.js\n// module id = ./node_modules/debug/src/debug.js\n// module chunks = 0 2","'use strict';\n\nvar GROUP_LEFT_TO_RIGHT,\n    GROUP_RIGHT_TO_LEFT,\n    EXPRESSION_LEFT_TO_RIGHT,\n    EXPRESSION_RIGHT_TO_LEFT;\n\n/*\n * Character ranges of left-to-right characters.\n */\n\nGROUP_LEFT_TO_RIGHT = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n    '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n    '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n/*\n * Character ranges of right-to-left characters.\n */\n\nGROUP_RIGHT_TO_LEFT = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\n\n/*\n * Expression to match a left-to-right string.\n *\n * Matches the start of a string, followed by zero or\n * more non-right-to-left characters, followed by a\n * left-to-right character.\n */\n\nEXPRESSION_LEFT_TO_RIGHT = new RegExp(\n    '^[^' + GROUP_RIGHT_TO_LEFT + ']*[' + GROUP_LEFT_TO_RIGHT + ']'\n);\n\n/*\n * Expression to match a right-to-left string.\n *\n * Matches the start of a string, followed by zero or\n * more non-left-to-right characters, followed by a\n * right-to-left character.\n */\n\nEXPRESSION_RIGHT_TO_LEFT = new RegExp(\n    '^[^' + GROUP_LEFT_TO_RIGHT + ']*[' + GROUP_RIGHT_TO_LEFT + ']'\n);\n\n/**\n * Detect the direction of text.\n *\n * @param {string} value - value to stringify and check.\n * @return {string} - One of `\"rtl\"`, `\"ltr\"`, or\n *   `\"neutral\"`.\n */\nfunction direction(value) {\n    value = value.toString();\n\n    if (EXPRESSION_RIGHT_TO_LEFT.test(value)) {\n        return 'rtl';\n    }\n\n    if (EXPRESSION_LEFT_TO_RIGHT.test(value)) {\n        return 'ltr';\n    }\n\n    return 'neutral';\n}\n\n/*\n * Expose `direction`.\n */\n\nmodule.exports = direction;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/direction/index.js\n// module id = ./node_modules/direction/index.js\n// module chunks = 0 2","// Inspired by Google Closure:\n// http://closure-library.googlecode.com/svn/docs/\n// closure_goog_array_array.js.html#goog.array.clear\n\n\"use strict\";\n\nvar value = require(\"../../object/valid-value\");\n\nmodule.exports = function () {\n\tvalue(this).length = 0;\n\treturn this;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/array/#/clear.js\n// module id = ./node_modules/es5-ext/array/#/clear.js\n// module chunks = 0 2","\"use strict\";\n\nvar numberIsNaN       = require(\"../../number/is-nan\")\n  , toPosInt          = require(\"../../number/to-pos-integer\")\n  , value             = require(\"../../object/valid-value\")\n  , indexOf           = Array.prototype.indexOf\n  , objHasOwnProperty = Object.prototype.hasOwnProperty\n  , abs               = Math.abs\n  , floor             = Math.floor;\n\nmodule.exports = function (searchElement /*, fromIndex*/) {\n\tvar i, length, fromIndex, val;\n\tif (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);\n\n\tlength = toPosInt(value(this).length);\n\tfromIndex = arguments[1];\n\tif (isNaN(fromIndex)) fromIndex = 0;\n\telse if (fromIndex >= 0) fromIndex = floor(fromIndex);\n\telse fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n\n\tfor (i = fromIndex; i < length; ++i) {\n\t\tif (objHasOwnProperty.call(this, i)) {\n\t\t\tval = this[i];\n\t\t\tif (numberIsNaN(val)) return i; // Jslint: ignore\n\t\t}\n\t}\n\treturn -1;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/array/#/e-index-of.js\n// module id = ./node_modules/es5-ext/array/#/e-index-of.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? Array.from\n\t: require(\"./shim\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/array/from/index.js\n// module id = ./node_modules/es5-ext/array/from/index.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = function () {\n\tvar from = Array.from, arr, result;\n\tif (typeof from !== \"function\") return false;\n\tarr = [\"raz\", \"dwa\"];\n\tresult = from(arr);\n\treturn Boolean(result && (result !== arr) && (result[1] === \"dwa\"));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/array/from/is-implemented.js\n// module id = ./node_modules/es5-ext/array/from/is-implemented.js\n// module chunks = 0 2","\"use strict\";\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isArguments    = require(\"../../function/is-arguments\")\n  , isFunction     = require(\"../../function/is-function\")\n  , toPosInt       = require(\"../../number/to-pos-integer\")\n  , callable       = require(\"../../object/valid-callable\")\n  , validValue     = require(\"../../object/valid-value\")\n  , isValue        = require(\"../../object/is-value\")\n  , isString       = require(\"../../string/is-string\")\n  , isArray        = Array.isArray\n  , call           = Function.prototype.call\n  , desc           = { configurable: true, enumerable: true, writable: true, value: null }\n  , defineProperty = Object.defineProperty;\n\n// eslint-disable-next-line complexity\nmodule.exports = function (arrayLike /*, mapFn, thisArg*/) {\n\tvar mapFn = arguments[1]\n\t  , thisArg = arguments[2]\n\t  , Context\n\t  , i\n\t  , j\n\t  , arr\n\t  , length\n\t  , code\n\t  , iterator\n\t  , result\n\t  , getIterator\n\t  , value;\n\n\tarrayLike = Object(validValue(arrayLike));\n\n\tif (isValue(mapFn)) callable(mapFn);\n\tif (!this || this === Array || !isFunction(this)) {\n\t\t// Result: Plain array\n\t\tif (!mapFn) {\n\t\t\tif (isArguments(arrayLike)) {\n\t\t\t\t// Source: Arguments\n\t\t\t\tlength = arrayLike.length;\n\t\t\t\tif (length !== 1) return Array.apply(null, arrayLike);\n\t\t\t\tarr = new Array(1);\n\t\t\t\tarr[0] = arrayLike[0];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tif (isArray(arrayLike)) {\n\t\t\t\t// Source: Array\n\t\t\t\tarr = new Array(length = arrayLike.length);\n\t\t\t\tfor (i = 0; i < length; ++i) arr[i] = arrayLike[i];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t}\n\t\tarr = [];\n\t} else {\n\t\t// Result: Non plain array\n\t\tContext = this;\n\t}\n\n\tif (!isArray(arrayLike)) {\n\t\tif ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {\n\t\t\t// Source: Iterator\n\t\t\titerator = callable(getIterator).call(arrayLike);\n\t\t\tif (Context) arr = new Context();\n\t\t\tresult = iterator.next();\n\t\t\ti = 0;\n\t\t\twhile (!result.done) {\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[i] = value;\n\t\t\t\t}\n\t\t\t\tresult = iterator.next();\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tlength = i;\n\t\t} else if (isString(arrayLike)) {\n\t\t\t// Source: String\n\t\t\tlength = arrayLike.length;\n\t\t\tif (Context) arr = new Context();\n\t\t\tfor (i = 0, j = 0; i < length; ++i) {\n\t\t\t\tvalue = arrayLike[i];\n\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\tcode = value.charCodeAt(0);\n\t\t\t\t\t// eslint-disable-next-line max-depth\n\t\t\t\t\tif (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];\n\t\t\t\t}\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, value, j) : value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, j, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[j] = value;\n\t\t\t\t}\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tlength = j;\n\t\t}\n\t}\n\tif (length === undefined) {\n\t\t// Source: array or array-like\n\t\tlength = toPosInt(arrayLike.length);\n\t\tif (Context) arr = new Context(length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];\n\t\t\tif (Context) {\n\t\t\t\tdesc.value = value;\n\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t} else {\n\t\t\t\tarr[i] = value;\n\t\t\t}\n\t\t}\n\t}\n\tif (Context) {\n\t\tdesc.value = null;\n\t\tarr.length = length;\n\t}\n\treturn arr;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/array/from/shim.js\n// module id = ./node_modules/es5-ext/array/from/shim.js\n// module chunks = 0 2","\"use strict\";\n\nvar objToString = Object.prototype.toString\n  , id = objToString.call(\n\t(function () {\n\t\treturn arguments;\n\t})()\n);\n\nmodule.exports = function (value) {\n\treturn objToString.call(value) === id;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/function/is-arguments.js\n// module id = ./node_modules/es5-ext/function/is-arguments.js\n// module chunks = 0 2","\"use strict\";\n\nvar objToString = Object.prototype.toString, id = objToString.call(require(\"./noop\"));\n\nmodule.exports = function (value) {\n\treturn typeof value === \"function\" && objToString.call(value) === id;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/function/is-function.js\n// module id = ./node_modules/es5-ext/function/is-function.js\n// module chunks = 0 2","\"use strict\";\n\n// eslint-disable-next-line no-empty-function\nmodule.exports = function () {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/function/noop.js\n// module id = ./node_modules/es5-ext/function/noop.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? Math.sign\n\t: require(\"./shim\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/math/sign/index.js\n// module id = ./node_modules/es5-ext/math/sign/index.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = function () {\n\tvar sign = Math.sign;\n\tif (typeof sign !== \"function\") return false;\n\treturn (sign(10) === 1) && (sign(-20) === -1);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/math/sign/is-implemented.js\n// module id = ./node_modules/es5-ext/math/sign/is-implemented.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = function (value) {\n\tvalue = Number(value);\n\tif (isNaN(value) || (value === 0)) return value;\n\treturn value > 0 ? 1 : -1;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/math/sign/shim.js\n// module id = ./node_modules/es5-ext/math/sign/shim.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? Number.isNaN\n\t: require(\"./shim\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/number/is-nan/index.js\n// module id = ./node_modules/es5-ext/number/is-nan/index.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = function () {\n\tvar numberIsNaN = Number.isNaN;\n\tif (typeof numberIsNaN !== \"function\") return false;\n\treturn !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/number/is-nan/is-implemented.js\n// module id = ./node_modules/es5-ext/number/is-nan/is-implemented.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = function (value) {\n\t// eslint-disable-next-line no-self-compare\n\treturn value !== value;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/number/is-nan/shim.js\n// module id = ./node_modules/es5-ext/number/is-nan/shim.js\n// module chunks = 0 2","\"use strict\";\n\nvar sign = require(\"../math/sign\")\n\n  , abs = Math.abs, floor = Math.floor;\n\nmodule.exports = function (value) {\n\tif (isNaN(value)) return 0;\n\tvalue = Number(value);\n\tif ((value === 0) || !isFinite(value)) return value;\n\treturn sign(value) * floor(abs(value));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/number/to-integer.js\n// module id = ./node_modules/es5-ext/number/to-integer.js\n// module chunks = 0 2","\"use strict\";\n\nvar toInteger = require(\"./to-integer\")\n\n  , max = Math.max;\n\nmodule.exports = function (value) {\n return max(0, toInteger(value));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/number/to-pos-integer.js\n// module id = ./node_modules/es5-ext/number/to-pos-integer.js\n// module chunks = 0 2","// Internal method, used by iteration functions.\n// Calls a function for each key-value pair found in object\n// Optionally takes compareFn to iterate object in specific order\n\n\"use strict\";\n\nvar callable                = require(\"./valid-callable\")\n  , value                   = require(\"./valid-value\")\n  , bind                    = Function.prototype.bind\n  , call                    = Function.prototype.call\n  , keys                    = Object.keys\n  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = function (method, defVal) {\n\treturn function (obj, cb /*, thisArg, compareFn*/) {\n\t\tvar list, thisArg = arguments[2], compareFn = arguments[3];\n\t\tobj = Object(value(obj));\n\t\tcallable(cb);\n\n\t\tlist = keys(obj);\n\t\tif (compareFn) {\n\t\t\tlist.sort(typeof compareFn === \"function\" ? bind.call(compareFn, obj) : undefined);\n\t\t}\n\t\tif (typeof method !== \"function\") method = list[method];\n\t\treturn call.call(method, list, function (key, index) {\n\t\t\tif (!objPropertyIsEnumerable.call(obj, key)) return defVal;\n\t\t\treturn call.call(cb, thisArg, obj[key], key, obj, index);\n\t\t});\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/_iterate.js\n// module id = ./node_modules/es5-ext/object/_iterate.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? Object.assign\n\t: require(\"./shim\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/assign/index.js\n// module id = ./node_modules/es5-ext/object/assign/index.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== \"function\") return false;\n\tobj = { foo: \"raz\" };\n\tassign(obj, { bar: \"dwa\" }, { trzy: \"trzy\" });\n\treturn (obj.foo + obj.bar + obj.trzy) === \"razdwatrzy\";\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/assign/is-implemented.js\n// module id = ./node_modules/es5-ext/object/assign/is-implemented.js\n// module chunks = 0 2","\"use strict\";\n\nvar keys  = require(\"../keys\")\n  , value = require(\"../valid-value\")\n  , max   = Math.max;\n\nmodule.exports = function (dest, src /*, …srcn*/) {\n\tvar error, i, length = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry {\n\t\t\tdest[key] = src[key];\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < length; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/assign/shim.js\n// module id = ./node_modules/es5-ext/object/assign/shim.js\n// module chunks = 0 2","\"use strict\";\n\nvar aFrom  = require(\"../array/from\")\n  , assign = require(\"./assign\")\n  , value  = require(\"./valid-value\");\n\nmodule.exports = function (obj/*, propertyNames, options*/) {\n\tvar copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);\n\tif (copy !== obj && !propertyNames) return copy;\n\tvar result = {};\n\tif (propertyNames) {\n\t\taFrom(propertyNames, function (propertyName) {\n\t\t\tif (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];\n\t\t});\n\t} else {\n\t\tassign(result, obj);\n\t}\n\treturn result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/copy.js\n// module id = ./node_modules/es5-ext/object/copy.js\n// module chunks = 0 2","// Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n\"use strict\";\n\nvar create = Object.create, shim;\n\nif (!require(\"./set-prototype-of/is-implemented\")()) {\n\tshim = require(\"./set-prototype-of/shim\");\n}\n\nmodule.exports = (function () {\n\tvar nullObject, polyProps, desc;\n\tif (!shim) return create;\n\tif (shim.level !== 1) return create;\n\n\tnullObject = {};\n\tpolyProps = {};\n\tdesc = {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: true,\n\t\tvalue: undefined\n\t};\n\tObject.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n\t\tif (name === \"__proto__\") {\n\t\t\tpolyProps[name] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: undefined\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tpolyProps[name] = desc;\n\t});\n\tObject.defineProperties(nullObject, polyProps);\n\n\tObject.defineProperty(shim, \"nullPolyfill\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: nullObject\n\t});\n\n\treturn function (prototype, props) {\n\t\treturn create(prototype === null ? nullObject : prototype, props);\n\t};\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/create.js\n// module id = ./node_modules/es5-ext/object/create.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = require(\"./_iterate\")(\"forEach\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/for-each.js\n// module id = ./node_modules/es5-ext/object/for-each.js\n// module chunks = 0 2","// Deprecated\n\n\"use strict\";\n\nmodule.exports = function (obj) {\n return typeof obj === \"function\";\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/is-callable.js\n// module id = ./node_modules/es5-ext/object/is-callable.js\n// module chunks = 0 2","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar map = { function: true, object: true };\n\nmodule.exports = function (value) {\n\treturn (isValue(value) && map[typeof value]) || false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/is-object.js\n// module id = ./node_modules/es5-ext/object/is-object.js\n// module chunks = 0 2","\"use strict\";\n\nvar _undefined = require(\"../function/noop\")(); // Support ES3 engines\n\nmodule.exports = function (val) {\n return (val !== _undefined) && (val !== null);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/is-value.js\n// module id = ./node_modules/es5-ext/object/is-value.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? Object.keys\n\t: require(\"./shim\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/keys/index.js\n// module id = ./node_modules/es5-ext/object/keys/index.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys(\"primitive\");\n\t\treturn true;\n\t} catch (e) {\n return false;\n}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/keys/is-implemented.js\n// module id = ./node_modules/es5-ext/object/keys/is-implemented.js\n// module chunks = 0 2","\"use strict\";\n\nvar isValue = require(\"../is-value\");\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) {\n\treturn keys(isValue(object) ? Object(object) : object);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/keys/shim.js\n// module id = ./node_modules/es5-ext/object/keys/shim.js\n// module chunks = 0 2","\"use strict\";\n\nvar callable = require(\"./valid-callable\")\n  , forEach  = require(\"./for-each\")\n  , call     = Function.prototype.call;\n\nmodule.exports = function (obj, cb /*, thisArg*/) {\n\tvar result = {}, thisArg = arguments[2];\n\tcallable(cb);\n\tforEach(obj, function (value, key, targetObj, index) {\n\t\tresult[key] = call.call(cb, thisArg, value, key, targetObj, index);\n\t});\n\treturn result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/map.js\n// module id = ./node_modules/es5-ext/object/map.js\n// module chunks = 0 2","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (opts1 /*, …options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (!isValue(options)) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/normalize-options.js\n// module id = ./node_modules/es5-ext/object/normalize-options.js\n// module chunks = 0 2","\"use strict\";\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (arg /*, …args*/) {\n\tvar set = create(null);\n\tforEach.call(arguments, function (name) {\n\t\tset[name] = true;\n\t});\n\treturn set;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/primitive-set.js\n// module id = ./node_modules/es5-ext/object/primitive-set.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? Object.setPrototypeOf\n\t: require(\"./shim\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/set-prototype-of/index.js\n// module id = ./node_modules/es5-ext/object/set-prototype-of/index.js\n// module chunks = 0 2","\"use strict\";\n\nvar create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};\n\nmodule.exports = function (/* CustomCreate*/) {\n\tvar setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;\n\tif (typeof setPrototypeOf !== \"function\") return false;\n\treturn getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/set-prototype-of/is-implemented.js\n// module id = ./node_modules/es5-ext/object/set-prototype-of/is-implemented.js\n// module chunks = 0 2","/* eslint no-proto: \"off\" */\n\n// Big thanks to @WebReflection for sorting this out\n// https://gist.github.com/WebReflection/5593554\n\n\"use strict\";\n\nvar isObject        = require(\"../is-object\")\n  , value           = require(\"../valid-value\")\n  , objIsPrototypOf = Object.prototype.isPrototypeOf\n  , defineProperty  = Object.defineProperty\n  , nullDesc        = {\n\tconfigurable: true,\n\tenumerable: false,\n\twritable: true,\n\tvalue: undefined\n}\n  , validate;\n\nvalidate = function (obj, prototype) {\n\tvalue(obj);\n\tif (prototype === null || isObject(prototype)) return obj;\n\tthrow new TypeError(\"Prototype must be null or an object\");\n};\n\nmodule.exports = (function (status) {\n\tvar fn, set;\n\tif (!status) return null;\n\tif (status.level === 2) {\n\t\tif (status.set) {\n\t\t\tset = status.set;\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tset.call(validate(obj, prototype), prototype);\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t} else {\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tvalidate(obj, prototype).__proto__ = prototype;\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}\n\t} else {\n\t\tfn = function self (obj, prototype) {\n\t\t\tvar isNullBase;\n\t\t\tvalidate(obj, prototype);\n\t\t\tisNullBase = objIsPrototypOf.call(self.nullPolyfill, obj);\n\t\t\tif (isNullBase) delete self.nullPolyfill.__proto__;\n\t\t\tif (prototype === null) prototype = self.nullPolyfill;\n\t\t\tobj.__proto__ = prototype;\n\t\t\tif (isNullBase) defineProperty(self.nullPolyfill, \"__proto__\", nullDesc);\n\t\t\treturn obj;\n\t\t};\n\t}\n\treturn Object.defineProperty(fn, \"level\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: status.level\n\t});\n}(\n\t(function () {\n\t\tvar tmpObj1 = Object.create(null)\n\t\t  , tmpObj2 = {}\n\t\t  , set\n\t\t  , desc = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\");\n\n\t\tif (desc) {\n\t\t\ttry {\n\t\t\t\tset = desc.set; // Opera crashes at this point\n\t\t\t\tset.call(tmpObj1, tmpObj2);\n\t\t\t} catch (ignore) {}\n\t\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };\n\t\t}\n\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };\n\n\t\ttmpObj1 = {};\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };\n\n\t\treturn false;\n\t})()\n));\n\nrequire(\"../create\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/set-prototype-of/shim.js\n// module id = ./node_modules/es5-ext/object/set-prototype-of/shim.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/valid-callable.js\n// module id = ./node_modules/es5-ext/object/valid-callable.js\n// module chunks = 0 2","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/object/valid-value.js\n// module id = ./node_modules/es5-ext/object/valid-value.js\n// module chunks = 0 2","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? String.prototype.contains\n\t: require(\"./shim\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/string/#/contains/index.js\n// module id = ./node_modules/es5-ext/string/#/contains/index.js\n// module chunks = 0 2","\"use strict\";\n\nvar str = \"razdwatrzy\";\n\nmodule.exports = function () {\n\tif (typeof str.contains !== \"function\") return false;\n\treturn (str.contains(\"dwa\") === true) && (str.contains(\"foo\") === false);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/string/#/contains/is-implemented.js\n// module id = ./node_modules/es5-ext/string/#/contains/is-implemented.js\n// module chunks = 0 2","\"use strict\";\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/string/#/contains/shim.js\n// module id = ./node_modules/es5-ext/string/#/contains/shim.js\n// module chunks = 0 2","\"use strict\";\n\nvar objToString = Object.prototype.toString, id = objToString.call(\"\");\n\nmodule.exports = function (value) {\n\treturn (\n\t\ttypeof value === \"string\" ||\n\t\t(value &&\n\t\t\ttypeof value === \"object\" &&\n\t\t\t(value instanceof String || objToString.call(value) === id)) ||\n\t\tfalse\n\t);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es5-ext/string/is-string.js\n// module id = ./node_modules/es5-ext/string/is-string.js\n// module chunks = 0 2","'use strict';\n\nvar setPrototypeOf = require('es5-ext/object/set-prototype-of')\n  , contains       = require('es5-ext/string/#/contains')\n  , d              = require('d')\n  , Iterator       = require('./')\n\n  , defineProperty = Object.defineProperty\n  , ArrayIterator;\n\nArrayIterator = module.exports = function (arr, kind) {\n\tif (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);\n\tIterator.call(this, arr);\n\tif (!kind) kind = 'value';\n\telse if (contains.call(kind, 'key+value')) kind = 'key+value';\n\telse if (contains.call(kind, 'key')) kind = 'key';\n\telse kind = 'value';\n\tdefineProperty(this, '__kind__', d('', kind));\n};\nif (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\nArrayIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(ArrayIterator),\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === 'value') return this.__list__[i];\n\t\tif (this.__kind__ === 'key+value') return [i, this.__list__[i]];\n\t\treturn i;\n\t}),\n\ttoString: d(function () { return '[object Array Iterator]'; })\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-iterator/array.js\n// module id = ./node_modules/es6-iterator/array.js\n// module chunks = 0 2","'use strict';\n\nvar isArguments = require('es5-ext/function/is-arguments')\n  , callable    = require('es5-ext/object/valid-callable')\n  , isString    = require('es5-ext/string/is-string')\n  , get         = require('./get')\n\n  , isArray = Array.isArray, call = Function.prototype.call\n  , some = Array.prototype.some;\n\nmodule.exports = function (iterable, cb/*, thisArg*/) {\n\tvar mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;\n\tif (isArray(iterable) || isArguments(iterable)) mode = 'array';\n\telse if (isString(iterable)) mode = 'string';\n\telse iterable = get(iterable);\n\n\tcallable(cb);\n\tdoBreak = function () { broken = true; };\n\tif (mode === 'array') {\n\t\tsome.call(iterable, function (value) {\n\t\t\tcall.call(cb, thisArg, value, doBreak);\n\t\t\tif (broken) return true;\n\t\t});\n\t\treturn;\n\t}\n\tif (mode === 'string') {\n\t\tl = iterable.length;\n\t\tfor (i = 0; i < l; ++i) {\n\t\t\tchar = iterable[i];\n\t\t\tif ((i + 1) < l) {\n\t\t\t\tcode = char.charCodeAt(0);\n\t\t\t\tif ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];\n\t\t\t}\n\t\t\tcall.call(cb, thisArg, char, doBreak);\n\t\t\tif (broken) break;\n\t\t}\n\t\treturn;\n\t}\n\tresult = iterable.next();\n\n\twhile (!result.done) {\n\t\tcall.call(cb, thisArg, result.value, doBreak);\n\t\tif (broken) return;\n\t\tresult = iterable.next();\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-iterator/for-of.js\n// module id = ./node_modules/es6-iterator/for-of.js\n// module chunks = 0 2","'use strict';\n\nvar isArguments    = require('es5-ext/function/is-arguments')\n  , isString       = require('es5-ext/string/is-string')\n  , ArrayIterator  = require('./array')\n  , StringIterator = require('./string')\n  , iterable       = require('./valid-iterable')\n  , iteratorSymbol = require('es6-symbol').iterator;\n\nmodule.exports = function (obj) {\n\tif (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();\n\tif (isArguments(obj)) return new ArrayIterator(obj);\n\tif (isString(obj)) return new StringIterator(obj);\n\treturn new ArrayIterator(obj);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-iterator/get.js\n// module id = ./node_modules/es6-iterator/get.js\n// module chunks = 0 2","'use strict';\n\nvar clear    = require('es5-ext/array/#/clear')\n  , assign   = require('es5-ext/object/assign')\n  , callable = require('es5-ext/object/valid-callable')\n  , value    = require('es5-ext/object/valid-value')\n  , d        = require('d')\n  , autoBind = require('d/auto-bind')\n  , Symbol   = require('es6-symbol')\n\n  , defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , Iterator;\n\nmodule.exports = Iterator = function (list, context) {\n\tif (!(this instanceof Iterator)) return new Iterator(list, context);\n\tdefineProperties(this, {\n\t\t__list__: d('w', value(list)),\n\t\t__context__: d('w', context),\n\t\t__nextIndex__: d('w', 0)\n\t});\n\tif (!context) return;\n\tcallable(context.on);\n\tcontext.on('_add', this._onAdd);\n\tcontext.on('_delete', this._onDelete);\n\tcontext.on('_clear', this._onClear);\n};\n\ndefineProperties(Iterator.prototype, assign({\n\tconstructor: d(Iterator),\n\t_next: d(function () {\n\t\tvar i;\n\t\tif (!this.__list__) return;\n\t\tif (this.__redo__) {\n\t\t\ti = this.__redo__.shift();\n\t\t\tif (i !== undefined) return i;\n\t\t}\n\t\tif (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t}),\n\tnext: d(function () { return this._createResult(this._next()); }),\n\t_createResult: d(function (i) {\n\t\tif (i === undefined) return { done: true, value: undefined };\n\t\treturn { done: false, value: this._resolve(i) };\n\t}),\n\t_resolve: d(function (i) { return this.__list__[i]; }),\n\t_unBind: d(function () {\n\t\tthis.__list__ = null;\n\t\tdelete this.__redo__;\n\t\tif (!this.__context__) return;\n\t\tthis.__context__.off('_add', this._onAdd);\n\t\tthis.__context__.off('_delete', this._onDelete);\n\t\tthis.__context__.off('_clear', this._onClear);\n\t\tthis.__context__ = null;\n\t}),\n\ttoString: d(function () { return '[object Iterator]'; })\n}, autoBind({\n\t_onAdd: d(function (index) {\n\t\tif (index >= this.__nextIndex__) return;\n\t\t++this.__nextIndex__;\n\t\tif (!this.__redo__) {\n\t\t\tdefineProperty(this, '__redo__', d('c', [index]));\n\t\t\treturn;\n\t\t}\n\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\tif (redo >= index) this.__redo__[i] = ++redo;\n\t\t}, this);\n\t\tthis.__redo__.push(index);\n\t}),\n\t_onDelete: d(function (index) {\n\t\tvar i;\n\t\tif (index >= this.__nextIndex__) return;\n\t\t--this.__nextIndex__;\n\t\tif (!this.__redo__) return;\n\t\ti = this.__redo__.indexOf(index);\n\t\tif (i !== -1) this.__redo__.splice(i, 1);\n\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\tif (redo > index) this.__redo__[i] = --redo;\n\t\t}, this);\n\t}),\n\t_onClear: d(function () {\n\t\tif (this.__redo__) clear.call(this.__redo__);\n\t\tthis.__nextIndex__ = 0;\n\t})\n})));\n\ndefineProperty(Iterator.prototype, Symbol.iterator, d(function () {\n\treturn this;\n}));\ndefineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-iterator/index.js\n// module id = ./node_modules/es6-iterator/index.js\n// module chunks = 0 2","'use strict';\n\nvar isArguments    = require('es5-ext/function/is-arguments')\n  , isString       = require('es5-ext/string/is-string')\n  , iteratorSymbol = require('es6-symbol').iterator\n\n  , isArray = Array.isArray;\n\nmodule.exports = function (value) {\n\tif (value == null) return false;\n\tif (isArray(value)) return true;\n\tif (isString(value)) return true;\n\tif (isArguments(value)) return true;\n\treturn (typeof value[iteratorSymbol] === 'function');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-iterator/is-iterable.js\n// module id = ./node_modules/es6-iterator/is-iterable.js\n// module chunks = 0 2","// Thanks @mathiasbynens\n// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n'use strict';\n\nvar setPrototypeOf = require('es5-ext/object/set-prototype-of')\n  , d              = require('d')\n  , Iterator       = require('./')\n\n  , defineProperty = Object.defineProperty\n  , StringIterator;\n\nStringIterator = module.exports = function (str) {\n\tif (!(this instanceof StringIterator)) return new StringIterator(str);\n\tstr = String(str);\n\tIterator.call(this, str);\n\tdefineProperty(this, '__length__', d('', str.length));\n\n};\nif (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\nStringIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(StringIterator),\n\t_next: d(function () {\n\t\tif (!this.__list__) return;\n\t\tif (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t}),\n\t_resolve: d(function (i) {\n\t\tvar char = this.__list__[i], code;\n\t\tif (this.__nextIndex__ === this.__length__) return char;\n\t\tcode = char.charCodeAt(0);\n\t\tif ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];\n\t\treturn char;\n\t}),\n\ttoString: d(function () { return '[object String Iterator]'; })\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-iterator/string.js\n// module id = ./node_modules/es6-iterator/string.js\n// module chunks = 0 2","'use strict';\n\nvar isIterable = require('./is-iterable');\n\nmodule.exports = function (value) {\n\tif (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n\treturn value;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-iterator/valid-iterable.js\n// module id = ./node_modules/es6-iterator/valid-iterable.js\n// module chunks = 0 2","'use strict';\n\nmodule.exports = require('./is-implemented')() ? Map : require('./polyfill');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-map/index.js\n// module id = ./node_modules/es6-map/index.js\n// module chunks = 0 2","'use strict';\n\nmodule.exports = function () {\n\tvar map, iterator, result;\n\tif (typeof Map !== 'function') return false;\n\ttry {\n\t\t// WebKit doesn't support arguments and crashes\n\t\tmap = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\tif (String(map) !== '[object Map]') return false;\n\tif (map.size !== 3) return false;\n\tif (typeof map.clear !== 'function') return false;\n\tif (typeof map.delete !== 'function') return false;\n\tif (typeof map.entries !== 'function') return false;\n\tif (typeof map.forEach !== 'function') return false;\n\tif (typeof map.get !== 'function') return false;\n\tif (typeof map.has !== 'function') return false;\n\tif (typeof map.keys !== 'function') return false;\n\tif (typeof map.set !== 'function') return false;\n\tif (typeof map.values !== 'function') return false;\n\n\titerator = map.entries();\n\tresult = iterator.next();\n\tif (result.done !== false) return false;\n\tif (!result.value) return false;\n\tif (result.value[0] !== 'raz') return false;\n\tif (result.value[1] !== 'one') return false;\n\n\treturn true;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-map/is-implemented.js\n// module id = ./node_modules/es6-map/is-implemented.js\n// module chunks = 0 2","// Exports true if environment provides native `Map` implementation,\n// whatever that is.\n\n'use strict';\n\nmodule.exports = (function () {\n\tif (typeof Map === 'undefined') return false;\n\treturn (Object.prototype.toString.call(new Map()) === '[object Map]');\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-map/is-native-implemented.js\n// module id = ./node_modules/es6-map/is-native-implemented.js\n// module chunks = 0 2","'use strict';\n\nmodule.exports = require('es5-ext/object/primitive-set')('key',\n\t'value', 'key+value');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-map/lib/iterator-kinds.js\n// module id = ./node_modules/es6-map/lib/iterator-kinds.js\n// module chunks = 0 2","'use strict';\n\nvar setPrototypeOf    = require('es5-ext/object/set-prototype-of')\n  , d                 = require('d')\n  , Iterator          = require('es6-iterator')\n  , toStringTagSymbol = require('es6-symbol').toStringTag\n  , kinds             = require('./iterator-kinds')\n\n  , defineProperties = Object.defineProperties\n  , unBind = Iterator.prototype._unBind\n  , MapIterator;\n\nMapIterator = module.exports = function (map, kind) {\n\tif (!(this instanceof MapIterator)) return new MapIterator(map, kind);\n\tIterator.call(this, map.__mapKeysData__, map);\n\tif (!kind || !kinds[kind]) kind = 'key+value';\n\tdefineProperties(this, {\n\t\t__kind__: d('', kind),\n\t\t__values__: d('w', map.__mapValuesData__)\n\t});\n};\nif (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);\n\nMapIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(MapIterator),\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === 'value') return this.__values__[i];\n\t\tif (this.__kind__ === 'key') return this.__list__[i];\n\t\treturn [this.__list__[i], this.__values__[i]];\n\t}),\n\t_unBind: d(function () {\n\t\tthis.__values__ = null;\n\t\tunBind.call(this);\n\t}),\n\ttoString: d(function () { return '[object Map Iterator]'; })\n});\nObject.defineProperty(MapIterator.prototype, toStringTagSymbol,\n\td('c', 'Map Iterator'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-map/lib/iterator.js\n// module id = ./node_modules/es6-map/lib/iterator.js\n// module chunks = 0 2","'use strict';\n\nvar clear          = require('es5-ext/array/#/clear')\n  , eIndexOf       = require('es5-ext/array/#/e-index-of')\n  , setPrototypeOf = require('es5-ext/object/set-prototype-of')\n  , callable       = require('es5-ext/object/valid-callable')\n  , validValue     = require('es5-ext/object/valid-value')\n  , d              = require('d')\n  , ee             = require('event-emitter')\n  , Symbol         = require('es6-symbol')\n  , iterator       = require('es6-iterator/valid-iterable')\n  , forOf          = require('es6-iterator/for-of')\n  , Iterator       = require('./lib/iterator')\n  , isNative       = require('./is-native-implemented')\n\n  , call = Function.prototype.call\n  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf\n  , MapPoly;\n\nmodule.exports = MapPoly = function (/*iterable*/) {\n\tvar iterable = arguments[0], keys, values, self;\n\tif (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n\tif (isNative && setPrototypeOf && (Map !== MapPoly)) {\n\t\tself = setPrototypeOf(new Map(), getPrototypeOf(this));\n\t} else {\n\t\tself = this;\n\t}\n\tif (iterable != null) iterator(iterable);\n\tdefineProperties(self, {\n\t\t__mapKeysData__: d('c', keys = []),\n\t\t__mapValuesData__: d('c', values = [])\n\t});\n\tif (!iterable) return self;\n\tforOf(iterable, function (value) {\n\t\tvar key = validValue(value)[0];\n\t\tvalue = value[1];\n\t\tif (eIndexOf.call(keys, key) !== -1) return;\n\t\tkeys.push(key);\n\t\tvalues.push(value);\n\t}, self);\n\treturn self;\n};\n\nif (isNative) {\n\tif (setPrototypeOf) setPrototypeOf(MapPoly, Map);\n\tMapPoly.prototype = Object.create(Map.prototype, {\n\t\tconstructor: d(MapPoly)\n\t});\n}\n\nee(defineProperties(MapPoly.prototype, {\n\tclear: d(function () {\n\t\tif (!this.__mapKeysData__.length) return;\n\t\tclear.call(this.__mapKeysData__);\n\t\tclear.call(this.__mapValuesData__);\n\t\tthis.emit('_clear');\n\t}),\n\tdelete: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return false;\n\t\tthis.__mapKeysData__.splice(index, 1);\n\t\tthis.__mapValuesData__.splice(index, 1);\n\t\tthis.emit('_delete', index, key);\n\t\treturn true;\n\t}),\n\tentries: d(function () { return new Iterator(this, 'key+value'); }),\n\tforEach: d(function (cb/*, thisArg*/) {\n\t\tvar thisArg = arguments[1], iterator, result;\n\t\tcallable(cb);\n\t\titerator = this.entries();\n\t\tresult = iterator._next();\n\t\twhile (result !== undefined) {\n\t\t\tcall.call(cb, thisArg, this.__mapValuesData__[result],\n\t\t\t\tthis.__mapKeysData__[result], this);\n\t\t\tresult = iterator._next();\n\t\t}\n\t}),\n\tget: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return;\n\t\treturn this.__mapValuesData__[index];\n\t}),\n\thas: d(function (key) {\n\t\treturn (eIndexOf.call(this.__mapKeysData__, key) !== -1);\n\t}),\n\tkeys: d(function () { return new Iterator(this, 'key'); }),\n\tset: d(function (key, value) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key), emit;\n\t\tif (index === -1) {\n\t\t\tindex = this.__mapKeysData__.push(key) - 1;\n\t\t\temit = true;\n\t\t}\n\t\tthis.__mapValuesData__[index] = value;\n\t\tif (emit) this.emit('_add', index, key);\n\t\treturn this;\n\t}),\n\tsize: d.gs(function () { return this.__mapKeysData__.length; }),\n\tvalues: d(function () { return new Iterator(this, 'value'); }),\n\ttoString: d(function () { return '[object Map]'; })\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {\n\treturn this.entries();\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-map/polyfill.js\n// module id = ./node_modules/es6-map/polyfill.js\n// module chunks = 0 2","'use strict';\n\nmodule.exports = require('./is-implemented')() ? Symbol : require('./polyfill');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-symbol/index.js\n// module id = ./node_modules/es6-symbol/index.js\n// module chunks = 0 2","'use strict';\n\nvar validTypes = { object: true, symbol: true };\n\nmodule.exports = function () {\n\tvar symbol;\n\tif (typeof Symbol !== 'function') return false;\n\tsymbol = Symbol('test symbol');\n\ttry { String(symbol); } catch (e) { return false; }\n\n\t// Return 'true' also for polyfills\n\tif (!validTypes[typeof Symbol.iterator]) return false;\n\tif (!validTypes[typeof Symbol.toPrimitive]) return false;\n\tif (!validTypes[typeof Symbol.toStringTag]) return false;\n\n\treturn true;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-symbol/is-implemented.js\n// module id = ./node_modules/es6-symbol/is-implemented.js\n// module chunks = 0 2","'use strict';\n\nmodule.exports = function (x) {\n\tif (!x) return false;\n\tif (typeof x === 'symbol') return true;\n\tif (!x.constructor) return false;\n\tif (x.constructor.name !== 'Symbol') return false;\n\treturn (x[x.constructor.toStringTag] === 'Symbol');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-symbol/is-symbol.js\n// module id = ./node_modules/es6-symbol/is-symbol.js\n// module chunks = 0 2","// ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n'use strict';\n\nvar d              = require('d')\n  , validateSymbol = require('./validate-symbol')\n\n  , create = Object.create, defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty, objPrototype = Object.prototype\n  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)\n  , isNativeSafe;\n\nif (typeof Symbol === 'function') {\n\tNativeSymbol = Symbol;\n\ttry {\n\t\tString(NativeSymbol());\n\t\tisNativeSafe = true;\n\t} catch (ignore) {}\n}\n\nvar generateName = (function () {\n\tvar created = create(null);\n\treturn function (desc) {\n\t\tvar postfix = 0, name, ie11BugWorkaround;\n\t\twhile (created[desc + (postfix || '')]) ++postfix;\n\t\tdesc += (postfix || '');\n\t\tcreated[desc] = true;\n\t\tname = '@@' + desc;\n\t\tdefineProperty(objPrototype, name, d.gs(null, function (value) {\n\t\t\t// For IE11 issue see:\n\t\t\t// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n\t\t\t//    ie11-broken-getters-on-dom-objects\n\t\t\t// https://github.com/medikoo/es6-symbol/issues/12\n\t\t\tif (ie11BugWorkaround) return;\n\t\t\tie11BugWorkaround = true;\n\t\t\tdefineProperty(this, name, d(value));\n\t\t\tie11BugWorkaround = false;\n\t\t}));\n\t\treturn name;\n\t};\n}());\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');\n\tif (isNativeSafe) return NativeSymbol(description);\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = (description === undefined ? '' : String(description));\n\treturn defineProperties(symbol, {\n\t\t__description__: d('', description),\n\t\t__name__: d('', generateName(description))\n\t});\n};\ndefineProperties(SymbolPolyfill, {\n\tfor: d(function (key) {\n\t\tif (globalSymbols[key]) return globalSymbols[key];\n\t\treturn (globalSymbols[key] = SymbolPolyfill(String(key)));\n\t}),\n\tkeyFor: d(function (s) {\n\t\tvar key;\n\t\tvalidateSymbol(s);\n\t\tfor (key in globalSymbols) if (globalSymbols[key] === s) return key;\n\t}),\n\n\t// To ensure proper interoperability with other native functions (e.g. Array.from)\n\t// fallback to eventual native implementation of given symbol\n\thasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),\n\tisConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||\n\t\tSymbolPolyfill('isConcatSpreadable')),\n\titerator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),\n\tmatch: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),\n\treplace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),\n\tsearch: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),\n\tspecies: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),\n\tsplit: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),\n\ttoPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),\n\ttoStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),\n\tunscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))\n});\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d('', function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {\n\tvar symbol = validateSymbol(this);\n\tif (typeof symbol === 'symbol') return symbol;\n\treturn symbol.toString();\n}));\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-symbol/polyfill.js\n// module id = ./node_modules/es6-symbol/polyfill.js\n// module chunks = 0 2","'use strict';\n\nvar isSymbol = require('./is-symbol');\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-symbol/validate-symbol.js\n// module id = ./node_modules/es6-symbol/validate-symbol.js\n// module chunks = 0 2","/*! https://mths.be/esrever v0.2.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar regexSymbolWithCombiningMarks = /([\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])([\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]+)/g;\n\tvar regexSurrogatePair = /([\\uD800-\\uDBFF])([\\uDC00-\\uDFFF])/g;\n\n\tvar reverse = function(string) {\n\t\t// Step 1: deal with combining marks and astral symbols (surrogate pairs)\n\t\tstring = string\n\t\t\t// Swap symbols with their combining marks so the combining marks go first\n\t\t\t.replace(regexSymbolWithCombiningMarks, function($0, $1, $2) {\n\t\t\t\t// Reverse the combining marks so they will end up in the same order\n\t\t\t\t// later on (after another round of reversing)\n\t\t\t\treturn reverse($2) + $1;\n\t\t\t})\n\t\t\t// Swap high and low surrogates so the low surrogates go first\n\t\t\t.replace(regexSurrogatePair, '$2$1');\n\t\t// Step 2: reverse the code units in the string\n\t\tvar result = '';\n\t\tvar index = string.length;\n\t\twhile (index--) {\n\t\t\tresult += string.charAt(index);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar esrever = {\n\t\t'version': '0.2.0',\n\t\t'reverse': reverse\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn esrever;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = esrever;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in esrever) {\n\t\t\t\tesrever.hasOwnProperty(key) && (freeExports[key] = esrever[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.esrever = esrever;\n\t}\n\n}(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/esrever/esrever.js\n// module id = ./node_modules/esrever/esrever.js\n// module chunks = 0 2","'use strict';\n\nvar d        = require('d')\n  , callable = require('es5-ext/object/valid-callable')\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;\n\telse if (typeof data[type] === 'object') data[type].push(listener);\n\telse data[type] = [data[type], listener];\n\n\treturn this;\n};\n\nonce = function (type, listener) {\n\tvar once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, once = function () {\n\t\toff.call(self, type, once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\tonce.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function (type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif (typeof listeners === 'object') {\n\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\telse listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((listeners === listener) ||\n\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function (type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif (typeof listeners === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n\t\tlisteners = listeners.slice();\n\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tcall.call(listeners, this);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t}\n\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: once,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(once),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/event-emitter/index.js\n// module id = ./node_modules/event-emitter/index.js\n// module chunks = 0 2","\n/**\n * Module exports.\n */\n\nmodule.exports = getDocument;\n\n// defined by w3c\nvar DOCUMENT_NODE = 9;\n\n/**\n * Returns `true` if `w` is a Document object, or `false` otherwise.\n *\n * @param {?} d - Document object, maybe\n * @return {Boolean}\n * @private\n */\n\nfunction isDocument (d) {\n  return d && d.nodeType === DOCUMENT_NODE;\n}\n\n/**\n * Returns the `document` object associated with the given `node`, which may be\n * a DOM element, the Window object, a Selection, a Range. Basically any DOM\n * object that references the Document in some way, this function will find it.\n *\n * @param {Mixed} node - DOM node, selection, or range in which to find the `document` object\n * @return {Document} the `document` object associated with `node`\n * @public\n */\n\nfunction getDocument(node) {\n  if (isDocument(node)) {\n    return node;\n\n  } else if (isDocument(node.ownerDocument)) {\n    return node.ownerDocument;\n\n  } else if (isDocument(node.document)) {\n    return node.document;\n\n  } else if (node.parentNode) {\n    return getDocument(node.parentNode);\n\n  // Range support\n  } else if (node.commonAncestorContainer) {\n    return getDocument(node.commonAncestorContainer);\n\n  } else if (node.startContainer) {\n    return getDocument(node.startContainer);\n\n  // Selection support\n  } else if (node.anchorNode) {\n    return getDocument(node.anchorNode);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/get-document/index.js\n// module id = ./node_modules/get-document/index.js\n// module chunks = 0 2","\n/**\n * Module dependencies.\n */\n\nvar getDocument = require('get-document');\n\n/**\n * Module exports.\n */\n\nmodule.exports = getWindow;\n\nvar needsIEFallback = require('./needs-ie-fallback');\n\n/**\n * Returns `true` if `w` is a Window object, or `false` otherwise.\n *\n * @param {Mixed} w - Window object, maybe\n * @return {Boolean}\n * @private\n */\n\nfunction isWindow (w) {\n  return w && w.window === w;\n}\n\n/**\n * Returns the `window` object associated with the given `node`, which may be\n * a DOM element, the Window object, a Selection, a Range. Basically any DOM\n * object that references the Window in some way, this function will find it.\n *\n * @param {Mixed} node - DOM node, selection, or range in which to find the `window` object\n * @return {Window} the `window` object associated with `node`\n * @public\n */\n\nfunction getWindow(node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  var doc = getDocument(node);\n\n  if (needsIEFallback) {\n    // In IE 6-8, only the variable 'window' can be used to connect events (others\n    // may be only copies).\n    doc.parentWindow.execScript('document._parentWindow = window;', 'Javascript');\n    var win = doc._parentWindow;\n    // to prevent memory leak, unset it after use\n    // another possibility is to add an onUnload handler,\n    // (which seems overkill to @liucougar)\n    doc._parentWindow = null;\n    return win;\n  } else {\n    // standards-compliant and newer IE\n    return doc.defaultView || doc.parentWindow;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/get-window/index.js\n// module id = ./node_modules/get-window/index.js\n// module chunks = 0 2","// this is a browser-only module. There is a non-browser equivalent in the same\n// directory. This is done using a `package.json` browser field.\n// old-IE fallback logic: http://stackoverflow.com/a/10260692\nmodule.exports =  !!document.attachEvent && window !== document.parentWindow;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/get-window/needs-ie-fallback.br.js\n// module id = ./node_modules/get-window/needs-ie-fallback.br.js\n// module chunks = 0 2","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Immutable = factory());\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/immutable/dist/immutable.js\n// module id = ./node_modules/immutable/dist/immutable.js\n// module chunks = 0 2","\n/**\n * Has own property.\n *\n * @type {Function}\n */\n\nvar has = Object.prototype.hasOwnProperty\n\n/**\n * To string.\n *\n * @type {Function}\n */\n\nvar toString = Object.prototype.toString\n\n/**\n * Test whether a value is \"empty\".\n *\n * @param {Mixed} val\n * @return {Boolean}\n */\n\nfunction isEmpty(val) {\n  // Null and Undefined...\n  if (val == null) return true\n\n  // Booleans...\n  if ('boolean' == typeof val) return false\n\n  // Numbers...\n  if ('number' == typeof val) return val === 0\n\n  // Strings...\n  if ('string' == typeof val) return val.length === 0\n\n  // Functions...\n  if ('function' == typeof val) return val.length === 0\n\n  // Arrays...\n  if (Array.isArray(val)) return val.length === 0\n\n  // Errors...\n  if (val instanceof Error) return val.message === ''\n\n  // Objects...\n  if (val.toString == toString) {\n    switch (val.toString()) {\n\n      // Maps, Sets, Files and Errors...\n      case '[object File]':\n      case '[object Map]':\n      case '[object Set]': {\n        return val.size === 0\n      }\n\n      // Plain objects...\n      case '[object Object]': {\n        for (var key in val) {\n          if (has.call(val, key)) return false\n        }\n\n        return true\n      }\n    }\n  }\n\n  // Anything else...\n  return false\n}\n\n/**\n * Export `isEmpty`.\n *\n * @type {Function}\n */\n\nmodule.exports = isEmpty\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/is-empty/lib/index.js\n// module id = ./node_modules/is-empty/lib/index.js\n// module chunks = 0 2","// Source: http://jsfiddle.net/vWx8V/\n// http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes\n\n/**\n * Conenience method returns corresponding value for given keyName or keyCode.\n *\n * @param {Mixed} keyCode {Number} or keyName {String}\n * @return {Mixed}\n * @api public\n */\n\nexports = module.exports = function(searchInput) {\n  // Keyboard Events\n  if (searchInput && 'object' === typeof searchInput) {\n    var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode\n    if (hasKeyCode) searchInput = hasKeyCode\n  }\n\n  // Numbers\n  if ('number' === typeof searchInput) return names[searchInput]\n\n  // Everything else (cast to string)\n  var search = String(searchInput)\n\n  // check codes\n  var foundNamedKey = codes[search.toLowerCase()]\n  if (foundNamedKey) return foundNamedKey\n\n  // check aliases\n  var foundNamedKey = aliases[search.toLowerCase()]\n  if (foundNamedKey) return foundNamedKey\n\n  // weird character?\n  if (search.length === 1) return search.charCodeAt(0)\n\n  return undefined\n}\n\n/**\n * Get by name\n *\n *   exports.code['enter'] // => 13\n */\n\nvar codes = exports.code = exports.codes = {\n  'backspace': 8,\n  'tab': 9,\n  'enter': 13,\n  'shift': 16,\n  'ctrl': 17,\n  'alt': 18,\n  'pause/break': 19,\n  'caps lock': 20,\n  'esc': 27,\n  'space': 32,\n  'page up': 33,\n  'page down': 34,\n  'end': 35,\n  'home': 36,\n  'left': 37,\n  'up': 38,\n  'right': 39,\n  'down': 40,\n  'insert': 45,\n  'delete': 46,\n  'command': 91,\n  'left command': 91,\n  'right command': 93,\n  'numpad *': 106,\n  'numpad +': 107,\n  'numpad -': 109,\n  'numpad .': 110,\n  'numpad /': 111,\n  'num lock': 144,\n  'scroll lock': 145,\n  'my computer': 182,\n  'my calculator': 183,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  \"'\": 222\n}\n\n// Helper aliases\n\nvar aliases = exports.aliases = {\n  'windows': 91,\n  '⇧': 16,\n  '⌥': 18,\n  '⌃': 17,\n  '⌘': 91,\n  'ctl': 17,\n  'control': 17,\n  'option': 18,\n  'pause': 19,\n  'break': 19,\n  'caps': 20,\n  'return': 13,\n  'escape': 27,\n  'spc': 32,\n  'pgup': 33,\n  'pgdn': 34,\n  'ins': 45,\n  'del': 46,\n  'cmd': 91\n}\n\n\n/*!\n * Programatically add the following\n */\n\n// lower case chars\nfor (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32\n\n// numbers\nfor (var i = 48; i < 58; i++) codes[i - 48] = i\n\n// function keys\nfor (i = 1; i < 13; i++) codes['f'+i] = i + 111\n\n// numpad keys\nfor (i = 0; i < 10; i++) codes['numpad '+i] = i + 96\n\n/**\n * Get by code\n *\n *   exports.name[13] // => 'Enter'\n */\n\nvar names = exports.names = exports.title = {} // title for backward compat\n\n// Create reverse mapping\nfor (i in codes) names[codes[i]] = i\n\n// Add aliases\nfor (var alias in aliases) {\n  codes[alias] = aliases[alias]\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/keycode/index.js\n// module id = ./node_modules/keycode/index.js\n// module chunks = 0 2 3 4","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms/index.js\n// module id = ./node_modules/ms/index.js\n// module chunks = 0 2","/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar ReactDefaultInjection = require('./ReactDefaultInjection');\nvar ReactServerRendering = require('./ReactServerRendering');\nvar ReactVersion = require('./ReactVersion');\n\nReactDefaultInjection.inject();\n\nvar ReactDOMServer = {\n  renderToString: ReactServerRendering.renderToString,\n  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,\n  version: ReactVersion\n};\n\nmodule.exports = ReactDOMServer;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-dom/lib/ReactDOMServer.js\n// module id = ./node_modules/react-dom/lib/ReactDOMServer.js\n// module chunks = 0 2","/**\n * Copyright 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar ReactServerBatchingStrategy = {\n  isBatchingUpdates: false,\n  batchedUpdates: function (callback) {\n    // Don't do anything here. During the server rendering we don't want to\n    // schedule any updates. We will simply ignore them.\n  }\n};\n\nmodule.exports = ReactServerBatchingStrategy;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-dom/lib/ReactServerBatchingStrategy.js\n// module id = ./node_modules/react-dom/lib/ReactServerBatchingStrategy.js\n// module chunks = 0 2","/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar React = require('react/lib/React');\nvar ReactDOMContainerInfo = require('./ReactDOMContainerInfo');\nvar ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');\nvar ReactInstrumentation = require('./ReactInstrumentation');\nvar ReactMarkupChecksum = require('./ReactMarkupChecksum');\nvar ReactReconciler = require('./ReactReconciler');\nvar ReactServerBatchingStrategy = require('./ReactServerBatchingStrategy');\nvar ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar instantiateReactComponent = require('./instantiateReactComponent');\nvar invariant = require('fbjs/lib/invariant');\n\nvar pendingTransactions = 0;\n\n/**\n * @param {ReactElement} element\n * @return {string} the HTML markup\n */\nfunction renderToStringImpl(element, makeStaticMarkup) {\n  var transaction;\n  try {\n    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);\n\n    transaction = ReactServerRenderingTransaction.getPooled(makeStaticMarkup);\n\n    pendingTransactions++;\n\n    return transaction.perform(function () {\n      var componentInstance = instantiateReactComponent(element, true);\n      var markup = ReactReconciler.mountComponent(componentInstance, transaction, null, ReactDOMContainerInfo(), emptyObject, 0 /* parentDebugID */\n      );\n      if (process.env.NODE_ENV !== 'production') {\n        ReactInstrumentation.debugTool.onUnmountComponent(componentInstance._debugID);\n      }\n      if (!makeStaticMarkup) {\n        markup = ReactMarkupChecksum.addChecksumToMarkup(markup);\n      }\n      return markup;\n    }, null);\n  } finally {\n    pendingTransactions--;\n    ReactServerRenderingTransaction.release(transaction);\n    // Revert to the DOM batching strategy since these two renderers\n    // currently share these stateful modules.\n    if (!pendingTransactions) {\n      ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);\n    }\n  }\n}\n\n/**\n * Render a ReactElement to its initial HTML. This should only be used on the\n * server.\n * See https://facebook.github.io/react/docs/top-level-api.html#reactdomserver.rendertostring\n */\nfunction renderToString(element) {\n  !React.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : _prodInvariant('46') : void 0;\n  return renderToStringImpl(element, false);\n}\n\n/**\n * Similar to renderToString, except this doesn't create extra DOM attributes\n * such as data-react-id that React uses internally.\n * See https://facebook.github.io/react/docs/top-level-api.html#reactdomserver.rendertostaticmarkup\n */\nfunction renderToStaticMarkup(element) {\n  !React.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : _prodInvariant('47') : void 0;\n  return renderToStringImpl(element, true);\n}\n\nmodule.exports = {\n  renderToString: renderToString,\n  renderToStaticMarkup: renderToStaticMarkup\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-dom/lib/ReactServerRendering.js\n// module id = ./node_modules/react-dom/lib/ReactServerRendering.js\n// module chunks = 0 2","'use strict';\n\nmodule.exports = require('./lib/ReactDOMServer');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-dom/server.js\n// module id = ./node_modules/react-dom/server.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar KEYCODES = {\n  ESCAPE: 27\n};\n\nvar Portal = function (_React$Component) {\n  _inherits(Portal, _React$Component);\n\n  function Portal() {\n    _classCallCheck(this, Portal);\n\n    var _this = _possibleConstructorReturn(this, (Portal.__proto__ || Object.getPrototypeOf(Portal)).call(this));\n\n    _this.state = { active: false };\n    _this.handleWrapperClick = _this.handleWrapperClick.bind(_this);\n    _this.closePortal = _this.closePortal.bind(_this);\n    _this.handleOutsideMouseClick = _this.handleOutsideMouseClick.bind(_this);\n    _this.handleKeydown = _this.handleKeydown.bind(_this);\n    _this.portal = null;\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(Portal, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (this.props.closeOnEsc) {\n        document.addEventListener('keydown', this.handleKeydown);\n      }\n\n      if (this.props.closeOnOutsideClick) {\n        document.addEventListener('mouseup', this.handleOutsideMouseClick);\n        document.addEventListener('touchstart', this.handleOutsideMouseClick);\n      }\n\n      if (this.props.isOpened) {\n        this.openPortal();\n      }\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(newProps) {\n      // portal's 'is open' state is handled through the prop isOpened\n      if (typeof newProps.isOpened !== 'undefined') {\n        if (newProps.isOpened) {\n          if (this.state.active) {\n            this.renderPortal(newProps);\n          } else {\n            this.openPortal(newProps);\n          }\n        }\n        if (!newProps.isOpened && this.state.active) {\n          this.closePortal();\n        }\n      }\n\n      // portal handles its own 'is open' state\n      if (typeof newProps.isOpened === 'undefined' && this.state.active) {\n        this.renderPortal(newProps);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this.props.closeOnEsc) {\n        document.removeEventListener('keydown', this.handleKeydown);\n      }\n\n      if (this.props.closeOnOutsideClick) {\n        document.removeEventListener('mouseup', this.handleOutsideMouseClick);\n        document.removeEventListener('touchstart', this.handleOutsideMouseClick);\n      }\n\n      this.closePortal(true);\n    }\n  }, {\n    key: 'handleWrapperClick',\n    value: function handleWrapperClick(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      if (this.state.active) {\n        return;\n      }\n      this.openPortal();\n    }\n  }, {\n    key: 'openPortal',\n    value: function openPortal() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\n      this.setState({ active: true });\n      this.renderPortal(props);\n      this.props.onOpen(this.node);\n    }\n  }, {\n    key: 'closePortal',\n    value: function closePortal() {\n      var _this2 = this;\n\n      var isUnmounted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var resetPortalState = function resetPortalState() {\n        if (_this2.node) {\n          _reactDom2.default.unmountComponentAtNode(_this2.node);\n          document.body.removeChild(_this2.node);\n        }\n        _this2.portal = null;\n        _this2.node = null;\n        if (isUnmounted !== true) {\n          _this2.setState({ active: false });\n        }\n      };\n\n      if (this.state.active) {\n        if (this.props.beforeClose) {\n          this.props.beforeClose(this.node, resetPortalState);\n        } else {\n          resetPortalState();\n        }\n\n        this.props.onClose();\n      }\n    }\n  }, {\n    key: 'handleOutsideMouseClick',\n    value: function handleOutsideMouseClick(e) {\n      if (!this.state.active) {\n        return;\n      }\n\n      var root = (0, _reactDom.findDOMNode)(this.portal);\n      if (root.contains(e.target) || e.button && e.button !== 0) {\n        return;\n      }\n\n      e.stopPropagation();\n      this.closePortal();\n    }\n  }, {\n    key: 'handleKeydown',\n    value: function handleKeydown(e) {\n      if (e.keyCode === KEYCODES.ESCAPE && this.state.active) {\n        this.closePortal();\n      }\n    }\n  }, {\n    key: 'renderPortal',\n    value: function renderPortal(props) {\n      if (!this.node) {\n        this.node = document.createElement('div');\n        document.body.appendChild(this.node);\n      }\n\n      var children = props.children;\n      // https://gist.github.com/jimfb/d99e0678e9da715ccf6454961ef04d1b\n      if (typeof props.children.type === 'function') {\n        children = _react2.default.cloneElement(props.children, { closePortal: this.closePortal });\n      }\n\n      this.portal = _reactDom2.default.unstable_renderSubtreeIntoContainer(this, children, this.node, this.props.onUpdate);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      if (this.props.openByClickOn) {\n        return _react2.default.cloneElement(this.props.openByClickOn, { onClick: this.handleWrapperClick });\n      }\n      return null;\n    }\n  }]);\n\n  return Portal;\n}(_react2.default.Component);\n\nexports.default = Portal;\n\n\nPortal.propTypes = {\n  children: _propTypes2.default.element.isRequired,\n  openByClickOn: _propTypes2.default.element,\n  closeOnEsc: _propTypes2.default.bool,\n  closeOnOutsideClick: _propTypes2.default.bool,\n  isOpened: _propTypes2.default.bool,\n  onOpen: _propTypes2.default.func,\n  onClose: _propTypes2.default.func,\n  beforeClose: _propTypes2.default.func,\n  onUpdate: _propTypes2.default.func\n};\n\nPortal.defaultProps = {\n  onOpen: function onOpen() {},\n  onClose: function onClose() {},\n  onUpdate: function onUpdate() {}\n};\nmodule.exports = exports['default'];\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-portal/build/portal.js\n// module id = ./node_modules/react-portal/build/portal.js\n// module chunks = 0 2","function isBackward(selection) {\n    var startNode = selection.anchorNode;\n    var startOffset = selection.anchorOffset;\n    var endNode = selection.focusNode;\n    var endOffset = selection.focusOffset;\n\n    var position = startNode.compareDocumentPosition(endNode);\n\n    return !(position === 4 || (position === 0 && startOffset < endOffset));\n}\n\nmodule.exports = isBackward;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/selection-is-backward/index.js\n// module id = ./node_modules/selection-is-backward/index.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nvar _keycode = require('keycode');\n\nvar _keycode2 = _interopRequireDefault(_keycode);\n\nvar _transferTypes = require('../constants/transfer-types');\n\nvar _transferTypes2 = _interopRequireDefault(_transferTypes);\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _selection = require('../models/selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _extendSelection = require('../utils/extend-selection');\n\nvar _extendSelection2 = _interopRequireDefault(_extendSelection);\n\nvar _findClosestNode = require('../utils/find-closest-node');\n\nvar _findClosestNode2 = _interopRequireDefault(_findClosestNode);\n\nvar _findDeepestNode = require('../utils/find-deepest-node');\n\nvar _findDeepestNode2 = _interopRequireDefault(_findDeepestNode);\n\nvar _getPoint = require('../utils/get-point');\n\nvar _getPoint2 = _interopRequireDefault(_getPoint);\n\nvar _getTransferData = require('../utils/get-transfer-data');\n\nvar _getTransferData2 = _interopRequireDefault(_getTransferData);\n\nvar _setTransferData = require('../utils/set-transfer-data');\n\nvar _setTransferData2 = _interopRequireDefault(_setTransferData);\n\nvar _getHtmlFromNativePaste = require('../utils/get-html-from-native-paste');\n\nvar _getHtmlFromNativePaste2 = _interopRequireDefault(_getHtmlFromNativePaste);\n\nvar _environment = require('../constants/environment');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:content');\n\n/**\n * Content.\n *\n * @type {Component}\n */\n\nvar Content = function (_React$Component) {\n  _inherits(Content, _React$Component);\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  function Content(props) {\n    _classCallCheck(this, Content);\n\n    var _this = _possibleConstructorReturn(this, (Content.__proto__ || Object.getPrototypeOf(Content)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    _this.tmp = {};\n    _this.tmp.compositions = 0;\n    _this.tmp.forces = 0;\n    return _this;\n  }\n\n  /**\n   * Should the component update?\n   *\n   * @param {Object} props\n   * @param {Object} state\n   * @return {Boolean}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * When the editor first mounts in the DOM we need to:\n   *\n   *   - Update the selection, in case it starts focused.\n   *   - Focus the editor if `autoFocus` is set.\n   */\n\n  /**\n   * On update, update the selection.\n   */\n\n  /**\n   * Update the native DOM selection to reflect the internal model.\n   */\n\n  /**\n   * The React ref method to set the root content element locally.\n   *\n   * @param {Element} n\n   */\n\n  /**\n   * Check if an event `target` is fired from within the contenteditable\n   * element. This should be false for edits happening in non-contenteditable\n   * children, such as void nodes and other nested Slate editors.\n   *\n   * @param {Element} target\n   * @return {Boolean}\n   */\n\n  /**\n   * On before input, bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On blur, update the selection to be not focused.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On focus, update the selection to be focused.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On change, bubble up.\n   *\n   * @param {State} state\n   */\n\n  /**\n   * On composition start, set the `isComposing` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On composition end, remove the `isComposing` flag on the next tick. Also\n   * increment the `forces` key, which will force the contenteditable element\n   * to completely re-render, since IME puts React in an unreconcilable state.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On copy, defer to `onCutCopy`, then bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On cut, defer to `onCutCopy`, then bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On drag end, unset the `isDragging` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On drag over, set the `isDragging` flag and the `isInternalDrag` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On drag start, set the `isDragging` flag and the `isInternalDrag` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On input, handle spellcheck and other similar edits that don't go trigger\n   * the `onBeforeInput` and instead update the DOM directly.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On key down, prevent the default behavior of certain commands that will\n   * leave the editor in an out-of-sync state, then bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On key up, unset the `isShifting` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On paste, determine the type and bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On select, update the current state's selection.\n   *\n   * @param {Event} event\n   */\n\n  _createClass(Content, [{\n    key: 'render',\n\n\n    /**\n     * Render the editor content.\n     *\n     * @return {Element}\n     */\n\n    value: function render() {\n      var _this2 = this;\n\n      var props = this.props;\n      var className = props.className,\n          readOnly = props.readOnly,\n          state = props.state,\n          tabIndex = props.tabIndex,\n          role = props.role,\n          tagName = props.tagName;\n\n      var Container = tagName;\n      var document = state.document;\n\n      var children = document.nodes.map(function (node) {\n        return _this2.renderNode(node);\n      }).toArray();\n\n      var style = _extends({\n        // Prevent the default outline styles.\n        outline: 'none',\n        // Preserve adjacent whitespace and new lines.\n        whiteSpace: 'pre-wrap',\n        // Allow words to break if they are too long.\n        wordWrap: 'break-word'\n      }, readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }, props.style);\n\n      // COMPAT: In Firefox, spellchecking can remove entire wrapping elements\n      // including inline ones like `<a>`, which is jarring for the user but also\n      // causes the DOM to get into an irreconcilable state. (2016/09/01)\n      var spellCheck = _environment.IS_FIREFOX ? false : props.spellCheck;\n\n      debug('render', { props: props });\n\n      return _react2.default.createElement(\n        Container,\n        {\n          'data-slate-editor': true,\n          key: this.tmp.forces,\n          ref: this.ref,\n          'data-key': document.key,\n          contentEditable: !readOnly,\n          suppressContentEditableWarning: true,\n          className: className,\n          onBeforeInput: this.onBeforeInput,\n          onBlur: this.onBlur,\n          onFocus: this.onFocus,\n          onCompositionEnd: this.onCompositionEnd,\n          onCompositionStart: this.onCompositionStart,\n          onCopy: this.onCopy,\n          onCut: this.onCut,\n          onDragEnd: this.onDragEnd,\n          onDragOver: this.onDragOver,\n          onDragStart: this.onDragStart,\n          onDrop: this.onDrop,\n          onInput: this.onInput,\n          onKeyDown: this.onKeyDown,\n          onKeyUp: this.onKeyUp,\n          onPaste: this.onPaste,\n          onSelect: this.onSelect,\n          autoCorrect: props.autoCorrect,\n          spellCheck: spellCheck,\n          style: style,\n          role: readOnly ? null : role || 'textbox',\n          tabIndex: tabIndex\n          // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n          // from under `contenteditable` elements, which leads to weird behaviors\n          // so we have to disable it like this. (2017/04/24)\n          , 'data-gramm': false\n        },\n        children,\n        this.props.children\n      );\n    }\n\n    /**\n     * Render a `node`.\n     *\n     * @param {Node} node\n     * @return {Element}\n     */\n\n  }]);\n\n  return Content;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nContent.propTypes = {\n  autoCorrect: _propTypes2.default.bool.isRequired,\n  autoFocus: _propTypes2.default.bool.isRequired,\n  children: _propTypes2.default.array.isRequired,\n  className: _propTypes2.default.string,\n  editor: _propTypes2.default.object.isRequired,\n  onBeforeInput: _propTypes2.default.func.isRequired,\n  onBlur: _propTypes2.default.func.isRequired,\n  onChange: _propTypes2.default.func.isRequired,\n  onCopy: _propTypes2.default.func.isRequired,\n  onCut: _propTypes2.default.func.isRequired,\n  onDrop: _propTypes2.default.func.isRequired,\n  onFocus: _propTypes2.default.func.isRequired,\n  onKeyDown: _propTypes2.default.func.isRequired,\n  onPaste: _propTypes2.default.func.isRequired,\n  onSelect: _propTypes2.default.func.isRequired,\n  readOnly: _propTypes2.default.bool.isRequired,\n  role: _propTypes2.default.string,\n  schema: _propTypes2.default.object,\n  spellCheck: _propTypes2.default.bool.isRequired,\n  state: _propTypes2.default.object.isRequired,\n  style: _propTypes2.default.object,\n  tabIndex: _propTypes2.default.number,\n  tagName: _propTypes2.default.string\n};\nContent.defaultProps = {\n  style: {},\n  tagName: 'div'\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  this.shouldComponentUpdate = function (props, state) {\n    // If the readOnly state has changed, we need to re-render so that\n    // the cursor will be added or removed again.\n    if (props.readOnly != _this3.props.readOnly) return true;\n\n    // If the state has been transformed natively, never re-render, or else we\n    // will end up duplicating content.\n    if (props.state.isNative) return false;\n\n    return props.className != _this3.props.className || props.schema != _this3.props.schema || props.autoCorrect != _this3.props.autoCorrect || props.spellCheck != _this3.props.spellCheck || props.state != _this3.props.state || props.style != _this3.props.style;\n  };\n\n  this.componentDidMount = function () {\n    _this3.updateSelection();\n\n    if (_this3.props.autoFocus) {\n      _this3.element.focus();\n    }\n  };\n\n  this.componentDidUpdate = function () {\n    _this3.updateSelection();\n  };\n\n  this.updateSelection = function () {\n    var _props = _this3.props,\n        editor = _props.editor,\n        state = _props.state;\n    var document = state.document,\n        selection = state.selection;\n\n    var window = (0, _getWindow2.default)(_this3.element);\n    var native = window.getSelection();\n\n    // If both selections are blurred, do nothing.\n    if (!native.rangeCount && selection.isBlurred) return;\n\n    // If the selection has been blurred, but is still inside the editor in the\n    // DOM, blur it manually.\n    if (selection.isBlurred) {\n      if (!_this3.isInEditor(native.anchorNode)) return;\n      native.removeAllRanges();\n      _this3.element.blur();\n      debug('updateSelection', { selection: selection, native: native });\n      return;\n    }\n\n    // Otherwise, figure out which DOM nodes should be selected...\n    var anchorText = state.anchorText,\n        focusText = state.focusText;\n    var anchorKey = selection.anchorKey,\n        anchorOffset = selection.anchorOffset,\n        focusKey = selection.focusKey,\n        focusOffset = selection.focusOffset;\n\n    var schema = editor.getSchema();\n    var anchorDecorators = document.getDescendantDecorators(anchorKey, schema);\n    var focusDecorators = document.getDescendantDecorators(focusKey, schema);\n    var anchorRanges = anchorText.getRanges(anchorDecorators);\n    var focusRanges = focusText.getRanges(focusDecorators);\n    var a = 0;\n    var f = 0;\n    var anchorIndex = void 0;\n    var focusIndex = void 0;\n    var anchorOff = void 0;\n    var focusOff = void 0;\n\n    anchorRanges.forEach(function (range, i, ranges) {\n      var length = range.text.length;\n\n      a += length;\n      if (a < anchorOffset) return;\n      anchorIndex = i;\n      anchorOff = anchorOffset - (a - length);\n      return false;\n    });\n\n    focusRanges.forEach(function (range, i, ranges) {\n      var length = range.text.length;\n\n      f += length;\n      if (f < focusOffset) return;\n      focusIndex = i;\n      focusOff = focusOffset - (f - length);\n      return false;\n    });\n\n    var anchorSpan = _this3.element.querySelector('[data-offset-key=\"' + anchorKey + '-' + anchorIndex + '\"]');\n    var focusSpan = _this3.element.querySelector('[data-offset-key=\"' + focusKey + '-' + focusIndex + '\"]');\n    var anchorEl = (0, _findDeepestNode2.default)(anchorSpan);\n    var focusEl = (0, _findDeepestNode2.default)(focusSpan);\n\n    // If they are already selected, do nothing.\n    if (anchorEl == native.anchorNode && anchorOff == native.anchorOffset && focusEl == native.focusNode && focusOff == native.focusOffset) {\n      return;\n    }\n\n    // Otherwise, set the `isSelecting` flag and update the selection.\n    _this3.tmp.isSelecting = true;\n    native.removeAllRanges();\n    var range = window.document.createRange();\n    range.setStart(anchorEl, anchorOff);\n    native.addRange(range);\n    (0, _extendSelection2.default)(native, focusEl, focusOff);\n\n    // Then unset the `isSelecting` flag after a delay.\n    setTimeout(function () {\n      // COMPAT: In Firefox, it's not enough to create a range, you also need to\n      // focus the contenteditable element too. (2016/11/16)\n      if (_environment.IS_FIREFOX) _this3.element.focus();\n      _this3.tmp.isSelecting = false;\n    });\n\n    debug('updateSelection', { selection: selection, native: native });\n  };\n\n  this.ref = function (element) {\n    _this3.element = element;\n  };\n\n  this.isInEditor = function (target) {\n    var element = _this3.element;\n    // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n    // `target` is a text node use its parent node for check.\n\n    var el = target.nodeType === 3 ? target.parentNode : target;\n    return el.isContentEditable && (el === element || (0, _findClosestNode2.default)(el, '[data-slate-editor]') === element);\n  };\n\n  this.onBeforeInput = function (event) {\n    if (_this3.props.readOnly) return;\n    if (!_this3.isInEditor(event.target)) return;\n\n    var data = {};\n\n    debug('onBeforeInput', { event: event, data: data });\n    _this3.props.onBeforeInput(event, data);\n  };\n\n  this.onBlur = function (event) {\n    if (_this3.props.readOnly) return;\n    if (_this3.tmp.isCopying) return;\n    if (!_this3.isInEditor(event.target)) return;\n\n    // If the active element is still the editor, the blur event is due to the\n    // window itself being blurred (eg. when changing tabs) so we should ignore\n    // the event, since we want to maintain focus when returning.\n    var window = (0, _getWindow2.default)(_this3.element);\n    if (window.document.activeElement == _this3.element) return;\n\n    var data = {};\n\n    debug('onBlur', { event: event, data: data });\n    _this3.props.onBlur(event, data);\n  };\n\n  this.onFocus = function (event) {\n    if (_this3.props.readOnly) return;\n    if (_this3.tmp.isCopying) return;\n    if (!_this3.isInEditor(event.target)) return;\n\n    // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n    if (_environment.IS_FIREFOX && event.target != _this3.element) {\n      _this3.element.focus();\n      return;\n    }\n\n    var data = {};\n\n    debug('onFocus', { event: event, data: data });\n    _this3.props.onFocus(event, data);\n  };\n\n  this.onChange = function (state) {\n    debug('onChange', state);\n    _this3.props.onChange(state);\n  };\n\n  this.onCompositionStart = function (event) {\n    if (!_this3.isInEditor(event.target)) return;\n\n    _this3.tmp.isComposing = true;\n    _this3.tmp.compositions++;\n\n    debug('onCompositionStart', { event: event });\n  };\n\n  this.onCompositionEnd = function (event) {\n    if (!_this3.isInEditor(event.target)) return;\n\n    _this3.tmp.forces++;\n    var count = _this3.tmp.compositions;\n\n    // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition in still in affect.\n    setTimeout(function () {\n      if (_this3.tmp.compositions > count) return;\n      _this3.tmp.isComposing = false;\n    });\n\n    debug('onCompositionEnd', { event: event });\n  };\n\n  this.onCopy = function (event) {\n    if (!_this3.isInEditor(event.target)) return;\n    var window = (0, _getWindow2.default)(event.target);\n\n    _this3.tmp.isCopying = true;\n    window.requestAnimationFrame(function () {\n      _this3.tmp.isCopying = false;\n    });\n\n    var state = _this3.props.state;\n\n    var data = {};\n    data.type = 'fragment';\n    data.fragment = state.fragment;\n\n    debug('onCopy', { event: event, data: data });\n    _this3.props.onCopy(event, data);\n  };\n\n  this.onCut = function (event) {\n    if (_this3.props.readOnly) return;\n    if (!_this3.isInEditor(event.target)) return;\n    var window = (0, _getWindow2.default)(event.target);\n\n    _this3.tmp.isCopying = true;\n    window.requestAnimationFrame(function () {\n      _this3.tmp.isCopying = false;\n    });\n\n    var state = _this3.props.state;\n\n    var data = {};\n    data.type = 'fragment';\n    data.fragment = state.fragment;\n\n    debug('onCut', { event: event, data: data });\n    _this3.props.onCut(event, data);\n  };\n\n  this.onDragEnd = function (event) {\n    if (!_this3.isInEditor(event.target)) return;\n\n    _this3.tmp.isDragging = false;\n    _this3.tmp.isInternalDrag = null;\n\n    debug('onDragEnd', { event: event });\n  };\n\n  this.onDragOver = function (event) {\n    if (!_this3.isInEditor(event.target)) return;\n\n    event.preventDefault();\n\n    if (_this3.tmp.isDragging) return;\n    _this3.tmp.isDragging = true;\n    _this3.tmp.isInternalDrag = false;\n\n    debug('onDragOver', { event: event });\n  };\n\n  this.onDragStart = function (event) {\n    if (!_this3.isInEditor(event.target)) return;\n\n    _this3.tmp.isDragging = true;\n    _this3.tmp.isInternalDrag = true;\n    var dataTransfer = event.nativeEvent.dataTransfer;\n\n    var data = (0, _getTransferData2.default)(dataTransfer);\n\n    // If it's a node being dragged, the data type is already set.\n    if (data.type == 'node') return;\n\n    var state = _this3.props.state;\n    var fragment = state.fragment;\n\n    var encoded = _base2.default.serializeNode(fragment);\n\n    (0, _setTransferData2.default)(dataTransfer, _transferTypes2.default.FRAGMENT, encoded);\n\n    debug('onDragStart', { event: event });\n  };\n\n  this.onDrop = function (event) {\n    if (_this3.props.readOnly) return;\n    if (!_this3.isInEditor(event.target)) return;\n\n    event.preventDefault();\n\n    var window = (0, _getWindow2.default)(event.target);\n    var _props2 = _this3.props,\n        state = _props2.state,\n        editor = _props2.editor;\n    var nativeEvent = event.nativeEvent;\n    var dataTransfer = nativeEvent.dataTransfer,\n        x = nativeEvent.x,\n        y = nativeEvent.y;\n\n    var data = (0, _getTransferData2.default)(dataTransfer);\n\n    // Resolve the point where the drop occured.\n    var range = void 0;\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (window.document.caretRangeFromPoint) {\n      range = window.document.caretRangeFromPoint(x, y);\n    } else {\n      range = window.document.createRange();\n      range.setStart(nativeEvent.rangeParent, nativeEvent.rangeOffset);\n    }\n\n    var _range = range,\n        startContainer = _range.startContainer,\n        startOffset = _range.startOffset;\n\n    var point = (0, _getPoint2.default)(startContainer, startOffset, state, editor);\n    if (!point) return;\n\n    var target = _selection2.default.create({\n      anchorKey: point.key,\n      anchorOffset: point.offset,\n      focusKey: point.key,\n      focusOffset: point.offset,\n      isFocused: true\n    });\n\n    // Add drop-specific information to the data.\n    data.target = target;\n\n    // COMPAT: Edge throws \"Permission denied\" errors when\n    // accessing `dropEffect` or `effectAllowed` (2017/7/12)\n    try {\n      data.effect = dataTransfer.dropEffect;\n    } catch (err) {\n      data.effect = null;\n    }\n\n    if (data.type == 'fragment' || data.type == 'node') {\n      data.isInternal = _this3.tmp.isInternalDrag;\n    }\n\n    debug('onDrop', { event: event, data: data });\n    _this3.props.onDrop(event, data);\n  };\n\n  this.onInput = function (event) {\n    if (_this3.tmp.isComposing) return;\n    if (_this3.props.state.isBlurred) return;\n    if (!_this3.isInEditor(event.target)) return;\n    debug('onInput', { event: event });\n\n    var window = (0, _getWindow2.default)(event.target);\n    var _props3 = _this3.props,\n        state = _props3.state,\n        editor = _props3.editor;\n\n    // Get the selection point.\n\n    var native = window.getSelection();\n    var anchorNode = native.anchorNode,\n        anchorOffset = native.anchorOffset;\n\n    var point = (0, _getPoint2.default)(anchorNode, anchorOffset, state, editor);\n    if (!point) return;\n\n    // Get the range in question.\n    var key = point.key,\n        index = point.index,\n        start = point.start,\n        end = point.end;\n    var document = state.document,\n        selection = state.selection;\n\n    var schema = editor.getSchema();\n    var decorators = document.getDescendantDecorators(key, schema);\n    var node = document.getDescendant(key);\n    var block = document.getClosestBlock(node.key);\n    var ranges = node.getRanges(decorators);\n    var lastText = block.getLastText();\n\n    // Get the text information.\n    var textContent = anchorNode.textContent;\n\n    var lastChar = textContent.charAt(textContent.length - 1);\n    var isLastText = node == lastText;\n    var isLastRange = index == ranges.size - 1;\n\n    // If we're dealing with the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    if (isLastText && isLastRange && lastChar == '\\n') {\n      textContent = textContent.slice(0, -1);\n    }\n\n    // If the text is no different, abort.\n    var range = ranges.get(index);\n    var text = range.text,\n        marks = range.marks;\n\n    if (textContent == text) return;\n\n    // Determine what the selection should be after changing the text.\n    var delta = textContent.length - text.length;\n    var after = selection.collapseToEnd().move(delta);\n\n    // Create an updated state with the text replaced.\n    var next = state.transform().select({\n      anchorKey: key,\n      anchorOffset: start,\n      focusKey: key,\n      focusOffset: end\n    }).delete().insertText(textContent, marks).select(after).apply();\n\n    // Change the current state.\n    _this3.onChange(next);\n  };\n\n  this.onKeyDown = function (event) {\n    if (_this3.props.readOnly) return;\n    if (!_this3.isInEditor(event.target)) return;\n\n    var altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey,\n        which = event.which;\n\n    var key = (0, _keycode2.default)(which);\n    var data = {};\n\n    // Keep track of an `isShifting` flag, because it's often used to trigger\n    // \"Paste and Match Style\" commands, but isn't available on the event in a\n    // normal paste event.\n    if (key == 'shift') {\n      _this3.tmp.isShifting = true;\n    }\n\n    // When composing, these characters commit the composition but also move the\n    // selection before we're able to handle it, so prevent their default,\n    // selection-moving behavior.\n    if (_this3.tmp.isComposing && (key == 'left' || key == 'right' || key == 'up' || key == 'down')) {\n      event.preventDefault();\n      return;\n    }\n\n    // Add helpful properties for handling hotkeys to the data object.\n    data.code = which;\n    data.key = key;\n    data.isAlt = altKey;\n    data.isCmd = _environment.IS_MAC ? metaKey && !altKey : false;\n    data.isCtrl = ctrlKey && !altKey;\n    data.isLine = _environment.IS_MAC ? metaKey : false;\n    data.isMeta = metaKey;\n    data.isMod = _environment.IS_MAC ? metaKey && !altKey : ctrlKey && !altKey;\n    data.isModAlt = _environment.IS_MAC ? metaKey && altKey : ctrlKey && altKey;\n    data.isShift = shiftKey;\n    data.isWord = _environment.IS_MAC ? altKey : ctrlKey;\n\n    // These key commands have native behavior in contenteditable elements which\n    // will cause our state to be out of sync, so prevent them.\n    if (key == 'enter' || key == 'backspace' || key == 'delete' || key == 'b' && data.isMod || key == 'i' && data.isMod || key == 'y' && data.isMod || key == 'z' && data.isMod) {\n      event.preventDefault();\n    }\n\n    debug('onKeyDown', { event: event, data: data });\n    _this3.props.onKeyDown(event, data);\n  };\n\n  this.onKeyUp = function (event) {\n    var which = event.which;\n\n    var key = (0, _keycode2.default)(which);\n\n    if (key == 'shift') {\n      _this3.tmp.isShifting = false;\n    }\n  };\n\n  this.onPaste = function (event) {\n    if (_this3.props.readOnly) return;\n    if (!_this3.isInEditor(event.target)) return;\n\n    var data = (0, _getTransferData2.default)(event.clipboardData);\n\n    // Attach the `isShift` flag, so that people can use it to trigger \"Paste\n    // and Match Style\" logic.\n    data.isShift = !!_this3.tmp.isShifting;\n    debug('onPaste', { event: event, data: data });\n\n    // COMPAT: In IE 11, only plain text can be retrieved from the event's\n    // `clipboardData`. To get HTML, use the browser's native paste action which\n    // can only be handled synchronously. (2017/06/23)\n    if (_environment.IS_IE) {\n      // Do not use `event.preventDefault()` as we need the native paste action.\n      (0, _getHtmlFromNativePaste2.default)(event.target, function (html) {\n        // If pasted HTML can be retreived, it is added to the `data` object,\n        // setting the `type` to `html`.\n        _this3.props.onPaste(event, html === undefined ? data : _extends({}, data, { html: html, type: 'html' }));\n      });\n    } else {\n      event.preventDefault();\n      _this3.props.onPaste(event, data);\n    }\n  };\n\n  this.onSelect = function (event) {\n    if (_this3.props.readOnly) return;\n    if (_this3.tmp.isCopying) return;\n    if (_this3.tmp.isComposing) return;\n    if (_this3.tmp.isSelecting) return;\n    if (!_this3.isInEditor(event.target)) return;\n\n    var window = (0, _getWindow2.default)(event.target);\n    var _props4 = _this3.props,\n        state = _props4.state,\n        editor = _props4.editor;\n    var document = state.document,\n        selection = state.selection;\n\n    var native = window.getSelection();\n    var data = {};\n\n    // If there are no ranges, the editor was blurred natively.\n    if (!native.rangeCount) {\n      data.selection = selection.set('isFocused', false);\n      data.isNative = true;\n    }\n\n    // Otherwise, determine the Slate selection from the native one.\n    else {\n        var anchorNode = native.anchorNode,\n            anchorOffset = native.anchorOffset,\n            focusNode = native.focusNode,\n            focusOffset = native.focusOffset;\n\n        var anchor = (0, _getPoint2.default)(anchorNode, anchorOffset, state, editor);\n        var focus = (0, _getPoint2.default)(focusNode, focusOffset, state, editor);\n        if (!anchor || !focus) return;\n\n        // There are situations where a select event will fire with a new native\n        // selection that resolves to the same internal position. In those cases\n        // we don't need to trigger any changes, since our internal model is\n        // already up to date, but we do want to update the native selection again\n        // to make sure it is in sync.\n        if (anchor.key == selection.anchorKey && anchor.offset == selection.anchorOffset && focus.key == selection.focusKey && focus.offset == selection.focusOffset && selection.isFocused) {\n          _this3.updateSelection();\n          return;\n        }\n\n        var properties = {\n          anchorKey: anchor.key,\n          anchorOffset: anchor.offset,\n          focusKey: focus.key,\n          focusOffset: focus.offset,\n          isFocused: true,\n          isBackward: null\n        };\n\n        // If the selection is at the end of a non-void inline node, and there is\n        // a node after it, put it in the node after instead.\n        var anchorText = document.getNode(anchor.key);\n        var focusText = document.getNode(focus.key);\n        var anchorInline = document.getClosestInline(anchor.key);\n        var focusInline = document.getClosestInline(focus.key);\n\n        if (anchorInline && !anchorInline.isVoid && anchor.offset == anchorText.length) {\n          var block = document.getClosestBlock(anchor.key);\n          var next = block.getNextText(anchor.key);\n          if (next) {\n            properties.anchorKey = next.key;\n            properties.anchorOffset = 0;\n          }\n        }\n\n        if (focusInline && !focusInline.isVoid && focus.offset == focusText.length) {\n          var _block = document.getClosestBlock(focus.key);\n          var _next = _block.getNextText(focus.key);\n          if (_next) {\n            properties.focusKey = _next.key;\n            properties.focusOffset = 0;\n          }\n        }\n\n        data.selection = selection.merge(properties).normalize(document);\n      }\n\n    debug('onSelect', { event: event, data: data });\n    _this3.props.onSelect(event, data);\n  };\n\n  this.renderNode = function (node) {\n    var _props5 = _this3.props,\n        editor = _props5.editor,\n        readOnly = _props5.readOnly,\n        schema = _props5.schema,\n        state = _props5.state;\n\n\n    return _react2.default.createElement(_node2.default, {\n      key: node.key,\n      block: null,\n      node: node,\n      parent: state.document,\n      schema: schema,\n      state: state,\n      editor: editor,\n      readOnly: readOnly\n    });\n  };\n};\n\nexports.default = Content;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/components/content.js\n// module id = ./node_modules/slate/lib/components/content.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _reactPortal = require('react-portal');\n\nvar _reactPortal2 = _interopRequireDefault(_reactPortal);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _stack = require('../models/stack');\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nvar _propTypes3 = require('../utils/prop-types');\n\nvar _propTypes4 = _interopRequireDefault(_propTypes3);\n\nvar _noop = require('../utils/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:editor');\n\n/**\n * Event handlers to mix in to the editor.\n *\n * @type {Array}\n */\n\nvar EVENT_HANDLERS = ['onBeforeInput', 'onBlur', 'onFocus', 'onCopy', 'onCut', 'onDrop', 'onKeyDown', 'onPaste', 'onSelect'];\n\n/**\n * Plugin-related properties of the editor.\n *\n * @type {Array}\n */\n\nvar PLUGINS_PROPS = [].concat(EVENT_HANDLERS, ['placeholder', 'placeholderClassName', 'placeholderStyle', 'plugins', 'schema']);\n\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nvar Editor = function (_React$Component) {\n  _inherits(Editor, _React$Component);\n\n  /**\n   * When constructed, create a new `Stack` and run `onBeforeChange`.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  function Editor(props) {\n    _classCallCheck(this, Editor);\n\n    var _this = _possibleConstructorReturn(this, (Editor.__proto__ || Object.getPrototypeOf(Editor)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    _this.tmp = {};\n    _this.state = {};\n\n    // Create a new `Stack`, omitting the `onChange` property since that has\n    // special significance on the editor itself.\n\n    var onChange = props.onChange,\n        rest = _objectWithoutProperties(props, ['onChange']); // eslint-disable-line no-unused-vars\n\n\n    var stack = _stack2.default.create(rest);\n    _this.state.stack = stack;\n\n    // Resolve the state, running `onBeforeChange` first.\n    var state = stack.onBeforeChange(props.state, _this);\n    _this.cacheState(state);\n    _this.state.state = state;\n\n    // Create a bound event handler for each event.\n\n    var _loop = function _loop(i) {\n      var method = EVENT_HANDLERS[i];\n      _this[method] = function () {\n        var _this$state$stack;\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var next = (_this$state$stack = _this.state.stack)[method].apply(_this$state$stack, [_this.state.state, _this].concat(args));\n        _this.onChange(next);\n      };\n    };\n\n    for (var i = 0; i < EVENT_HANDLERS.length; i++) {\n      _loop(i);\n    }\n    return _this;\n  }\n\n  /**\n   * When the `props` are updated, create a new `Stack` if necessary, and\n   * run `onBeforeChange`.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Cache a `state` in memory to be able to compare against it later, for\n   * things like `onDocumentChange`.\n   *\n   * @param {State} state\n   */\n\n  /**\n   * Programmatically blur the editor.\n   */\n\n  /**\n   * Programmatically focus the editor.\n   */\n\n  /**\n   * Get the editor's current schema.\n   *\n   * @return {Schema}\n   */\n\n  /**\n   * Get the editor's current state.\n   *\n   * @return {State}\n   */\n\n  /**\n   * When the `state` changes, pass through plugins, then bubble up.\n   *\n   * @param {State} state\n   */\n\n  _createClass(Editor, [{\n    key: 'render',\n\n\n    /**\n     * Render the editor.\n     *\n     * @return {Element}\n     */\n\n    value: function render() {\n      var props = this.props,\n          state = this.state;\n      var stack = state.stack;\n\n      var children = stack.renderPortal(state.state, this).map(function (child, i) {\n        return _react2.default.createElement(\n          _reactPortal2.default,\n          { key: i, isOpened: true },\n          child\n        );\n      });\n\n      debug('render', { props: props, state: state });\n\n      var tree = stack.render(state.state, this, _extends({}, props, { children: children }));\n      return tree;\n    }\n  }]);\n\n  return Editor;\n}(_react2.default.Component);\n\n/**\n * Mix in the property types for the event handlers.\n */\n\nEditor.propTypes = {\n  autoCorrect: _propTypes2.default.bool,\n  autoFocus: _propTypes2.default.bool,\n  className: _propTypes2.default.string,\n  onBeforeChange: _propTypes2.default.func,\n  onChange: _propTypes2.default.func,\n  onDocumentChange: _propTypes2.default.func,\n  onSelectionChange: _propTypes2.default.func,\n  placeholder: _propTypes2.default.any,\n  placeholderClassName: _propTypes2.default.string,\n  placeholderStyle: _propTypes2.default.object,\n  plugins: _propTypes2.default.array,\n  readOnly: _propTypes2.default.bool,\n  role: _propTypes2.default.string,\n  schema: _propTypes2.default.object,\n  spellCheck: _propTypes2.default.bool,\n  state: _propTypes4.default.state.isRequired,\n  style: _propTypes2.default.object,\n  tabIndex: _propTypes2.default.number\n};\nEditor.defaultProps = {\n  autoFocus: false,\n  autoCorrect: true,\n  onChange: _noop2.default,\n  onDocumentChange: _noop2.default,\n  onSelectionChange: _noop2.default,\n  plugins: [],\n  readOnly: false,\n  schema: {},\n  spellCheck: true\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.componentWillReceiveProps = function (props) {\n    var stack = _this2.state.stack;\n\n    // If any plugin-related properties will change, create a new `Stack`.\n\n    for (var _i = 0; _i < PLUGINS_PROPS.length; _i++) {\n      var prop = PLUGINS_PROPS[_i];\n      if (props[prop] == _this2.props[prop]) continue;\n\n      var onChange = props.onChange,\n          rest = _objectWithoutProperties(props, ['onChange']); // eslint-disable-line no-unused-vars\n\n\n      stack = _stack2.default.create(rest);\n      _this2.setState({ stack: stack });\n    }\n\n    // Resolve the state, running the before change handler of the stack.\n    var state = stack.onBeforeChange(props.state, _this2);\n    _this2.cacheState(state);\n    _this2.setState({ state: state });\n  };\n\n  this.cacheState = function (state) {\n    _this2.tmp.document = state.document;\n    _this2.tmp.selection = state.selection;\n  };\n\n  this.blur = function () {\n    var state = _this2.state.state.transform().blur().apply();\n\n    _this2.onChange(state);\n  };\n\n  this.focus = function () {\n    var state = _this2.state.state.transform().focus().apply();\n\n    _this2.onChange(state);\n  };\n\n  this.getSchema = function () {\n    return _this2.state.stack.schema;\n  };\n\n  this.getState = function () {\n    return _this2.state.state;\n  };\n\n  this.onChange = function (state) {\n    if (state == _this2.state.state) return;\n    var tmp = _this2.tmp,\n        props = _this2.props;\n    var stack = _this2.state.stack;\n    var onChange = props.onChange,\n        onDocumentChange = props.onDocumentChange,\n        onSelectionChange = props.onSelectionChange;\n    var document = tmp.document,\n        selection = tmp.selection;\n\n\n    state = stack.onChange(state, _this2);\n    onChange(state);\n    if (state.document != document) onDocumentChange(state.document, state);\n    if (state.selection != selection) onSelectionChange(state.selection, state);\n  };\n};\n\nfor (var i = 0; i < EVENT_HANDLERS.length; i++) {\n  var property = EVENT_HANDLERS[i];\n  Editor.propTypes[property] = _propTypes2.default.func;\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexports.default = Editor;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/components/editor.js\n// module id = ./node_modules/slate/lib/components/editor.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _offsetKey = require('../utils/offset-key');\n\nvar _offsetKey2 = _interopRequireDefault(_offsetKey);\n\nvar _findDeepestNode = require('../utils/find-deepest-node');\n\nvar _findDeepestNode2 = _interopRequireDefault(_findDeepestNode);\n\nvar _environment = require('../constants/environment');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debugger.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:leaf');\n\n/**\n * Leaf.\n *\n * @type {Component}\n */\n\nvar Leaf = function (_React$Component) {\n  _inherits(Leaf, _React$Component);\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} props\n   */\n\n  function Leaf(props) {\n    _classCallCheck(this, Leaf);\n\n    var _this = _possibleConstructorReturn(this, (Leaf.__proto__ || Object.getPrototypeOf(Leaf)).call(this, props));\n\n    _this.debug = function (message) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      debug.apply(undefined, [message, _this.props.node.key + '-' + _this.props.index].concat(args));\n    };\n\n    _this.tmp = {};\n    _this.tmp.renders = 0;\n    return _this;\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  _createClass(Leaf, [{\n    key: 'shouldComponentUpdate',\n\n\n    /**\n     * Should component update?\n     *\n     * @param {Object} props\n     * @return {Boolean}\n     */\n\n    value: function shouldComponentUpdate(props) {\n      // If any of the regular properties have changed, re-render.\n      if (props.index != this.props.index || props.marks != this.props.marks || props.schema != this.props.schema || props.text != this.props.text) {\n        return true;\n      }\n\n      // If the DOM text does not equal the `text` property, re-render, this can\n      // happen because React gets out of sync when previously natively rendered.\n      var el = (0, _findDeepestNode2.default)(_reactDom2.default.findDOMNode(this));\n      var text = this.renderText(props);\n      if (el.textContent != text) return true;\n\n      // Otherwise, don't update.\n      return false;\n    }\n\n    /**\n     * Render the leaf.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var props = this.props;\n      var node = props.node,\n          index = props.index;\n\n      var offsetKey = _offsetKey2.default.stringify({\n        key: node.key,\n        index: index\n      });\n\n      // Increment the renders key, which forces a re-render whenever this\n      // component is told it should update. This is required because \"native\"\n      // renders where we don't update the leaves cause React's internal state to\n      // get out of sync, causing it to not realize the DOM needs updating.\n      this.tmp.renders++;\n\n      this.debug('render', { props: props });\n\n      return _react2.default.createElement(\n        'span',\n        { key: this.tmp.renders, 'data-offset-key': offsetKey },\n        this.renderMarks(props)\n      );\n    }\n\n    /**\n     * Render the text content of the leaf, accounting for browsers.\n     *\n     * @param {Object} props\n     * @return {Element}\n     */\n\n  }, {\n    key: 'renderText',\n    value: function renderText(props) {\n      var block = props.block,\n          node = props.node,\n          parent = props.parent,\n          text = props.text,\n          index = props.index,\n          ranges = props.ranges;\n\n      // COMPAT: If the text is empty and it's the only child, we need to render a\n      // <br/> to get the block to have the proper height.\n\n      if (text == '' && parent.kind == 'block' && parent.text == '') return _react2.default.createElement('br', null);\n\n      // COMPAT: If the text is empty otherwise, it's because it's on the edge of\n      // an inline void node, so we render a zero-width space so that the\n      // selection can be inserted next to it still.\n      if (text == '') {\n        // COMPAT: In Chrome, zero-width space produces graphics glitches, so use\n        // hair space in place of it. (2017/02/12)\n        var space = _environment.IS_FIREFOX ? '\\u200B' : '\\u200A';\n        return _react2.default.createElement(\n          'span',\n          { 'data-slate-zero-width': true },\n          space\n        );\n      }\n\n      // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n      // so we need to add an extra trailing new lines to prevent that.\n      var lastText = block.getLastText();\n      var lastChar = text.charAt(text.length - 1);\n      var isLastText = node == lastText;\n      var isLastRange = index == ranges.size - 1;\n      if (isLastText && isLastRange && lastChar == '\\n') return text + '\\n';\n\n      // Otherwise, just return the text.\n      return text;\n    }\n\n    /**\n     * Render all of the leaf's mark components.\n     *\n     * @param {Object} props\n     * @return {Element}\n     */\n\n  }, {\n    key: 'renderMarks',\n    value: function renderMarks(props) {\n      var marks = props.marks,\n          schema = props.schema,\n          node = props.node,\n          offset = props.offset,\n          text = props.text,\n          state = props.state,\n          editor = props.editor;\n\n      var children = this.renderText(props);\n\n      return marks.reduce(function (memo, mark) {\n        var Component = mark.getComponent(schema);\n        if (!Component) return memo;\n        return _react2.default.createElement(\n          Component,\n          {\n            editor: editor,\n            mark: mark,\n            marks: marks,\n            node: node,\n            offset: offset,\n            schema: schema,\n            state: state,\n            text: text\n          },\n          memo\n        );\n      }, children);\n    }\n  }]);\n\n  return Leaf;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nLeaf.propTypes = {\n  block: _propTypes2.default.object.isRequired,\n  editor: _propTypes2.default.object.isRequired,\n  index: _propTypes2.default.number.isRequired,\n  marks: _propTypes2.default.object.isRequired,\n  node: _propTypes2.default.object.isRequired,\n  offset: _propTypes2.default.number.isRequired,\n  parent: _propTypes2.default.object.isRequired,\n  ranges: _propTypes2.default.object.isRequired,\n  schema: _propTypes2.default.object.isRequired,\n  state: _propTypes2.default.object.isRequired,\n  text: _propTypes2.default.string.isRequired\n};\nexports.default = Leaf;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/components/leaf.js\n// module id = ./node_modules/slate/lib/components/leaf.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _transferTypes = require('../constants/transfer-types');\n\nvar _transferTypes2 = _interopRequireDefault(_transferTypes);\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _leaf = require('./leaf');\n\nvar _leaf2 = _interopRequireDefault(_leaf);\n\nvar _void = require('./void');\n\nvar _void2 = _interopRequireDefault(_void);\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nvar _scrollToSelection = require('../utils/scroll-to-selection');\n\nvar _scrollToSelection2 = _interopRequireDefault(_scrollToSelection);\n\nvar _setTransferData = require('../utils/set-transfer-data');\n\nvar _setTransferData2 = _interopRequireDefault(_setTransferData);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:node');\n\n/**\n * Node.\n *\n * @type {Component}\n */\n\nvar Node = function (_React$Component) {\n  _inherits(Node, _React$Component);\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} props\n   */\n\n  function Node(props) {\n    _classCallCheck(this, Node);\n\n    var _this = _possibleConstructorReturn(this, (Node.__proto__ || Object.getPrototypeOf(Node)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var node = props.node,\n        schema = props.schema;\n\n    _this.state = {};\n    _this.state.Component = node.kind == 'text' ? null : node.getComponent(schema);\n    return _this;\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * On receiving new props, update the `Component` renderer.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} state\n   * @return {Boolean}\n   */\n\n  /**\n   * On mount, update the scroll position.\n   */\n\n  /**\n   * After update, update the scroll position if the node's content changed.\n   *\n   * @param {Object} prevProps\n   * @param {Object} prevState\n   */\n\n  /**\n   * There is a corner case, that some nodes are unmounted right after they update\n   * Then, when the timer execute, it will throw the error\n   * `findDOMNode was called on an unmounted component`\n   * We should clear the timer from updateScroll here\n   */\n\n  /**\n   * Update the scroll position after a change as occured if this is a leaf\n   * block and it has the selection's ending edge. This ensures that scrolling\n   * matches native `contenteditable` behavior even for cases where the edit is\n   * not applied natively, like when enter is pressed.\n   */\n\n  /**\n   * On drag start, add a serialized representation of the node to the data.\n   *\n   * @param {Event} e\n   */\n\n  _createClass(Node, [{\n    key: 'render',\n\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n\n    value: function render() {\n      var props = this.props;\n      var node = this.props.node;\n\n\n      this.debug('render', { props: props });\n\n      return node.kind == 'text' ? this.renderText() : this.renderElement();\n    }\n\n    /**\n     * Render a `child` node.\n     *\n     * @param {Node} child\n     * @return {Element}\n     */\n\n    /**\n     * Render an element `node`.\n     *\n     * @return {Element}\n     */\n\n    /**\n     * Render a text node.\n     *\n     * @return {Element}\n     */\n\n    /**\n     * Render a single leaf node given a `range` and `offset`.\n     *\n     * @param {List<Range>} ranges\n     * @param {Range} range\n     * @param {Number} index\n     * @param {Number} offset\n     * @return {Element} leaf\n     */\n\n  }]);\n\n  return Node;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nNode.propTypes = {\n  block: _propTypes2.default.object,\n  editor: _propTypes2.default.object.isRequired,\n  node: _propTypes2.default.object.isRequired,\n  parent: _propTypes2.default.object.isRequired,\n  readOnly: _propTypes2.default.bool.isRequired,\n  schema: _propTypes2.default.object.isRequired,\n  state: _propTypes2.default.object.isRequired\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var node = _this2.props.node;\n    var key = node.key,\n        kind = node.kind,\n        type = node.type;\n\n    var id = kind == 'text' ? key + ' (' + kind + ')' : key + ' (' + type + ')';\n    debug.apply(undefined, [message, '' + id].concat(args));\n  };\n\n  this.componentWillReceiveProps = function (props) {\n    if (props.node.kind == 'text') return;\n    if (props.node == _this2.props.node) return;\n    var Component = props.node.getComponent(props.schema);\n    _this2.setState({ Component: Component });\n  };\n\n  this.shouldComponentUpdate = function (nextProps) {\n    var props = _this2.props;\n    var Component = _this2.state.Component;\n\n    // If the `Component` has enabled suppression of update checking, always\n    // return true so that it can deal with update checking itself.\n\n    if (Component && Component.suppressShouldComponentUpdate) return true;\n\n    // If the `readOnly` status has changed, re-render in case there is any\n    // user-land logic that depends on it, like nested editable contents.\n    if (nextProps.readOnly != props.readOnly) return true;\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (nextProps.node != props.node) return true;\n\n    // If the node is a block or inline, which can have custom renderers, we\n    // include an extra check to re-render if the node's focus changes, to make\n    // it simple for users to show a node's \"selected\" state.\n    if (nextProps.node.kind != 'text') {\n      var hasEdgeIn = props.state.selection.hasEdgeIn(props.node);\n      var nextHasEdgeIn = nextProps.state.selection.hasEdgeIn(nextProps.node);\n      var hasFocus = props.state.isFocused || nextProps.state.isFocused;\n      var hasEdge = hasEdgeIn || nextHasEdgeIn;\n      if (hasFocus && hasEdge) return true;\n    }\n\n    // If the node is a text node, re-render if the current decorations have\n    // changed, even if the content of the text node itself hasn't.\n    if (nextProps.node.kind == 'text' && nextProps.schema.hasDecorators) {\n      var nextDecorators = nextProps.state.document.getDescendantDecorators(nextProps.node.key, nextProps.schema);\n      var decorators = props.state.document.getDescendantDecorators(props.node.key, props.schema);\n      var nextRanges = nextProps.node.getRanges(nextDecorators);\n      var ranges = props.node.getRanges(decorators);\n      if (!nextRanges.equals(ranges)) return true;\n    }\n\n    // If the node is a text node, and its parent is a block node, and it was\n    // the last child of the block, re-render to cleanup extra `<br/>` or `\\n`.\n    if (nextProps.node.kind == 'text' && nextProps.parent.kind == 'block') {\n      var last = props.parent.nodes.last();\n      var nextLast = nextProps.parent.nodes.last();\n      if (props.node == last && nextProps.node != nextLast) return true;\n    }\n\n    // Otherwise, don't update.\n    return false;\n  };\n\n  this.componentDidMount = function () {\n    _this2.updateScroll();\n  };\n\n  this.componentDidUpdate = function (prevProps, prevState) {\n    if (_this2.props.node != prevProps.node) _this2.updateScroll();\n  };\n\n  this.componentWillUnmount = function () {\n    clearTimeout(_this2.scrollTimer);\n  };\n\n  this.updateScroll = function () {\n    var _props = _this2.props,\n        node = _props.node,\n        state = _props.state;\n    var selection = state.selection;\n\n    // If this isn't a block, or it's a wrapping block, abort.\n\n    if (node.kind != 'block') return;\n    if (node.nodes.first().kind == 'block') return;\n\n    // If the selection is blurred, or this block doesn't contain it, abort.\n    if (selection.isBlurred) return;\n    if (!selection.hasEndIn(node)) return;\n\n    // The native selection will be updated after componentDidMount or componentDidUpdate.\n    // Use setTimeout to queue scrolling to the last when the native selection has been updated to the correct value.\n    _this2.scrollTimer = setTimeout(function () {\n      var el = _reactDom2.default.findDOMNode(_this2);\n      var window = (0, _getWindow2.default)(el);\n      var native = window.getSelection();\n      (0, _scrollToSelection2.default)(native);\n\n      _this2.debug('updateScroll', el);\n    });\n  };\n\n  this.onDragStart = function (e) {\n    var node = _this2.props.node;\n\n    // Only void node are draggable\n\n    if (!node.isVoid) {\n      return;\n    }\n\n    var encoded = _base2.default.serializeNode(node, { preserveKeys: true });\n    var dataTransfer = e.nativeEvent.dataTransfer;\n\n\n    (0, _setTransferData2.default)(dataTransfer, _transferTypes2.default.NODE, encoded);\n\n    _this2.debug('onDragStart', e);\n  };\n\n  this.renderNode = function (child) {\n    var _props2 = _this2.props,\n        block = _props2.block,\n        editor = _props2.editor,\n        node = _props2.node,\n        readOnly = _props2.readOnly,\n        schema = _props2.schema,\n        state = _props2.state;\n\n    return _react2.default.createElement(Node, {\n      key: child.key,\n      node: child,\n      block: node.kind == 'block' ? node : block,\n      parent: node,\n      editor: editor,\n      readOnly: readOnly,\n      schema: schema,\n      state: state\n    });\n  };\n\n  this.renderElement = function () {\n    var _props3 = _this2.props,\n        editor = _props3.editor,\n        node = _props3.node,\n        parent = _props3.parent,\n        readOnly = _props3.readOnly,\n        state = _props3.state;\n    var Component = _this2.state.Component;\n\n    var children = node.nodes.map(_this2.renderNode).toArray();\n\n    // Attributes that the developer must to mix into the element in their\n    // custom node renderer component.\n    var attributes = {\n      'data-key': node.key,\n      'onDragStart': _this2.onDragStart\n    };\n\n    // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (node.kind == 'block' && node.nodes.first().kind != 'block') {\n      var direction = node.getTextDirection();\n      if (direction == 'rtl') attributes.dir = 'rtl';\n    }\n\n    var element = _react2.default.createElement(\n      Component,\n      {\n        attributes: attributes,\n        key: node.key,\n        editor: editor,\n        parent: parent,\n        node: node,\n        readOnly: readOnly,\n        state: state\n      },\n      children\n    );\n\n    return node.isVoid ? _react2.default.createElement(\n      _void2.default,\n      _this2.props,\n      element\n    ) : element;\n  };\n\n  this.renderText = function () {\n    var _props4 = _this2.props,\n        node = _props4.node,\n        schema = _props4.schema,\n        state = _props4.state;\n    var document = state.document;\n\n    var decorators = schema.hasDecorators ? document.getDescendantDecorators(node.key, schema) : [];\n    var ranges = node.getRanges(decorators);\n    var offset = 0;\n\n    var leaves = ranges.map(function (range, i) {\n      var leaf = _this2.renderLeaf(ranges, range, i, offset);\n      offset += range.text.length;\n      return leaf;\n    });\n\n    return _react2.default.createElement(\n      'span',\n      { 'data-key': node.key },\n      leaves\n    );\n  };\n\n  this.renderLeaf = function (ranges, range, index, offset) {\n    var _props5 = _this2.props,\n        block = _props5.block,\n        node = _props5.node,\n        parent = _props5.parent,\n        schema = _props5.schema,\n        state = _props5.state,\n        editor = _props5.editor;\n    var text = range.text,\n        marks = range.marks;\n\n\n    return _react2.default.createElement(_leaf2.default, {\n      key: node.key + '-' + index,\n      block: block,\n      editor: editor,\n      index: index,\n      marks: marks,\n      node: node,\n      offset: offset,\n      parent: parent,\n      ranges: ranges,\n      schema: schema,\n      state: state,\n      text: text\n    });\n  };\n};\n\nexports.default = Node;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/components/node.js\n// module id = ./node_modules/slate/lib/components/node.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Placeholder.\n *\n * @type {Component}\n */\n\nvar Placeholder = function (_React$Component) {\n  _inherits(Placeholder, _React$Component);\n\n  function Placeholder() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Placeholder);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Placeholder.__proto__ || Object.getPrototypeOf(Placeholder)).call.apply(_ref, [this].concat(args))), _this), _this.shouldComponentUpdate = function (props, state) {\n      return props.children != _this.props.children || props.className != _this.props.className || props.firstOnly != _this.props.firstOnly || props.parent != _this.props.parent || props.node != _this.props.node || props.style != _this.props.style;\n    }, _this.isVisible = function () {\n      var _this$props = _this.props,\n          firstOnly = _this$props.firstOnly,\n          node = _this$props.node,\n          parent = _this$props.parent;\n\n      if (node.text) return false;\n\n      if (firstOnly) {\n        if (parent.nodes.size > 1) return false;\n        if (parent.nodes.first() === node) return true;\n        return false;\n      } else {\n        return true;\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Should the placeholder update?\n   *\n   * @param {Object} props\n   * @param {Object} state\n   * @return {Boolean}\n   */\n\n  /**\n   * Is the placeholder visible?\n   *\n   * @return {Boolean}\n   */\n\n  _createClass(Placeholder, [{\n    key: 'render',\n\n\n    /**\n     * Render.\n     *\n     * If the placeholder is a string, and no `className` or `style` has been\n     * passed, give it a default style of lowered opacity.\n     *\n     * @return {Element}\n     */\n\n    value: function render() {\n      var isVisible = this.isVisible();\n      if (!isVisible) return null;\n\n      var _props = this.props,\n          children = _props.children,\n          className = _props.className;\n      var style = this.props.style;\n\n\n      if (typeof children === 'string' && style == null && className == null) {\n        style = { opacity: '0.333' };\n      } else if (style == null) {\n        style = {};\n      }\n\n      var styles = _extends({\n        position: 'absolute',\n        top: '0px',\n        right: '0px',\n        bottom: '0px',\n        left: '0px',\n        pointerEvents: 'none'\n      }, style);\n\n      return _react2.default.createElement(\n        'span',\n        { contentEditable: false, className: className, style: styles },\n        children\n      );\n    }\n  }]);\n\n  return Placeholder;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nPlaceholder.propTypes = {\n  children: _propTypes2.default.any.isRequired,\n  className: _propTypes2.default.string,\n  firstOnly: _propTypes2.default.bool,\n  node: _propTypes2.default.object.isRequired,\n  parent: _propTypes2.default.object,\n  state: _propTypes2.default.object.isRequired,\n  style: _propTypes2.default.object\n};\nPlaceholder.defaultProps = {\n  firstOnly: true\n};\nexports.default = Placeholder;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/components/placeholder.js\n// module id = ./node_modules/slate/lib/components/placeholder.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _leaf = require('./leaf');\n\nvar _leaf2 = _interopRequireDefault(_leaf);\n\nvar _mark = require('../models/mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _offsetKey = require('../utils/offset-key');\n\nvar _offsetKey2 = _interopRequireDefault(_offsetKey);\n\nvar _environment = require('../constants/environment');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:void');\n\n/**\n * Void.\n *\n * @type {Component}\n */\n\nvar Void = function (_React$Component) {\n  _inherits(Void, _React$Component);\n\n  function Void() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Void);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Void.__proto__ || Object.getPrototypeOf(Void)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * State\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * When one of the wrapper elements it clicked, select the void node.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * Increment counter, and temporarily switch node to editable to allow drop events\n   * Counter required as onDragLeave fires when hovering over child elements\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * Decrement counter, and if counter 0, then no longer dragging over node\n   * and thus switch back to non-editable\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * If dropped item onto node, then reset state\n   *\n   * @param {Event} event\n   */\n\n  _createClass(Void, [{\n    key: 'render',\n\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n\n    value: function render() {\n      var props = this.props;\n      var children = props.children,\n          node = props.node;\n\n      var Tag = void 0,\n          style = void 0;\n\n      // Make the outer wrapper relative, so the spacer can overlay it.\n      if (node.kind === 'block') {\n        Tag = 'div';\n        style = { position: 'relative' };\n      } else {\n        Tag = 'span';\n      }\n\n      this.debug('render', { props: props });\n\n      return _react2.default.createElement(\n        Tag,\n        {\n          'data-slate-void': true,\n          style: style,\n          onClick: this.onClick,\n          onDragEnter: this.onDragEnter,\n          onDragLeave: this.onDragLeave,\n          onDrop: this.onDrop\n        },\n        this.renderSpacer(),\n        _react2.default.createElement(\n          Tag,\n          { contentEditable: this.state.editable },\n          children\n        )\n      );\n    }\n\n    /**\n     * Render a fake spacer leaf, which will catch the cursor when it the void\n     * node is navigated to with the arrow keys. Having this spacer there means\n     * the browser continues to manage the selection natively, so it keeps track\n     * of the right offset when moving across the block.\n     *\n     * @return {Element}\n     */\n\n    /**\n     * Render a fake leaf.\n     *\n     * @return {Element}\n     */\n\n  }]);\n\n  return Void;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nVoid.propTypes = {\n  block: _propTypes2.default.object,\n  children: _propTypes2.default.any.isRequired,\n  editor: _propTypes2.default.object.isRequired,\n  node: _propTypes2.default.object.isRequired,\n  parent: _propTypes2.default.object.isRequired,\n  readOnly: _propTypes2.default.bool.isRequired,\n  schema: _propTypes2.default.object.isRequired,\n  state: _propTypes2.default.object.isRequired\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.state = {\n    dragCounter: 0,\n    editable: false\n  };\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this2.props.node;\n    var key = node.key,\n        type = node.type;\n\n    var id = key + ' (' + type + ')';\n    debug.apply(undefined, [message, '' + id].concat(args));\n  };\n\n  this.onClick = function (event) {\n    if (_this2.props.readOnly) return;\n\n    _this2.debug('onClick', { event: event });\n\n    var _props = _this2.props,\n        node = _props.node,\n        editor = _props.editor;\n\n    var next = editor.getState().transform()\n    // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n    // an inline node will be automatically replaced to be at the last offset\n    // of a previous inline node, which screws us up, so we always want to set\n    // it to the end of the node. (2016/11/29)\n    .collapseToEndOf(node).focus().apply();\n\n    editor.onChange(next);\n  };\n\n  this.onDragEnter = function () {\n    _this2.setState(function (prevState) {\n      var dragCounter = prevState.dragCounter + 1;\n      return { dragCounter: dragCounter, editable: undefined };\n    });\n  };\n\n  this.onDragLeave = function () {\n    _this2.setState(function (prevState) {\n      var dragCounter = prevState.dragCounter + 1;\n      var editable = dragCounter === 0 ? false : undefined;\n      return { dragCounter: dragCounter, editable: editable };\n    });\n  };\n\n  this.onDrop = function () {\n    _this2.setState({ dragCounter: 0, editable: false });\n  };\n\n  this.renderSpacer = function () {\n    var node = _this2.props.node;\n\n    var style = void 0;\n\n    if (node.kind == 'block') {\n      style = _environment.IS_FIREFOX ? {\n        pointerEvents: 'none',\n        width: '0px',\n        height: '0px',\n        lineHeight: '0px',\n        visibility: 'hidden'\n      } : {\n        position: 'absolute',\n        top: '0px',\n        left: '-9999px',\n        textIndent: '-9999px'\n      };\n    } else {\n      style = {\n        color: 'transparent'\n      };\n    }\n\n    return _react2.default.createElement(\n      'span',\n      { style: style },\n      _this2.renderLeaf()\n    );\n  };\n\n  this.renderLeaf = function () {\n    var _props2 = _this2.props,\n        block = _props2.block,\n        node = _props2.node,\n        schema = _props2.schema,\n        state = _props2.state,\n        editor = _props2.editor;\n\n    var child = node.getFirstText();\n    var ranges = child.getRanges();\n    var text = '';\n    var offset = 0;\n    var marks = _mark2.default.createSet();\n    var index = 0;\n    var offsetKey = _offsetKey2.default.stringify({\n      key: child.key,\n      index: index\n    });\n\n    return _react2.default.createElement(_leaf2.default, {\n      key: offsetKey,\n      block: node.kind == 'block' ? node : block,\n      editor: editor,\n      index: index,\n      marks: marks,\n      node: child,\n      offset: offset,\n      parent: node,\n      ranges: ranges,\n      schema: schema,\n      state: state,\n      text: text\n    });\n  };\n};\n\nexports.default = Void;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/components/void.js\n// module id = ./node_modules/slate/lib/components/void.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IS_WINDOWS = exports.IS_MAC = exports.IS_IE = exports.IS_SAFARI = exports.IS_FIREFOX = exports.IS_CHROME = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _isInBrowser = require('is-in-browser');\n\nvar _isInBrowser2 = _interopRequireDefault(_isInBrowser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Browser matching rules.\n *\n * @type {Array}\n */\n\nvar BROWSER_RULES = [['edge', /Edge\\/([0-9\\._]+)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], ['firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/], ['opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/], ['opera', /OPR\\/([0-9\\.]+)(:?\\s|$)$/], ['ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+)\\).*Gecko$/], ['ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/], ['ie', /MSIE\\s(7\\.0)/], ['android', /Android\\s([0-9\\.]+)/], ['safari', /Version\\/([0-9\\._]+).*Safari/]];\n\n/**\n * Operating system matching rules.\n *\n * @type {Array}\n */\n\nvar OS_RULES = [['macos', /mac os x/i], ['ios', /os ([\\.\\_\\d]+) like mac os/i], ['android', /android/i], ['firefoxos', /mozilla\\/[a-z\\.\\_\\d]+ \\((?:mobile)|(?:tablet)/i], ['windows', /windows\\s*(?:nt)?\\s*([\\.\\_\\d]+)/i]];\n\n/**\n * Define variables to store the result.\n */\n\nvar BROWSER = void 0;\nvar OS = void 0;\n\n/**\n * Run the matchers when in browser.\n */\n\nif (_isInBrowser2.default) {\n  var userAgent = window.navigator.userAgent;\n\n\n  for (var i = 0; i < BROWSER_RULES.length; i++) {\n    var _BROWSER_RULES$i = _slicedToArray(BROWSER_RULES[i], 2),\n        name = _BROWSER_RULES$i[0],\n        regexp = _BROWSER_RULES$i[1];\n\n    if (regexp.test(userAgent)) {\n      BROWSER = name;\n      break;\n    }\n  }\n\n  for (var _i = 0; _i < OS_RULES.length; _i++) {\n    var _OS_RULES$_i = _slicedToArray(OS_RULES[_i], 2),\n        name = _OS_RULES$_i[0],\n        regexp = _OS_RULES$_i[1];\n\n    if (regexp.test(userAgent)) {\n      OS = name;\n      break;\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar IS_CHROME = exports.IS_CHROME = BROWSER === 'chrome';\nvar IS_FIREFOX = exports.IS_FIREFOX = BROWSER === 'firefox';\nvar IS_SAFARI = exports.IS_SAFARI = BROWSER === 'safari';\nvar IS_IE = exports.IS_IE = BROWSER === 'ie';\n\nvar IS_MAC = exports.IS_MAC = OS === 'macos';\nvar IS_WINDOWS = exports.IS_WINDOWS = OS === 'windows';\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/constants/environment.js\n// module id = ./node_modules/slate/lib/constants/environment.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Is in development?\n *\n * @type {Boolean}\n */\n\nvar IS_DEV = typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production';\n\n/**\n * Export.\n *\n * @type {Boolean}\n */\n\nexports.default = IS_DEV;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/constants/is-dev.js\n// module id = ./node_modules/slate/lib/constants/is-dev.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Slate-specific item types.\n *\n * @type {Object}\n */\n\nvar MODEL_TYPES = {\n  STATE: '@@__SLATE_STATE__@@',\n  DOCUMENT: '@@__SLATE_DOCUMENT__@@',\n  BLOCK: '@@__SLATE_BLOCK__@@',\n  INLINE: '@@__SLATE_INLINE__@@',\n  TEXT: '@@__SLATE_TEXT__@@',\n  CHARACTER: '@@__SLATE_CHARACTER__@@',\n  MARK: '@@__SLATE_MARK__@@',\n  RANGE: '@@__SLATE_RANGE__@@',\n  SELECTION: '@@__SLATE_SELECTION__@@',\n  SCHEMA: '@@__SLATE_SCHEMA__@@'\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = MODEL_TYPES;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/constants/model-types.js\n// module id = ./node_modules/slate/lib/constants/model-types.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Slate-specific data transfer types.\n *\n * @type {Object}\n */\n\nvar TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  NODE: 'application/x-slate-node'\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = TYPES;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/constants/transfer-types.js\n// module id = ./node_modules/slate/lib/constants/transfer-types.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setKeyGenerator = exports.resetKeyGenerator = exports.findDOMNode = exports.Transforms = exports.Text = exports.State = exports.Stack = exports.Selection = exports.Schema = exports.Raw = exports.Range = exports.Plain = exports.Placeholder = exports.Mark = exports.Inline = exports.Html = exports.Editor = exports.Document = exports.Data = exports.Character = exports.Block = undefined;\n\nvar _editor = require('./components/editor');\n\nvar _editor2 = _interopRequireDefault(_editor);\n\nvar _placeholder = require('./components/placeholder');\n\nvar _placeholder2 = _interopRequireDefault(_placeholder);\n\nvar _block = require('./models/block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _character = require('./models/character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _data = require('./models/data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _document = require('./models/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _inline = require('./models/inline');\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _mark = require('./models/mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _schema = require('./models/schema');\n\nvar _schema2 = _interopRequireDefault(_schema);\n\nvar _selection = require('./models/selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _stack = require('./models/stack');\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nvar _state = require('./models/state');\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _text = require('./models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _range = require('./models/range');\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _html = require('./serializers/html');\n\nvar _html2 = _interopRequireDefault(_html);\n\nvar _plain = require('./serializers/plain');\n\nvar _plain2 = _interopRequireDefault(_plain);\n\nvar _raw = require('./serializers/raw');\n\nvar _raw2 = _interopRequireDefault(_raw);\n\nvar _transforms = require('./transforms');\n\nvar _transforms2 = _interopRequireDefault(_transforms);\n\nvar _findDomNode = require('./utils/find-dom-node');\n\nvar _findDomNode2 = _interopRequireDefault(_findDomNode);\n\nvar _generateKey = require('./utils/generate-key');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\n/**\n * Utils.\n */\n\n/**\n * Serializers.\n */\n\n/**\n * Models.\n */\n\n/**\n * Components.\n */\n\nexports.Block = _block2.default;\nexports.Character = _character2.default;\nexports.Data = _data2.default;\nexports.Document = _document2.default;\nexports.Editor = _editor2.default;\nexports.Html = _html2.default;\nexports.Inline = _inline2.default;\nexports.Mark = _mark2.default;\nexports.Placeholder = _placeholder2.default;\nexports.Plain = _plain2.default;\nexports.Range = _range2.default;\nexports.Raw = _raw2.default;\nexports.Schema = _schema2.default;\nexports.Selection = _selection2.default;\nexports.Stack = _stack2.default;\nexports.State = _state2.default;\nexports.Text = _text2.default;\nexports.Transforms = _transforms2.default;\nexports.findDOMNode = _findDomNode2.default;\nexports.resetKeyGenerator = _generateKey.resetKeyGenerator;\nexports.setKeyGenerator = _generateKey.setKeyGenerator;\n\n/**\n * Transforms.\n */\n\nexports.default = {\n  Block: _block2.default,\n  Character: _character2.default,\n  Data: _data2.default,\n  Document: _document2.default,\n  Editor: _editor2.default,\n  Html: _html2.default,\n  Inline: _inline2.default,\n  Mark: _mark2.default,\n  Placeholder: _placeholder2.default,\n  Plain: _plain2.default,\n  Range: _range2.default,\n  Raw: _raw2.default,\n  Schema: _schema2.default,\n  Selection: _selection2.default,\n  Stack: _stack2.default,\n  State: _state2.default,\n  Text: _text2.default,\n  Transforms: _transforms2.default,\n  findDOMNode: _findDomNode2.default,\n  resetKeyGenerator: _generateKey.resetKeyGenerator,\n  setKeyGenerator: _generateKey.setKeyGenerator\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/index.js\n// module id = ./node_modules/slate/lib/index.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nrequire('./document');\n\nvar _data = require('./data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _inline = require('./inline');\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _text = require('./text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n/**\n * Prevent circular dependencies.\n */\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new _immutable.Map(),\n  isVoid: false,\n  key: null,\n  nodes: new _immutable.List(),\n  type: null\n};\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nvar Block = function (_ref) {\n  _inherits(Block, _ref);\n\n  function Block() {\n    _classCallCheck(this, Block);\n\n    return _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).apply(this, arguments));\n  }\n\n  _createClass(Block, [{\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'block';\n    }\n\n    /**\n     * Is the node empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the length of the concatenated text of the node.\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.text.length;\n    }\n\n    /**\n     * Get the concatenated text `string` of all child nodes.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Block` with `properties`.\n     *\n     * @param {Object|Block} properties\n     * @return {Block}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(properties)) return properties;\n      if (_inline2.default.isInline(properties)) return properties;\n      if (_text2.default.isText(properties)) return properties;\n      if (!properties.type) throw new Error('You must pass a block `type`.');\n\n      properties.key = properties.key || (0, _generateKey2.default)();\n      properties.data = _data2.default.create(properties.data);\n      properties.isVoid = !!properties.isVoid;\n      properties.nodes = Block.createList(properties.nodes);\n\n      if (properties.nodes.size == 0) {\n        properties.nodes = properties.nodes.push(_text2.default.create());\n      }\n\n      return new Block(properties);\n    }\n\n    /**\n     * Create a list of `Blocks` from an array.\n     *\n     * @param {Array<Object|Block>} elements\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.List.isList(elements)) return elements;\n      return new _immutable.List(elements.map(Block.create));\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate Block or not\n     *\n     * @param {*} maybeBlock\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlock',\n    value: function isBlock(maybeBlock) {\n      return !!(maybeBlock && maybeBlock[_modelTypes2.default.BLOCK]);\n    }\n  }]);\n\n  return Block;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Pseduo-symbol that shows this is a Slate Block\n */\n\nBlock.prototype[_modelTypes2.default.BLOCK] = true;\n\n/**\n * Mix in `Node` methods.\n */\n\nfor (var method in _node2.default) {\n  Block.prototype[method] = _node2.default[method];\n}\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexports.default = Block;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/block.js\n// module id = ./node_modules/slate/lib/models/block.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mark = require('./mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  marks: new _immutable.Set(),\n  text: ''\n};\n\n/**\n * Character.\n *\n * @type {Character}\n */\n\nvar Character = function (_ref) {\n  _inherits(Character, _ref);\n\n  function Character() {\n    _classCallCheck(this, Character);\n\n    return _possibleConstructorReturn(this, (Character.__proto__ || Object.getPrototypeOf(Character)).apply(this, arguments));\n  }\n\n  _createClass(Character, [{\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'character';\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a character record with `properties`.\n     *\n     * @param {Object|Character} properties\n     * @return {Character}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Character.isCharacter(properties)) return properties;\n      properties.marks = _mark2.default.createSet(properties.marks);\n      return new Character(properties);\n    }\n\n    /**\n     * Create a characters list from an array of characters.\n     *\n     * @param {Array<Object|Character>} array\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.List.isList(array)) return array;\n      return new _immutable.List(array.map(Character.create));\n    }\n\n    /**\n     * Create a characters list from a `string` and optional `marks`.\n     *\n     * @param {String} string\n     * @param {Set<Mark>} marks (optional)\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'createListFromText',\n    value: function createListFromText(string, marks) {\n      var chars = string.split('').map(function (text) {\n        return { text: text, marks: marks };\n      });\n      var list = Character.createList(chars);\n      return list;\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate Character or not\n     *\n     * @param {*} maybeCharacter\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCharacter',\n    value: function isCharacter(maybeCharacter) {\n      return !!(maybeCharacter && maybeCharacter[_modelTypes2.default.CHARACTER]);\n    }\n  }]);\n\n  return Character;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Pseduo-symbol that shows this is a Slate Character\n */\n\nCharacter.prototype[_modelTypes2.default.CHARACTER] = true;\n\n/**\n * Export.\n *\n * @type {Character}\n */\n\nexports.default = Character;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/character.js\n// module id = ./node_modules/slate/lib/models/character.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _immutable = require('immutable');\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nvar Data = {\n\n  /**\n   * Create a new `Data` with `properties`.\n   *\n   * @param {Object} properties\n   * @return {Data} data\n   */\n\n  create: function create() {\n    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    return _immutable.Map.isMap(properties) ? properties : new _immutable.Map(properties);\n  }\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Data;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/data.js\n// module id = ./node_modules/slate/lib/models/data.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _block = require('./block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nrequire('./inline');\n\nvar _data = require('./data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n/**\n * Prevent circular dependencies.\n */\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new _immutable.Map(),\n  key: null,\n  nodes: new _immutable.List()\n};\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nvar Document = function (_ref) {\n  _inherits(Document, _ref);\n\n  function Document() {\n    _classCallCheck(this, Document);\n\n    return _possibleConstructorReturn(this, (Document.__proto__ || Object.getPrototypeOf(Document)).apply(this, arguments));\n  }\n\n  _createClass(Document, [{\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'document';\n    }\n\n    /**\n     * Is the document empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the length of the concatenated text of the document.\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.text.length;\n    }\n\n    /**\n     * Get the concatenated text `string` of all child nodes.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Document` with `properties`.\n     *\n     * @param {Object|Document} properties\n     * @return {Document}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Document.isDocument(properties)) return properties;\n\n      properties.key = properties.key || (0, _generateKey2.default)();\n      properties.data = _data2.default.create(properties.data);\n      properties.nodes = _block2.default.createList(properties.nodes);\n\n      return new Document(properties);\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate Document or not\n     *\n     * @param {*} maybeDocument\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isDocument',\n    value: function isDocument(maybeDocument) {\n      return !!(maybeDocument && maybeDocument[_modelTypes2.default.DOCUMENT]);\n    }\n  }]);\n\n  return Document;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Pseduo-symbol that shows this is a Slate Document\n */\n\nDocument.prototype[_modelTypes2.default.DOCUMENT] = true;\n\n/**\n * Mix in `Node` methods.\n */\n\nfor (var method in _node2.default) {\n  Document.prototype[method] = _node2.default[method];\n}\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexports.default = Document;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/document.js\n// module id = ./node_modules/slate/lib/models/document.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nrequire('./document');\n\nvar _block = require('./block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _data = require('./data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _text = require('./text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n/**\n * Prevent circular dependencies.\n */\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new _immutable.Map(),\n  isVoid: false,\n  key: null,\n  nodes: new _immutable.List(),\n  type: null\n};\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nvar Inline = function (_ref) {\n  _inherits(Inline, _ref);\n\n  function Inline() {\n    _classCallCheck(this, Inline);\n\n    return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n  }\n\n  _createClass(Inline, [{\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'inline';\n    }\n\n    /**\n     * Is the node empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the length of the concatenated text of the node.\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.text.length;\n    }\n\n    /**\n     * Get the concatenated text `string` of all child nodes.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Inline` with `properties`.\n     *\n     * @param {Object|Inline} properties\n     * @return {Inline}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (_block2.default.isBlock(properties)) return properties;\n      if (Inline.isInline(properties)) return properties;\n      if (_text2.default.isText(properties)) return properties;\n      if (!properties.type) throw new Error('You must pass an inline `type`.');\n\n      properties.key = properties.key || (0, _generateKey2.default)();\n      properties.data = _data2.default.create(properties.data);\n      properties.isVoid = !!properties.isVoid;\n      properties.nodes = Inline.createList(properties.nodes);\n\n      if (properties.nodes.size == 0) {\n        properties.nodes = properties.nodes.push(_text2.default.create());\n      }\n\n      return new Inline(properties);\n    }\n\n    /**\n     * Create a list of `Inlines` from an array.\n     *\n     * @param {Array<Object|Inline>} elements\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.List.isList(elements)) return elements;\n      return new _immutable.List(elements.map(Inline.create));\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate Inline or not\n     *\n     * @param {*} maybeInline\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInline',\n    value: function isInline(maybeInline) {\n      return !!(maybeInline && maybeInline[_modelTypes2.default.INLINE]);\n    }\n  }]);\n\n  return Inline;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Pseduo-symbol that shows this is a Slate Inline\n */\n\nInline.prototype[_modelTypes2.default.INLINE] = true;\n\n/**\n * Mix in `Node` methods.\n */\n\nfor (var method in _node2.default) {\n  Inline.prototype[method] = _node2.default[method];\n}\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexports.default = Inline;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/inline.js\n// module id = ./node_modules/slate/lib/models/inline.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _data = require('./data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _memoize = require('../utils/memoize');\n\nvar _memoize2 = _interopRequireDefault(_memoize);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new _immutable.Map(),\n  type: null\n};\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nvar Mark = function (_ref) {\n  _inherits(Mark, _ref);\n\n  function Mark() {\n    _classCallCheck(this, Mark);\n\n    return _possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).apply(this, arguments));\n  }\n\n  _createClass(Mark, [{\n    key: 'getComponent',\n\n\n    /**\n     * Get the component for the node from a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Component|Void}\n     */\n\n    value: function getComponent(schema) {\n      return schema.__getComponent(this);\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     */\n\n    get: function get() {\n      return 'mark';\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Mark` with `properties`.\n     *\n     * @param {Object|Mark} properties\n     * @return {Mark}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(properties)) return properties;\n      if (!properties.type) throw new Error('You must provide a `type` for the mark.');\n      properties.data = _data2.default.create(properties.data);\n      return new Mark(properties);\n    }\n\n    /**\n     * Create a marks set from an array of marks.\n     *\n     * @param {Array<Object|Mark>} array\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'createSet',\n    value: function createSet() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.Set.isSet(array)) return array;\n      return new _immutable.Set(array.map(Mark.create));\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate Mark or not\n     *\n     * @param {*} maybeMark\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isMark',\n    value: function isMark(maybeMark) {\n      return !!(maybeMark && maybeMark[_modelTypes2.default.MARK]);\n    }\n  }]);\n\n  return Mark;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Pseduo-symbol that shows this is a Slate Mark\n */\n\nMark.prototype[_modelTypes2.default.MARK] = true;\n\n/**\n * Memoize read methods.\n */\n\n(0, _memoize2.default)(Mark.prototype, ['getComponent'], {\n  takesArguments: true\n});\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexports.default = Mark;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/mark.js\n// module id = ./node_modules/slate/lib/models/mark.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _document = require('./document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _direction = require('direction');\n\nvar _direction2 = _interopRequireDefault(_direction);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _isInRange = require('../utils/is-in-range');\n\nvar _isInRange2 = _interopRequireDefault(_isInRange);\n\nvar _memoize = require('../utils/memoize');\n\nvar _memoize2 = _interopRequireDefault(_memoize);\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Node.\n *\n * And interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Object}\n */\n\nvar Node = {\n\n  /**\n   * True if the node has both descendants in that order, false otherwise. The\n   * order is depth-first, post-order.\n   *\n   * @param {String} first\n   * @param {String} second\n   * @return {Boolean}\n   */\n\n  areDescendantsSorted: function areDescendantsSorted(first, second) {\n    first = _normalize2.default.key(first);\n    second = _normalize2.default.key(second);\n\n    var sorted = void 0;\n\n    this.forEachDescendant(function (n) {\n      if (n.key === first) {\n        sorted = true;\n        return false;\n      } else if (n.key === second) {\n        sorted = false;\n        return false;\n      }\n    });\n\n    return sorted;\n  },\n\n\n  /**\n   * Assert that a node has a child by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertChild: function assertChild(key) {\n    var child = this.getChild(key);\n\n    if (!child) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a child node with key \"' + key + '\".');\n    }\n\n    return child;\n  },\n\n\n  /**\n   * Assert that a node has a descendant by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertDescendant: function assertDescendant(key) {\n    var descendant = this.getDescendant(key);\n\n    if (!descendant) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a descendant node with key \"' + key + '\".');\n    }\n\n    return descendant;\n  },\n\n\n  /**\n   * Assert that a node's tree has a node by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertNode: function assertNode(key) {\n    var node = this.getNode(key);\n\n    if (!node) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a node with key \"' + key + '\".');\n    }\n\n    return node;\n  },\n\n\n  /**\n   * Assert that a node exists at `path` and return it.\n   *\n   * @param {Array} path\n   * @return {Node}\n   */\n\n  assertPath: function assertPath(path) {\n    var descendant = this.getDescendantAtPath(path);\n\n    if (!descendant) {\n      throw new Error('Could not find a descendant at path \"' + path + '\".');\n    }\n\n    return descendant;\n  },\n\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendants: function filterDescendants(iterator) {\n    var matches = [];\n\n    this.forEachDescendant(function (node, i, nodes) {\n      if (iterator(node, i, nodes)) matches.push(node);\n    });\n\n    return (0, _immutable.List)(matches);\n  },\n\n\n  /**\n   * Recursively find all descendant nodes by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendant: function findDescendant(iterator) {\n    var found = null;\n\n    this.forEachDescendant(function (node, i, nodes) {\n      if (iterator(node, i, nodes)) {\n        found = node;\n        return false;\n      }\n    });\n\n    return found;\n  },\n\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   *\n   * @param {Function} iterator\n   */\n\n  forEachDescendant: function forEachDescendant(iterator) {\n    var ret = void 0;\n\n    this.nodes.forEach(function (child, i, nodes) {\n      if (iterator(child, i, nodes) === false) {\n        ret = false;\n        return false;\n      }\n\n      if (child.kind != 'text') {\n        ret = child.forEachDescendant(iterator);\n        return ret;\n      }\n    });\n\n    return ret;\n  },\n\n\n  /**\n   * Get the path of ancestors of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors: function getAncestors(key) {\n    key = _normalize2.default.key(key);\n\n    if (key == this.key) return (0, _immutable.List)();\n    if (this.hasChild(key)) return (0, _immutable.List)([this]);\n\n    var ancestors = void 0;\n    this.nodes.find(function (node) {\n      if (node.kind == 'text') return false;\n      ancestors = node.getAncestors(key);\n      return ancestors;\n    });\n\n    if (ancestors) {\n      return ancestors.unshift(this);\n    } else {\n      return null;\n    }\n  },\n\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks: function getBlocks() {\n    var array = this.getBlocksAsArray();\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocksAsArray: function getBlocksAsArray() {\n    return this.nodes.reduce(function (array, child) {\n      if (child.kind != 'block') return array;\n      if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray());\n      array.push(child);\n      return array;\n    }, []);\n  },\n\n\n  /**\n   * Get the leaf block descendants in a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Node>}\n   */\n\n  getBlocksAtRange: function getBlocksAtRange(range) {\n    var array = this.getBlocksAtRangeAsArray(range);\n    // Eliminate duplicates by converting to an `OrderedSet` first.\n    return new _immutable.List(new _immutable.OrderedSet(array));\n  },\n\n\n  /**\n   * Get the leaf block descendants in a `range` as an array\n   *\n   * @param {Selection} range\n   * @return {Array}\n   */\n\n  getBlocksAtRangeAsArray: function getBlocksAtRangeAsArray(range) {\n    range = range.normalize(this);\n    var _range = range,\n        startKey = _range.startKey,\n        endKey = _range.endKey;\n\n    var startBlock = this.getClosestBlock(startKey);\n\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startBlock];\n\n    var endBlock = this.getClosestBlock(endKey);\n    var blocks = this.getBlocksAsArray();\n    var start = blocks.indexOf(startBlock);\n    var end = blocks.indexOf(endBlock);\n    return blocks.slice(start, end + 1);\n  },\n\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType: function getBlocksByType(type) {\n    var array = this.getBlocksByTypeAsArray(type);\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Get all of the leaf blocks that match a `type` as an array\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getBlocksByTypeAsArray: function getBlocksByTypeAsArray(type) {\n    return this.nodes.reduce(function (array, node) {\n      if (node.kind != 'block') {\n        return array;\n      } else if (node.isLeafBlock() && node.type == type) {\n        array.push(node);\n        return array;\n      } else {\n        return array.concat(node.getBlocksByTypeAsArray(type));\n      }\n    }, []);\n  },\n\n\n  /**\n   * Get all of the characters for every text node.\n   *\n   * @return {List<Character>}\n   */\n\n  getCharacters: function getCharacters() {\n    var array = this.getCharactersAsArray();\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Get all of the characters for every text node as an array\n   *\n   * @return {Array}\n   */\n\n  getCharactersAsArray: function getCharactersAsArray() {\n    return this.nodes.reduce(function (arr, node) {\n      return node.kind == 'text' ? arr.concat(node.characters.toArray()) : arr.concat(node.getCharactersAsArray());\n    }, []);\n  },\n\n\n  /**\n   * Get a list of the characters in a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Character>}\n   */\n\n  getCharactersAtRange: function getCharactersAtRange(range) {\n    var array = this.getCharactersAtRangeAsArray(range);\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Get a list of the characters in a `range` as an array.\n   *\n   * @param {Selection} range\n   * @return {Array}\n   */\n\n  getCharactersAtRangeAsArray: function getCharactersAtRangeAsArray(range) {\n    return this.getTextsAtRange(range).reduce(function (arr, text) {\n      var chars = text.characters.filter(function (char, i) {\n        return (0, _isInRange2.default)(i, text, range);\n      }).toArray();\n\n      return arr.concat(chars);\n    }, []);\n  },\n\n\n  /**\n   * Get a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getChild: function getChild(key) {\n    key = _normalize2.default.key(key);\n    return this.nodes.find(function (node) {\n      return node.key == key;\n    });\n  },\n\n\n  /**\n   * Get closest parent of node by `key` that matches `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getClosest: function getClosest(key, iterator) {\n    key = _normalize2.default.key(key);\n    var ancestors = this.getAncestors(key);\n    if (!ancestors) {\n      throw new Error('Could not find a descendant node with key \"' + key + '\".');\n    }\n\n    // Exclude this node itself.\n    return ancestors.rest().findLast(iterator);\n  },\n\n\n  /**\n   * Get the closest block parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestBlock: function getClosestBlock(key) {\n    return this.getClosest(key, function (parent) {\n      return parent.kind == 'block';\n    });\n  },\n\n\n  /**\n   * Get the closest inline parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestInline: function getClosestInline(key) {\n    return this.getClosest(key, function (parent) {\n      return parent.kind == 'inline';\n    });\n  },\n\n\n  /**\n   * Get the closest void parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestVoid: function getClosestVoid(key) {\n    return this.getClosest(key, function (parent) {\n      return parent.isVoid;\n    });\n  },\n\n\n  /**\n   * Get the common ancestor of nodes `one` and `two` by keys.\n   *\n   * @param {String} one\n   * @param {String} two\n   * @return {Node}\n   */\n\n  getCommonAncestor: function getCommonAncestor(one, two) {\n    one = _normalize2.default.key(one);\n    two = _normalize2.default.key(two);\n\n    if (one == this.key) return this;\n    if (two == this.key) return this;\n\n    this.assertDescendant(one);\n    this.assertDescendant(two);\n    var ancestors = new _immutable.List();\n    var oneParent = this.getParent(one);\n    var twoParent = this.getParent(two);\n\n    while (oneParent) {\n      ancestors = ancestors.push(oneParent);\n      oneParent = this.getParent(oneParent.key);\n    }\n\n    while (twoParent) {\n      if (ancestors.includes(twoParent)) return twoParent;\n      twoParent = this.getParent(twoParent.key);\n    }\n  },\n\n\n  /**\n   * Get the component for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Component|Void}\n   */\n\n  getComponent: function getComponent(schema) {\n    return schema.__getComponent(this);\n  },\n\n\n  /**\n   * Get the decorations for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Array}\n   */\n\n  getDecorators: function getDecorators(schema) {\n    return schema.__getDecorators(this);\n  },\n\n\n  /**\n   * Get the depth of a child node by `key`, with optional `startAt`.\n   *\n   * @param {String} key\n   * @param {Number} startAt (optional)\n   * @return {Number} depth\n   */\n\n  getDepth: function getDepth(key) {\n    var startAt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    this.assertDescendant(key);\n    if (this.hasChild(key)) return startAt;\n    return this.getFurthestAncestor(key).getDepth(key, startAt + 1);\n  },\n\n\n  /**\n   * Get a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getDescendant: function getDescendant(key) {\n    key = _normalize2.default.key(key);\n    var descendantFound = null;\n\n    var found = this.nodes.find(function (node) {\n      if (node.key === key) {\n        return node;\n      } else if (node.kind !== 'text') {\n        descendantFound = node.getDescendant(key);\n        return descendantFound;\n      } else {\n        return false;\n      }\n    });\n\n    return descendantFound || found;\n  },\n\n\n  /**\n   * Get a descendant by `path`.\n   *\n   * @param {Array} path\n   * @return {Node|Null}\n   */\n\n  getDescendantAtPath: function getDescendantAtPath(path) {\n    var descendant = this;\n\n    for (var i = 0; i < path.length; i++) {\n      var index = path[i];\n      if (!descendant) return;\n      if (!descendant.nodes) return;\n      descendant = descendant.nodes.get(index);\n    }\n\n    return descendant;\n  },\n\n\n  /**\n   * Get the decorators for a descendant by `key` given a `schema`.\n   *\n   * @param {String} key\n   * @param {Schema} schema\n   * @return {Array}\n   */\n\n  getDescendantDecorators: function getDescendantDecorators(key, schema) {\n    if (!schema.hasDecorators) {\n      return [];\n    }\n\n    var descendant = this.assertDescendant(key);\n    var child = this.getFurthestAncestor(key);\n    var decorators = [];\n\n    while (child != descendant) {\n      decorators = decorators.concat(child.getDecorators(schema));\n      child = child.getFurthestAncestor(key);\n    }\n\n    decorators = decorators.concat(descendant.getDecorators(schema));\n    return decorators;\n  },\n\n\n  /**\n   * Get the first child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText: function getFirstText() {\n    var descendantFound = null;\n\n    var found = this.nodes.find(function (node) {\n      if (node.kind == 'text') return true;\n      descendantFound = node.getFirstText();\n      return descendantFound;\n    });\n\n    return descendantFound || found;\n  },\n\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Node>}\n   */\n\n  getFragmentAtRange: function getFragmentAtRange(range) {\n    var node = this;\n    var nodes = new _immutable.List();\n\n    // Make sure the children exist.\n    var startKey = range.startKey,\n        startOffset = range.startOffset,\n        endKey = range.endKey,\n        endOffset = range.endOffset;\n\n    node.assertDescendant(startKey);\n    node.assertDescendant(endKey);\n\n    // Split at the start and end.\n    var start = range.collapseToStart();\n    node = node.splitBlockAtRange(start, Infinity);\n\n    var next = node.getNextText(startKey);\n    var end = startKey == endKey ? range.collapseToStartOf(next).move(endOffset - startOffset) : range.collapseToEnd();\n    node = node.splitBlockAtRange(end, Infinity);\n\n    // Get the start and end nodes.\n    var startNode = node.getNextSibling(node.getFurthestAncestor(startKey).key);\n    var endNode = startKey == endKey ? node.getFurthestAncestor(next.key) : node.getFurthestAncestor(endKey);\n\n    // Get children range of nodes from start to end nodes\n    var startIndex = node.nodes.indexOf(startNode);\n    var endIndex = node.nodes.indexOf(endNode);\n    nodes = node.nodes.slice(startIndex, endIndex + 1);\n\n    // Return a new document fragment.\n    return _document2.default.create({ nodes: nodes });\n  },\n\n\n  /**\n   * Get the furthest parent of a node by `key` that matches an `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getFurthest: function getFurthest(key, iterator) {\n    var ancestors = this.getAncestors(key);\n    if (!ancestors) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a descendant node with key \"' + key + '\".');\n    }\n\n    // Exclude this node itself\n    return ancestors.rest().find(iterator);\n  },\n\n\n  /**\n   * Get the furthest block parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock: function getFurthestBlock(key) {\n    return this.getFurthest(key, function (node) {\n      return node.kind == 'block';\n    });\n  },\n\n\n  /**\n   * Get the furthest inline parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestInline: function getFurthestInline(key) {\n    return this.getFurthest(key, function (node) {\n      return node.kind == 'inline';\n    });\n  },\n\n\n  /**\n   * Get the furthest ancestor of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestAncestor: function getFurthestAncestor(key) {\n    key = _normalize2.default.key(key);\n    return this.nodes.find(function (node) {\n      if (node.key == key) return true;\n      if (node.kind == 'text') return false;\n      return node.hasDescendant(key);\n    });\n  },\n\n\n  /**\n   * Get the furthest ancestor of a node by `key` that has only one child.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestOnlyChildAncestor: function getFurthestOnlyChildAncestor(key) {\n    var ancestors = this.getAncestors(key);\n\n    if (!ancestors) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a descendant node with key \"' + key + '\".');\n    }\n\n    return ancestors\n    // Skip this node...\n    .skipLast()\n    // Take parents until there are more than one child...\n    .reverse().takeUntil(function (p) {\n      return p.nodes.size > 1;\n    })\n    // And pick the highest.\n    .last();\n  },\n\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines: function getInlines() {\n    var array = this.getInlinesAsArray();\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Get the closest inline nodes for each text node in the node, as an array.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlinesAsArray: function getInlinesAsArray() {\n    var array = [];\n\n    this.nodes.forEach(function (child) {\n      if (child.kind == 'text') return;\n      if (child.isLeafInline()) {\n        array.push(child);\n      } else {\n        array = array.concat(child.getInlinesAsArray());\n      }\n    });\n\n    return array;\n  },\n\n\n  /**\n   * Get the closest inline nodes for each text node in a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Node>}\n   */\n\n  getInlinesAtRange: function getInlinesAtRange(range) {\n    var array = this.getInlinesAtRangeAsArray(range);\n    // Remove duplicates by converting it to an `OrderedSet` first.\n    return new _immutable.List(new _immutable.OrderedSet(array));\n  },\n\n\n  /**\n   * Get the closest inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Selection} range\n   * @return {Array}\n   */\n\n  getInlinesAtRangeAsArray: function getInlinesAtRangeAsArray(range) {\n    var _this = this;\n\n    return this.getTextsAtRangeAsArray(range).map(function (text) {\n      return _this.getClosestInline(text.key);\n    }).filter(function (exists) {\n      return exists;\n    });\n  },\n\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType: function getInlinesByType(type) {\n    var array = this.getInlinesByTypeAsArray(type);\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Get all of the leaf inline nodes that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getInlinesByTypeAsArray: function getInlinesByTypeAsArray(type) {\n    return this.nodes.reduce(function (inlines, node) {\n      if (node.kind == 'text') {\n        return inlines;\n      } else if (node.isLeafInline() && node.type == type) {\n        inlines.push(node);\n        return inlines;\n      } else {\n        return inlines.concat(node.getInlinesByTypeAsArray(type));\n      }\n    }, []);\n  },\n\n\n  /**\n   * Return a set of all keys in the node.\n   *\n   * @return {Set<String>}\n   */\n\n  getKeys: function getKeys() {\n    var keys = [];\n\n    this.forEachDescendant(function (desc) {\n      keys.push(desc.key);\n    });\n\n    return new _immutable.Set(keys);\n  },\n\n\n  /**\n   * Get the last child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText: function getLastText() {\n    var descendantFound = null;\n\n    var found = this.nodes.findLast(function (node) {\n      if (node.kind == 'text') return true;\n      descendantFound = node.getLastText();\n      return descendantFound;\n    });\n\n    return descendantFound || found;\n  },\n\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {Set<Mark>}\n   */\n\n  getMarks: function getMarks() {\n    var array = this.getMarksAsArray();\n    return new _immutable.Set(array);\n  },\n\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarks: function getOrderedMarks() {\n    var array = this.getMarksAsArray();\n    return new _immutable.OrderedSet(array);\n  },\n\n\n  /**\n   * Get all of the marks as an array.\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray: function getMarksAsArray() {\n    return this.nodes.reduce(function (marks, node) {\n      return marks.concat(node.getMarksAsArray());\n    }, []);\n  },\n\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Selection} range\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtRange: function getMarksAtRange(range) {\n    var array = this.getMarksAtRangeAsArray(range);\n    return new _immutable.Set(array);\n  },\n\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Selection} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksAtRange: function getOrderedMarksAtRange(range) {\n    var array = this.getMarksAtRangeAsArray(range);\n    return new _immutable.OrderedSet(array);\n  },\n\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Selection} range\n   * @return {Array}\n   */\n\n  getMarksAtRangeAsArray: function getMarksAtRangeAsArray(range) {\n    range = range.normalize(this);\n    var _range2 = range,\n        startKey = _range2.startKey,\n        startOffset = _range2.startOffset;\n\n    // If the range is collapsed at the start of the node, check the previous.\n\n    if (range.isCollapsed && startOffset == 0) {\n      var previous = this.getPreviousText(startKey);\n      if (!previous || !previous.length) return [];\n      var char = previous.characters.get(previous.length - 1);\n      return char.marks.toArray();\n    }\n\n    // If the range is collapsed, check the character before the start.\n    if (range.isCollapsed) {\n      var text = this.getDescendant(startKey);\n      var _char = text.characters.get(range.startOffset - 1);\n      return _char.marks.toArray();\n    }\n\n    // Otherwise, get a set of the marks for each character in the range.\n    return this.getCharactersAtRange(range).reduce(function (memo, char) {\n      char.marks.toArray().forEach(function (c) {\n        return memo.push(c);\n      });\n      return memo;\n    }, []);\n  },\n\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {Set<Mark>}\n   */\n\n  getMarksByType: function getMarksByType(type) {\n    var array = this.getMarksByTypeAsArray(type);\n    return new _immutable.Set(array);\n  },\n\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksByType: function getOrderedMarksByType(type) {\n    var array = this.getMarksByTypeAsArray(type);\n    return new _immutable.OrderedSet(array);\n  },\n\n\n  /**\n   * Get all of the marks that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getMarksByTypeAsArray: function getMarksByTypeAsArray(type) {\n    return this.nodes.reduce(function (array, node) {\n      return node.kind == 'text' ? array.concat(node.getMarksAsArray().filter(function (m) {\n        return m.type == type;\n      })) : array.concat(node.getMarksByTypeAsArray(type));\n    }, []);\n  },\n\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextBlock: function getNextBlock(key) {\n    var child = this.assertDescendant(key);\n    var last = void 0;\n\n    if (child.kind == 'block') {\n      last = child.getLastText();\n    } else {\n      var block = this.getClosestBlock(key);\n      last = block.getLastText();\n    }\n\n    var next = this.getNextText(last.key);\n    if (!next) return null;\n\n    return this.getClosestBlock(next.key);\n  },\n\n\n  /**\n   * Get the node after a descendant by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextSibling: function getNextSibling(key) {\n    key = _normalize2.default.key(key);\n\n    var parent = this.getParent(key);\n    var after = parent.nodes.skipUntil(function (child) {\n      return child.key == key;\n    });\n\n    if (after.size == 0) {\n      throw new Error('Could not find a child node with key \"' + key + '\".');\n    }\n    return after.get(1);\n  },\n\n\n  /**\n   * Get the text node after a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextText: function getNextText(key) {\n    key = _normalize2.default.key(key);\n    return this.getTexts().skipUntil(function (text) {\n      return text.key == key;\n    }).get(1);\n  },\n\n\n  /**\n   * Get a node in the tree by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNode: function getNode(key) {\n    key = _normalize2.default.key(key);\n    return this.key == key ? this : this.getDescendant(key);\n  },\n\n\n  /**\n   * Get the offset for a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n\n  getOffset: function getOffset(key) {\n    this.assertDescendant(key);\n\n    // Calculate the offset of the nodes before the highest child.\n    var child = this.getFurthestAncestor(key);\n    var offset = this.nodes.takeUntil(function (n) {\n      return n == child;\n    }).reduce(function (memo, n) {\n      return memo + n.length;\n    }, 0);\n\n    // Recurse if need be.\n    return this.hasChild(key) ? offset : offset + child.getOffset(key);\n  },\n\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Selection} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange: function getOffsetAtRange(range) {\n    range = range.normalize(this);\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.');\n    }\n\n    var _range3 = range,\n        startKey = _range3.startKey,\n        startOffset = _range3.startOffset;\n\n    return this.getOffset(startKey) + startOffset;\n  },\n\n\n  /**\n   * Get the parent of a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getParent: function getParent(key) {\n    if (this.hasChild(key)) return this;\n\n    var node = null;\n\n    this.nodes.find(function (child) {\n      if (child.kind == 'text') {\n        return false;\n      } else {\n        node = child.getParent(key);\n        return node;\n      }\n    });\n\n    return node;\n  },\n\n\n  /**\n   * Get the path of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {Array}\n   */\n\n  getPath: function getPath(key) {\n    var child = this.assertNode(key);\n    var ancestors = this.getAncestors(key);\n    var path = [];\n\n    ancestors.reverse().forEach(function (ancestor) {\n      var index = ancestor.nodes.indexOf(child);\n      path.unshift(index);\n      child = ancestor;\n    });\n\n    return path;\n  },\n\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock: function getPreviousBlock(key) {\n    var child = this.assertDescendant(key);\n    var first = void 0;\n\n    if (child.kind == 'block') {\n      first = child.getFirstText();\n    } else {\n      var block = this.getClosestBlock(key);\n      first = block.getFirstText();\n    }\n\n    var previous = this.getPreviousText(first.key);\n    if (!previous) return null;\n\n    return this.getClosestBlock(previous.key);\n  },\n\n\n  /**\n   * Get the node before a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling: function getPreviousSibling(key) {\n    key = _normalize2.default.key(key);\n    var parent = this.getParent(key);\n    var before = parent.nodes.takeUntil(function (child) {\n      return child.key == key;\n    });\n\n    if (before.size == parent.nodes.size) {\n      throw new Error('Could not find a child node with key \"' + key + '\".');\n    }\n\n    return before.last();\n  },\n\n\n  /**\n   * Get the text node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousText: function getPreviousText(key) {\n    key = _normalize2.default.key(key);\n    return this.getTexts().takeUntil(function (text) {\n      return text.key == key;\n    }).last();\n  },\n\n\n  /**\n   * Get the concatenated text string of all child nodes.\n   *\n   * @return {String}\n   */\n\n  getText: function getText() {\n    return this.nodes.reduce(function (string, node) {\n      return string + node.text;\n    }, '');\n  },\n\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset: function getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset == 0) return this.getFirstText();\n    if (offset == this.length) return this.getLastText();\n    if (offset < 0 || offset > this.length) return null;\n\n    var length = 0;\n\n    return this.getTexts().find(function (text, i, texts) {\n      length += text.length;\n      return length > offset;\n    });\n  },\n\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection: function getTextDirection() {\n    var dir = (0, _direction2.default)(this.text);\n    return dir == 'neutral' ? undefined : dir;\n  },\n\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts: function getTexts() {\n    var array = this.getTextsAsArray();\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Recursively get all the leaf text nodes in order of appearance, as array.\n   *\n   * @return {List<Node>}\n   */\n\n  getTextsAsArray: function getTextsAsArray() {\n    var array = [];\n\n    this.nodes.forEach(function (node) {\n      if (node.kind == 'text') {\n        array.push(node);\n      } else {\n        array = array.concat(node.getTextsAsArray());\n      }\n    });\n\n    return array;\n  },\n\n\n  /**\n   * Get all of the text nodes in a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange: function getTextsAtRange(range) {\n    var array = this.getTextsAtRangeAsArray(range);\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   *\n   * @param {Selection} range\n   * @return {Array}\n   */\n\n  getTextsAtRangeAsArray: function getTextsAtRangeAsArray(range) {\n    range = range.normalize(this);\n    var _range4 = range,\n        startKey = _range4.startKey,\n        endKey = _range4.endKey;\n\n    var startText = this.getDescendant(startKey);\n\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startText];\n\n    var endText = this.getDescendant(endKey);\n    var texts = this.getTextsAsArray();\n    var start = texts.indexOf(startText);\n    var end = texts.indexOf(endText);\n    return texts.slice(start, end + 1);\n  },\n\n\n  /**\n   * Check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasChild: function hasChild(key) {\n    return !!this.getChild(key);\n  },\n\n\n  /**\n   * Recursively check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasDescendant: function hasDescendant(key) {\n    return !!this.getDescendant(key);\n  },\n\n\n  /**\n   * Recursively check if a node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasNode: function hasNode(key) {\n    return !!this.getNode(key);\n  },\n\n\n  /**\n   * Check if a node has a void parent by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasVoidParent: function hasVoidParent(key) {\n    return !!this.getClosest(key, function (parent) {\n      return parent.isVoid;\n    });\n  },\n\n\n  /**\n   * Insert a `node` at `index`.\n   *\n   * @param {Number} index\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode: function insertNode(index, node) {\n    var keys = this.getKeys();\n\n    if (keys.contains(node.key)) {\n      node = node.regenerateKey();\n    }\n\n    if (node.kind != 'text') {\n      node = node.mapDescendants(function (desc) {\n        return keys.contains(desc.key) ? desc.regenerateKey() : desc;\n      });\n    }\n\n    var nodes = this.nodes.insert(index, node);\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock: function isLeafBlock() {\n    return this.kind == 'block' && this.nodes.every(function (n) {\n      return n.kind != 'block';\n    });\n  },\n\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline: function isLeafInline() {\n    return this.kind == 'inline' && this.nodes.every(function (n) {\n      return n.kind != 'inline';\n    });\n  },\n\n\n  /**\n   * Join a children node `first` with another children node `second`.\n   * `first` and `second` will be concatenated in that order.\n   * `first` and `second` must be two Nodes or two Text.\n   *\n   * @param {Node} first\n   * @param {Node} second\n   * @param {Boolean} options.deep (optional) Join recursively the\n   * respective last node and first node of the nodes' children. Like a zipper :)\n   * @return {Node}\n   */\n\n  joinNode: function joinNode(first, second, options) {\n    var _options$deep = options.deep,\n        deep = _options$deep === undefined ? false : _options$deep;\n\n    var node = this;\n    var parent = node.getParent(second.key);\n    var isParent = node == parent;\n    var index = parent.nodes.indexOf(second);\n\n    if (second.kind == 'text') {\n      var _first = first,\n          characters = _first.characters;\n\n      characters = characters.concat(second.characters);\n      first = first.set('characters', characters);\n    } else {\n      var size = first.nodes.size;\n\n      second.nodes.forEach(function (child, i) {\n        first = first.insertNode(size + i, child);\n      });\n\n      if (deep) {\n        // Join recursively\n        first = first.joinNode(first.nodes.get(size - 1), first.nodes.get(size), { deep: deep });\n      }\n    }\n\n    parent = parent.removeNode(index);\n    node = isParent ? parent : node.updateDescendant(parent);\n    node = node.updateDescendant(first);\n    return node;\n  },\n\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapChildren: function mapChildren(iterator) {\n    var _this2 = this;\n\n    var nodes = this.nodes;\n\n\n    nodes.forEach(function (node, i) {\n      var ret = iterator(node, i, _this2.nodes);\n      if (ret != node) nodes = nodes.set(ret.key, ret);\n    });\n\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapDescendants: function mapDescendants(iterator) {\n    var _this3 = this;\n\n    var nodes = this.nodes;\n\n\n    nodes.forEach(function (node, i) {\n      var ret = node;\n      if (ret.kind != 'text') ret = ret.mapDescendants(iterator);\n      ret = iterator(ret, i, _this3.nodes);\n      if (ret == node) return;\n\n      var index = nodes.indexOf(node);\n      nodes = nodes.set(index, ret);\n    });\n\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey: function regenerateKey() {\n    var key = (0, _generateKey2.default)();\n    return this.set('key', key);\n  },\n\n\n  /**\n   * Remove a `node` from the children node map.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  removeDescendant: function removeDescendant(key) {\n    key = _normalize2.default.key(key);\n\n    var node = this;\n    var parent = node.getParent(key);\n    if (!parent) throw new Error('Could not find a descendant node with key \"' + key + '\".');\n\n    var index = parent.nodes.findIndex(function (n) {\n      return n.key === key;\n    });\n    var isParent = node == parent;\n    var nodes = parent.nodes.splice(index, 1);\n\n    parent = parent.set('nodes', nodes);\n    node = isParent ? parent : node.updateDescendant(parent);\n    return node;\n  },\n\n\n  /**\n   * Remove a node at `index`.\n   *\n   * @param {Number} index\n   * @return {Node}\n   */\n\n  removeNode: function removeNode(index) {\n    var nodes = this.nodes.splice(index, 1);\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Split the block nodes at a `range`, to optional `height`.\n   *\n   * @param {Selection} range\n   * @param {Number} height (optional)\n   * @return {Node}\n   */\n\n  splitBlockAtRange: function splitBlockAtRange(range) {\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var startKey = range.startKey,\n        startOffset = range.startOffset;\n\n    var base = this;\n    var node = base.assertDescendant(startKey);\n    var parent = base.getClosestBlock(node.key);\n    var offset = startOffset;\n    var h = 0;\n\n    while (parent && parent.kind == 'block' && h < height) {\n      offset += parent.getOffset(node.key);\n      node = parent;\n      parent = base.getClosestBlock(parent.key);\n      h++;\n    }\n\n    var path = base.getPath(node.key);\n    return this.splitNode(path, offset);\n  },\n\n\n  /**\n   * Split a node by `path` at `offset`.\n   *\n   * @param {Array} path\n   * @param {Number} offset\n   * @return {Node}\n   */\n\n  splitNode: function splitNode(path, offset) {\n    var base = this;\n    var node = base.assertPath(path);\n    var parent = base.getParent(node.key);\n    var isParent = base == parent;\n    var index = parent.nodes.indexOf(node);\n\n    var child = node;\n    var one = void 0;\n    var two = void 0;\n\n    if (node.kind != 'text') {\n      child = node.getTextAtOffset(offset);\n    }\n\n    while (child && child != parent) {\n      if (child.kind == 'text') {\n        var i = node.kind == 'text' ? offset : offset - node.getOffset(child.key);\n        var _child = child,\n            characters = _child.characters;\n\n        var oneChars = characters.take(i);\n        var twoChars = characters.skip(i);\n        one = child.set('characters', oneChars);\n        two = child.set('characters', twoChars).regenerateKey();\n      } else {\n        var _child2 = child,\n            nodes = _child2.nodes;\n\n        // Try to preserve the nodes list to preserve reference of one == node to avoid re-render\n        // When spliting at the end of a text node, the first node is preserved\n\n        var oneNodes = nodes.takeUntil(function (n) {\n          return n.key == one.key;\n        });\n        oneNodes = oneNodes.size == nodes.size - 1 && one == nodes.last() ? nodes : oneNodes.push(one);\n\n        var twoNodes = nodes.skipUntil(function (n) {\n          return n.key == one.key;\n        }).rest().unshift(two);\n        one = child.set('nodes', oneNodes);\n        two = child.set('nodes', twoNodes).regenerateKey();\n      }\n\n      child = base.getParent(child.key);\n    }\n\n    parent = parent.removeNode(index);\n    parent = parent.insertNode(index, two);\n    parent = parent.insertNode(index, one);\n    base = isParent ? parent : base.updateDescendant(parent);\n    return base;\n  },\n\n\n  /**\n   * Split a node by `path` after 'count' children.\n   * Does not work on Text nodes. Use `Node.splitNode` to split text nodes as well.\n   *\n   * @param {Array} path\n   * @param {Number} count\n   * @return {Node}\n   */\n\n  splitNodeAfter: function splitNodeAfter(path, count) {\n    var base = this;\n    var node = base.assertPath(path);\n    if (node.kind === 'text') throw new Error('Cannot split text node at index. Use Node.splitNode at offset instead');\n    var nodes = node.nodes;\n\n\n    var parent = base.getParent(node.key);\n    var isParent = base == parent;\n\n    var oneNodes = nodes.take(count);\n    var twoNodes = nodes.skip(count);\n\n    var one = node.set('nodes', oneNodes);\n    var two = node.set('nodes', twoNodes).regenerateKey();\n\n    var nodeIndex = parent.nodes.indexOf(node);\n    parent = parent.removeNode(nodeIndex);\n    parent = parent.insertNode(nodeIndex, two);\n    parent = parent.insertNode(nodeIndex, one);\n\n    base = isParent ? parent : base.updateDescendant(parent);\n    return base;\n  },\n\n\n  /**\n   * Set a new value for a child node by `key`.\n   *\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  updateDescendant: function updateDescendant(node) {\n    var child = this.assertDescendant(node.key);\n    var ancestors = this.getAncestors(node.key);\n\n    ancestors.reverse().forEach(function (parent) {\n      var _parent = parent,\n          nodes = _parent.nodes;\n\n      var index = nodes.indexOf(child);\n      child = parent;\n      nodes = nodes.set(index, node);\n      parent = parent.set('nodes', nodes);\n      node = parent;\n    });\n\n    return node;\n  },\n\n\n  /**\n   * Validate the node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Object|Null}\n   */\n\n  validate: function validate(schema) {\n    return schema.__validate(this);\n  },\n\n\n  /**\n   * True if the node has both descendants in that order, false otherwise. The\n   * order is depth-first, post-order.\n   *\n   * @param {String} first\n   * @param {String} second\n   * @return {Boolean}\n   */\n\n  areDescendantSorted: function areDescendantSorted(first, second) {\n    (0, _warn2.default)('The Node.areDescendantSorted(first, second) method is deprecated, please use `Node.areDescendantsSorted(first, second) instead.');\n    return this.areDescendantsSorted(first, second);\n  },\n\n\n  /**\n   * Concat children `nodes` on to the end of the node.\n   *\n   * @param {List<Node>} nodes\n   * @return {Node}\n   */\n\n  concatChildren: function concatChildren(nodes) {\n    (0, _warn2.default)('The `Node.concatChildren(nodes)` method is deprecated.');\n    nodes = this.nodes.concat(nodes);\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Decorate all of the text nodes with a `decorator` function.\n   *\n   * @param {Function} decorator\n   * @return {Node}\n   */\n\n  decorateTexts: function decorateTexts(decorator) {\n    (0, _warn2.default)('The `Node.decorateTexts(decorator) method is deprecated.');\n    return this.mapDescendants(function (child) {\n      return child.kind == 'text' ? child.decorateCharacters(decorator) : child;\n    });\n  },\n\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`, depth-first.\n   * It is different from `filterDescendants` in regard of the order of results.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendantsDeep: function filterDescendantsDeep(iterator) {\n    (0, _warn2.default)('The Node.filterDescendantsDeep(iterator) method is deprecated.');\n    return this.nodes.reduce(function (matches, child, i, nodes) {\n      if (child.kind != 'text') matches = matches.concat(child.filterDescendantsDeep(iterator));\n      if (iterator(child, i, nodes)) matches = matches.push(child);\n      return matches;\n    }, new _immutable.List());\n  },\n\n\n  /**\n   * Recursively find all descendant nodes by `iterator`. Depth first.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendantDeep: function findDescendantDeep(iterator) {\n    (0, _warn2.default)('The Node.findDescendantDeep(iterator) method is deprecated.');\n    var found = void 0;\n\n    this.forEachDescendant(function (node) {\n      if (iterator(node)) {\n        found = node;\n        return false;\n      }\n    });\n\n    return found;\n  },\n\n\n  /**\n   * Get children between two child keys.\n   *\n   * @param {String} start\n   * @param {String} end\n   * @return {Node}\n   */\n\n  getChildrenBetween: function getChildrenBetween(start, end) {\n    (0, _warn2.default)('The `Node.getChildrenBetween(start, end)` method is deprecated.');\n    start = this.assertChild(start);\n    start = this.nodes.indexOf(start);\n    end = this.assertChild(end);\n    end = this.nodes.indexOf(end);\n    return this.nodes.slice(start + 1, end);\n  },\n\n\n  /**\n   * Get children between two child keys, including the two children.\n   *\n   * @param {String} start\n   * @param {String} end\n   * @return {Node}\n   */\n\n  getChildrenBetweenIncluding: function getChildrenBetweenIncluding(start, end) {\n    (0, _warn2.default)('The `Node.getChildrenBetweenIncluding(start, end)` method is deprecated.');\n    start = this.assertChild(start);\n    start = this.nodes.indexOf(start);\n    end = this.assertChild(end);\n    end = this.nodes.indexOf(end);\n    return this.nodes.slice(start, end + 1);\n  },\n\n\n  /**\n   * Get the highest child ancestor of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getHighestChild: function getHighestChild(key) {\n    (0, _warn2.default)('The `Node.getHighestChild(key) method is deprecated, please use `Node.getFurthestAncestor(key) instead.');\n    return this.getFurthestAncestor(key);\n  },\n\n\n  /**\n   * Get the highest parent of a node by `key` which has an only child.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getHighestOnlyChildParent: function getHighestOnlyChildParent(key) {\n    (0, _warn2.default)('The `Node.getHighestOnlyChildParent(key)` method is deprecated, please use `Node.getFurthestOnlyChildAncestor` instead.');\n    return this.getFurthestOnlyChildAncestor(key);\n  },\n\n\n  /**\n   * Check if the inline nodes are split at a `range`.\n   *\n   * @param {Selection} range\n   * @return {Boolean}\n   */\n\n  isInlineSplitAtRange: function isInlineSplitAtRange(range) {\n    (0, _warn2.default)('The `Node.isInlineSplitAtRange(range)` method is deprecated.');\n    range = range.normalize(this);\n    if (range.isExpanded) throw new Error();\n\n    var _range5 = range,\n        startKey = _range5.startKey;\n\n    var start = this.getFurthestInline(startKey) || this.getDescendant(startKey);\n    return range.isAtStartOf(start) || range.isAtEndOf(start);\n  }\n};\n\n/**\n * Memoize read methods.\n */\n\n(0, _memoize2.default)(Node, ['getBlocks', 'getBlocksAsArray', 'getCharacters', 'getCharactersAsArray', 'getFirstText', 'getInlines', 'getInlinesAsArray', 'getKeys', 'getLastText', 'getMarks', 'getOrderedMarks', 'getMarksAsArray', 'getText', 'getTextDirection', 'getTexts', 'getTextsAsArray', 'isLeafBlock', 'isLeafInline'], {\n  takesArguments: false\n});\n\n(0, _memoize2.default)(Node, ['areDescendantsSorted', 'getAncestors', 'getBlocksAtRange', 'getBlocksAtRangeAsArray', 'getBlocksByType', 'getBlocksByTypeAsArray', 'getCharactersAtRange', 'getCharactersAtRangeAsArray', 'getChild', 'getChildrenBetween', 'getChildrenBetweenIncluding', 'getClosestBlock', 'getClosestInline', 'getClosestVoid', 'getCommonAncestor', 'getComponent', 'getDecorators', 'getDepth', 'getDescendant', 'getDescendantAtPath', 'getDescendantDecorators', 'getFragmentAtRange', 'getFurthestBlock', 'getFurthestInline', 'getFurthestAncestor', 'getFurthestOnlyChildAncestor', 'getInlinesAtRange', 'getInlinesAtRangeAsArray', 'getInlinesByType', 'getInlinesByTypeAsArray', 'getMarksAtRange', 'getOrderedMarksAtRange', 'getMarksAtRangeAsArray', 'getMarksByType', 'getOrderedMarksByType', 'getMarksByTypeAsArray', 'getNextBlock', 'getNextSibling', 'getNextText', 'getNode', 'getOffset', 'getOffsetAtRange', 'getParent', 'getPath', 'getPreviousBlock', 'getPreviousSibling', 'getPreviousText', 'getTextAtOffset', 'getTextsAtRange', 'getTextsAtRangeAsArray', 'hasChild', 'hasDescendant', 'hasNode', 'hasVoidParent', 'isInlineSplitAtRange', 'validate'], {\n  takesArguments: true\n});\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Node;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/node.js\n// module id = ./node_modules/slate/lib/models/node.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _character = require('./character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _mark = require('./mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  marks: new _immutable.Set(),\n  text: ''\n};\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nvar Range = function (_ref) {\n  _inherits(Range, _ref);\n\n  function Range() {\n    _classCallCheck(this, Range);\n\n    return _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).apply(this, arguments));\n  }\n\n  _createClass(Range, [{\n    key: 'getCharacters',\n\n\n    /**\n     * Return range as a list of characters\n     *\n     * @return {List<Character>}\n     */\n\n    value: function getCharacters() {\n      var marks = this.marks;\n\n\n      return _character2.default.createList(this.text.split('').map(function (char) {\n        return _character2.default.create({\n          text: char,\n          marks: marks\n        });\n      }));\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'range';\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Range` with `properties`.\n     *\n     * @param {Object|Range} properties\n     * @return {Range}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(properties)) return properties;\n      properties.text = properties.text;\n      properties.marks = _mark2.default.createSet(properties.marks);\n      return new Range(properties);\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate Range or not\n     *\n     * @param {*} maybeRange\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isRange',\n    value: function isRange(maybeRange) {\n      return !!(maybeRange && maybeRange[_modelTypes2.default.RANGE]);\n    }\n  }]);\n\n  return Range;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Pseduo-symbol that shows this is a Slate Range\n */\n\nRange.prototype[_modelTypes2.default.RANGE] = true;\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexports.default = Range;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/range.js\n// module id = ./node_modules/slate/lib/models/range.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _isReactComponent = require('../utils/is-react-component');\n\nvar _isReactComponent2 = _interopRequireDefault(_isReactComponent);\n\nvar _typeOf = require('type-of');\n\nvar _typeOf2 = _interopRequireDefault(_typeOf);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _immutable = require('immutable');\n\nvar _find = require('lodash/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  rules: []\n};\n\n/**\n * Schema.\n *\n * @type {Schema}\n */\n\nvar Schema = function (_ref) {\n  _inherits(Schema, _ref);\n\n  function Schema() {\n    _classCallCheck(this, Schema);\n\n    return _possibleConstructorReturn(this, (Schema.__proto__ || Object.getPrototypeOf(Schema)).apply(this, arguments));\n  }\n\n  _createClass(Schema, [{\n    key: '__getComponent',\n\n\n    /**\n     * Return the renderer for an `object`.\n     *\n     * This method is private, because it should always be called on one of the\n     * often-changing immutable objects instead, since it will be memoized for\n     * much better performance.\n     *\n     * @param {Mixed} object\n     * @return {Component|Void}\n     */\n\n    value: function __getComponent(object) {\n      var match = (0, _find2.default)(this.rules, function (rule) {\n        return rule.render && rule.match(object);\n      });\n      if (!match) return;\n      return match.render;\n    }\n\n    /**\n     * Return the decorators for an `object`.\n     *\n     * This method is private, because it should always be called on one of the\n     * often-changing immutable objects instead, since it will be memoized for\n     * much better performance.\n     *\n     * @param {Mixed} object\n     * @return {Array}\n     */\n\n  }, {\n    key: '__getDecorators',\n    value: function __getDecorators(object) {\n      return this.rules.filter(function (rule) {\n        return rule.decorate && rule.match(object);\n      }).map(function (rule) {\n        return function (text) {\n          return rule.decorate(text, object);\n        };\n      });\n    }\n\n    /**\n     * Validate an `object` against the schema, returning the failing rule and\n     * value if the object is invalid, or void if it's valid.\n     *\n     * This method is private, because it should always be called on one of the\n     * often-changing immutable objects instead, since it will be memoized for\n     * much better performance.\n     *\n     * @param {Mixed} object\n     * @return {Object|Void}\n     */\n\n  }, {\n    key: '__validate',\n    value: function __validate(object) {\n      var value = void 0;\n\n      var match = (0, _find2.default)(this.rules, function (rule) {\n        if (!rule.validate) return;\n        if (!rule.match(object)) return;\n\n        value = rule.validate(object);\n        return value;\n      });\n\n      if (!value) return;\n\n      return {\n        rule: match,\n        value: value\n      };\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'schema';\n    }\n\n    /**\n     * Return true if one rule can normalize the document\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasValidators',\n    get: function get() {\n      var rules = this.rules;\n\n      return rules.some(function (rule) {\n        return rule.validate;\n      });\n    }\n\n    /**\n     * Return true if one rule can decorate text nodes\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasDecorators',\n    get: function get() {\n      var rules = this.rules;\n\n      return rules.some(function (rule) {\n        return rule.decorate;\n      });\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Schema` with `properties`.\n     *\n     * @param {Object|Schema} properties\n     * @return {Schema}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Schema.isSchema(properties)) return properties;\n      return new Schema(normalizeProperties(properties));\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate Schema or not\n     *\n     * @param {*} maybeSchema\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSchema',\n    value: function isSchema(maybeSchema) {\n      return !!(maybeSchema && maybeSchema[_modelTypes2.default.SCHEMA]);\n    }\n  }]);\n\n  return Schema;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Normalize the `properties` of a schema.\n *\n * @param {Object} properties\n * @return {Object}\n */\n\nfunction normalizeProperties(properties) {\n  var _properties$rules = properties.rules,\n      rules = _properties$rules === undefined ? [] : _properties$rules,\n      nodes = properties.nodes,\n      marks = properties.marks;\n\n\n  if (nodes) {\n    var array = normalizeNodes(nodes);\n    rules = rules.concat(array);\n  }\n\n  if (marks) {\n    var _array = normalizeMarks(marks);\n    rules = rules.concat(_array);\n  }\n\n  return { rules: rules };\n}\n\n/**\n * Normalize a `nodes` shorthand argument.\n *\n * @param {Object} nodes\n * @return {Array}\n */\n\nfunction normalizeNodes(nodes) {\n  var rules = [];\n\n  var _loop = function _loop(key) {\n    var rule = nodes[key];\n\n    if ((0, _typeOf2.default)(rule) == 'function' || (0, _isReactComponent2.default)(rule)) {\n      rule = { render: rule };\n    }\n\n    rule.match = function (object) {\n      return (object.kind == 'block' || object.kind == 'inline') && object.type == key;\n    };\n\n    rules.push(rule);\n  };\n\n  for (var key in nodes) {\n    _loop(key);\n  }\n\n  return rules;\n}\n\n/**\n * Normalize a `marks` shorthand argument.\n *\n * @param {Object} marks\n * @return {Array}\n */\n\nfunction normalizeMarks(marks) {\n  var rules = [];\n\n  var _loop2 = function _loop2(key) {\n    var rule = marks[key];\n\n    if (!rule.render && !rule.decorator && !rule.validate) {\n      rule = { render: rule };\n    }\n\n    rule.render = normalizeMarkComponent(rule.render);\n    rule.match = function (object) {\n      return object.kind == 'mark' && object.type == key;\n    };\n    rules.push(rule);\n  };\n\n  for (var key in marks) {\n    _loop2(key);\n  }\n\n  return rules;\n}\n\n/**\n * Normalize a mark `render` property.\n *\n * @param {Component|Function|Object|String} render\n * @return {Component}\n */\n\nfunction normalizeMarkComponent(render) {\n  if ((0, _isReactComponent2.default)(render)) return render;\n\n  switch ((0, _typeOf2.default)(render)) {\n    case 'function':\n      return render;\n    case 'object':\n      return function (props) {\n        return _react2.default.createElement(\n          'span',\n          { style: render },\n          props.children\n        );\n      };\n    case 'string':\n      return function (props) {\n        return _react2.default.createElement(\n          'span',\n          { className: render },\n          props.children\n        );\n      };\n  }\n}\n\n/**\n * Pseduo-symbol that shows this is a Slate Schema\n */\n\nSchema.prototype[_modelTypes2.default.SCHEMA] = true;\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexports.default = Schema;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/schema.js\n// module id = ./node_modules/slate/lib/models/schema.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  anchorKey: null,\n  anchorOffset: 0,\n  focusKey: null,\n  focusOffset: 0,\n  isBackward: null,\n  isFocused: false,\n  marks: null\n};\n\n/**\n * Selection.\n *\n * @type {Selection}\n */\n\nvar Selection = function (_ref) {\n  _inherits(Selection, _ref);\n\n  function Selection() {\n    _classCallCheck(this, Selection);\n\n    return _possibleConstructorReturn(this, (Selection.__proto__ || Object.getPrototypeOf(Selection)).apply(this, arguments));\n  }\n\n  _createClass(Selection, [{\n    key: 'hasAnchorAtStartOf',\n\n\n    /**\n     * Check whether anchor point of the selection is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n    value: function hasAnchorAtStartOf(node) {\n      // PERF: Do a check for a `0` offset first since it's quickest.\n      if (this.anchorOffset != 0) return false;\n      var first = getFirst(node);\n      return this.anchorKey == first.key;\n    }\n\n    /**\n     * Check whether anchor point of the selection is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorAtEndOf',\n    value: function hasAnchorAtEndOf(node) {\n      var last = getLast(node);\n      return this.anchorKey == last.key && this.anchorOffset == last.length;\n    }\n\n    /**\n     * Check whether the anchor edge of a selection is in a `node` and at an\n     * offset between `start` and `end`.\n     *\n     * @param {Node} node\n     * @param {Number} start\n     * @param {Number} end\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorBetween',\n    value: function hasAnchorBetween(node, start, end) {\n      return this.anchorOffset <= end && start <= this.anchorOffset && this.hasAnchorIn(node);\n    }\n\n    /**\n     * Check whether the anchor edge of a selection is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorIn',\n    value: function hasAnchorIn(node) {\n      return node.kind == 'text' ? node.key == this.anchorKey : node.hasDescendant(this.anchorKey);\n    }\n\n    /**\n     * Check whether focus point of the selection is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusAtEndOf',\n    value: function hasFocusAtEndOf(node) {\n      var last = getLast(node);\n      return this.focusKey == last.key && this.focusOffset == last.length;\n    }\n\n    /**\n     * Check whether focus point of the selection is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusAtStartOf',\n    value: function hasFocusAtStartOf(node) {\n      if (this.focusOffset != 0) return false;\n      var first = getFirst(node);\n      return this.focusKey == first.key;\n    }\n\n    /**\n     * Check whether the focus edge of a selection is in a `node` and at an\n     * offset between `start` and `end`.\n     *\n     * @param {Node} node\n     * @param {Number} start\n     * @param {Number} end\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusBetween',\n    value: function hasFocusBetween(node, start, end) {\n      return start <= this.focusOffset && this.focusOffset <= end && this.hasFocusIn(node);\n    }\n\n    /**\n     * Check whether the focus edge of a selection is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusIn',\n    value: function hasFocusIn(node) {\n      return node.kind == 'text' ? node.key == this.focusKey : node.hasDescendant(this.focusKey);\n    }\n\n    /**\n     * Check whether the selection is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOf',\n    value: function isAtStartOf(node) {\n      return this.isCollapsed && this.hasAnchorAtStartOf(node);\n    }\n\n    /**\n     * Check whether the selection is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOf',\n    value: function isAtEndOf(node) {\n      return this.isCollapsed && this.hasAnchorAtEndOf(node);\n    }\n\n    /**\n     * Focus the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'focus',\n    value: function focus() {\n      return this.merge({\n        isFocused: true\n      });\n    }\n\n    /**\n     * Blur the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'blur',\n    value: function blur() {\n      return this.merge({\n        isFocused: false\n      });\n    }\n\n    /**\n     * Unset the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'deselect',\n    value: function deselect() {\n      return this.merge({\n        anchorKey: null,\n        anchorOffset: 0,\n        focusKey: null,\n        focusOffset: 0,\n        isFocused: false,\n        isBackward: false\n      });\n    }\n\n    /**\n     * Flip the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'flip',\n    value: function flip() {\n      return this.merge({\n        anchorKey: this.focusKey,\n        anchorOffset: this.focusOffset,\n        focusKey: this.anchorKey,\n        focusOffset: this.anchorOffset,\n        isBackward: this.isBackward == null ? null : !this.isBackward\n      });\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchor',\n    value: function moveAnchor() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var anchorKey = this.anchorKey,\n          focusKey = this.focusKey,\n          focusOffset = this.focusOffset,\n          isBackward = this.isBackward;\n\n      var anchorOffset = this.anchorOffset + n;\n      return this.merge({\n        anchorOffset: anchorOffset,\n        isBackward: anchorKey == focusKey ? anchorOffset > focusOffset : isBackward\n      });\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocus',\n    value: function moveFocus() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var anchorKey = this.anchorKey,\n          anchorOffset = this.anchorOffset,\n          focusKey = this.focusKey,\n          isBackward = this.isBackward;\n\n      var focusOffset = this.focusOffset + n;\n      return this.merge({\n        focusOffset: focusOffset,\n        isBackward: focusKey == anchorKey ? anchorOffset > focusOffset : isBackward\n      });\n    }\n\n    /**\n     * Move the selection's anchor point to a `key` and `offset`.\n     *\n     * @param {String} key\n     * @param {Number} offset\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorTo',\n    value: function moveAnchorTo(key, offset) {\n      var anchorKey = this.anchorKey,\n          focusKey = this.focusKey,\n          focusOffset = this.focusOffset,\n          isBackward = this.isBackward;\n\n      return this.merge({\n        anchorKey: key,\n        anchorOffset: offset,\n        isBackward: key == focusKey ? offset > focusOffset : key == anchorKey ? isBackward : null\n      });\n    }\n\n    /**\n     * Move the selection's focus point to a `key` and `offset`.\n     *\n     * @param {String} key\n     * @param {Number} offset\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusTo',\n    value: function moveFocusTo(key, offset) {\n      var focusKey = this.focusKey,\n          anchorKey = this.anchorKey,\n          anchorOffset = this.anchorOffset,\n          isBackward = this.isBackward;\n\n      return this.merge({\n        focusKey: key,\n        focusOffset: offset,\n        isBackward: key == anchorKey ? anchorOffset > offset : key == focusKey ? isBackward : null\n      });\n    }\n\n    /**\n     * Move the selection to `anchorOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorOffsetTo',\n    value: function moveAnchorOffsetTo(anchorOffset) {\n      return this.merge({\n        anchorOffset: anchorOffset,\n        isBackward: this.anchorKey == this.focusKey ? anchorOffset > this.focusOffset : this.isBackward\n      });\n    }\n\n    /**\n     * Move the selection to `focusOffset`.\n     *\n     * @param {Number} focusOffset\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusOffsetTo',\n    value: function moveFocusOffsetTo(focusOffset) {\n      return this.merge({\n        focusOffset: focusOffset,\n        isBackward: this.anchorKey == this.focusKey ? this.anchorOffset > focusOffset : this.isBackward\n      });\n    }\n\n    /**\n     * Move the selection to `anchorOffset` and `focusOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @param {Number} focusOffset (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveOffsetsTo',\n    value: function moveOffsetsTo(anchorOffset) {\n      var focusOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : anchorOffset;\n\n      return this.moveAnchorOffsetTo(anchorOffset).moveFocusOffsetTo(focusOffset);\n    }\n\n    /**\n     * Move the focus point to the anchor point.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveToAnchor',\n    value: function moveToAnchor() {\n      return this.moveFocusTo(this.anchorKey, this.anchorOffset);\n    }\n\n    /**\n     * Move the anchor point to the focus point.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveToFocus',\n    value: function moveToFocus() {\n      return this.moveAnchorTo(this.focusKey, this.focusOffset);\n    }\n\n    /**\n     * Move the selection's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorToStartOf',\n    value: function moveAnchorToStartOf(node) {\n      node = getFirst(node);\n      return this.moveAnchorTo(node.key, 0);\n    }\n\n    /**\n     * Move the selection's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorToEndOf',\n    value: function moveAnchorToEndOf(node) {\n      node = getLast(node);\n      return this.moveAnchorTo(node.key, node.length);\n    }\n\n    /**\n     * Move the selection's focus point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusToStartOf',\n    value: function moveFocusToStartOf(node) {\n      node = getFirst(node);\n      return this.moveFocusTo(node.key, 0);\n    }\n\n    /**\n     * Move the selection's focus point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusToEndOf',\n    value: function moveFocusToEndOf(node) {\n      node = getLast(node);\n      return this.moveFocusTo(node.key, node.length);\n    }\n\n    /**\n     * Move to the entire range of `start` and `end` nodes.\n     *\n     * @param {Node} start\n     * @param {Node} end (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveToRangeOf',\n    value: function moveToRangeOf(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n\n      return this.moveAnchorToStartOf(start).moveFocusToEndOf(end);\n    }\n\n    /**\n     * Normalize the selection, relative to a `node`, ensuring that the anchor\n     * and focus nodes of the selection always refer to leaf text nodes.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      var selection = this;\n      var anchorKey = selection.anchorKey,\n          anchorOffset = selection.anchorOffset,\n          focusKey = selection.focusKey,\n          focusOffset = selection.focusOffset,\n          isBackward = selection.isBackward;\n\n      // If the selection isn't formed yet or is malformed, ensure that it is\n      // properly zeroed out.\n\n      if (anchorKey == null || focusKey == null || !node.hasDescendant(anchorKey) || !node.hasDescendant(focusKey)) {\n        return selection.merge({\n          anchorKey: null,\n          anchorOffset: 0,\n          focusKey: null,\n          focusOffset: 0,\n          isBackward: false\n        });\n      }\n\n      // Get the anchor and focus nodes.\n      var anchorNode = node.getDescendant(anchorKey);\n      var focusNode = node.getDescendant(focusKey);\n\n      // If the anchor node isn't a text node, match it to one.\n      if (anchorNode.kind != 'text') {\n        (0, _warn2.default)('The selection anchor was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:', anchorNode);\n        var anchorText = anchorNode.getTextAtOffset(anchorOffset);\n        var offset = anchorNode.getOffset(anchorText.key);\n        anchorOffset = anchorOffset - offset;\n        anchorNode = anchorText;\n      }\n\n      // If the focus node isn't a text node, match it to one.\n      if (focusNode.kind != 'text') {\n        (0, _warn2.default)('The selection focus was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:', focusNode);\n        var focusText = focusNode.getTextAtOffset(focusOffset);\n        var _offset = focusNode.getOffset(focusText.key);\n        focusOffset = focusOffset - _offset;\n        focusNode = focusText;\n      }\n\n      // If `isBackward` is not set, derive it.\n      if (isBackward == null) {\n        if (anchorNode.key === focusNode.key) {\n          isBackward = anchorOffset > focusOffset;\n        } else {\n          isBackward = !node.areDescendantsSorted(anchorNode.key, focusNode.key);\n        }\n      }\n\n      // Merge in any updated properties.\n      return selection.merge({\n        anchorKey: anchorNode.key,\n        anchorOffset: anchorOffset,\n        focusKey: focusNode.key,\n        focusOffset: focusOffset,\n        isBackward: isBackward\n      });\n    }\n\n    /**\n     * Unset the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'unset',\n    value: function unset() {\n      (0, _warn2.default)('The `Selection.unset` method is deprecated, please switch to using `Selection.deselect` instead.');\n      return this.deselect();\n    }\n\n    /**\n     * Move the selection forward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveForward',\n    value: function moveForward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveForward(n)` method is deprecated, please switch to using `Selection.move(n)` instead.');\n      return this.move(n);\n    }\n\n    /**\n     * Move the selection backward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveBackward',\n    value: function moveBackward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveBackward(n)` method is deprecated, please switch to using `Selection.move(-n)` (with a negative number) instead.');\n      return this.move(0 - n);\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorOffset',\n    value: function moveAnchorOffset() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveAnchorOffset(n)` method is deprecated, please switch to using `Selection.moveAnchor(n)` instead.');\n      return this.moveAnchor(n);\n    }\n\n    /**\n     * Move the focus offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusOffset',\n    value: function moveFocusOffset() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveFocusOffset(n)` method is deprecated, please switch to using `Selection.moveFocus(n)` instead.');\n      return this.moveFocus(n);\n    }\n\n    /**\n     * Move the start offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveStartOffset',\n    value: function moveStartOffset() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveStartOffset(n)` method is deprecated, please switch to using `Selection.moveStart(n)` instead.');\n      return this.moveStart(n);\n    }\n\n    /**\n     * Move the focus offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveEndOffset',\n    value: function moveEndOffset() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveEndOffset(n)` method is deprecated, please switch to using `Selection.moveEnd(n)` instead.');\n      return this.moveEnd(n);\n    }\n\n    /**\n     * Extend the focus point forward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'extendForward',\n    value: function extendForward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.extendForward(n)` method is deprecated, please switch to using `Selection.extend(n)` instead.');\n      return this.extend(n);\n    }\n\n    /**\n     * Extend the focus point backward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'extendBackward',\n    value: function extendBackward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.extendBackward(n)` method is deprecated, please switch to using `Selection.extend(-n)` (with a negative number) instead.');\n      return this.extend(0 - n);\n    }\n\n    /**\n     * Move the selection to `anchorOffset` and `focusOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @param {Number} focusOffset (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveToOffsets',\n    value: function moveToOffsets(anchorOffset) {\n      var focusOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : anchorOffset;\n\n      (0, _warn2.default)('The `Selection.moveToOffsets` method is deprecated, please switch to using `Selection.moveOffsetsTo` instead.');\n      return this.moveOffsetsTo(anchorOffset, focusOffset);\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'selection';\n    }\n\n    /**\n     * Check whether the selection is blurred.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlurred',\n    get: function get() {\n      return !this.isFocused;\n    }\n\n    /**\n     * Check whether the selection is collapsed.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCollapsed',\n    get: function get() {\n      return this.anchorKey == this.focusKey && this.anchorOffset == this.focusOffset;\n    }\n\n    /**\n     * Check whether the selection is expanded.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get() {\n      return !this.isCollapsed;\n    }\n\n    /**\n     * Check whether the selection is forward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get() {\n      return this.isBackward == null ? null : !this.isBackward;\n    }\n\n    /**\n     * Check whether the selection's keys are set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSet',\n    get: function get() {\n      return this.anchorKey != null && this.focusKey != null;\n    }\n\n    /**\n     * Check whether the selection's keys are not set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get() {\n      return !this.isSet;\n    }\n\n    /**\n     * Get the start key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startKey',\n    get: function get() {\n      return this.isBackward ? this.focusKey : this.anchorKey;\n    }\n\n    /**\n     * Get the start offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startOffset',\n    get: function get() {\n      return this.isBackward ? this.focusOffset : this.anchorOffset;\n    }\n\n    /**\n     * Get the end key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endKey',\n    get: function get() {\n      return this.isBackward ? this.anchorKey : this.focusKey;\n    }\n\n    /**\n     * Get the end offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endOffset',\n    get: function get() {\n      return this.isBackward ? this.anchorOffset : this.focusOffset;\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Selection` with `properties`.\n     *\n     * @param {Object|Selection} properties\n     * @return {Selection}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Selection.isSelection(properties)) return properties;\n      return new Selection(properties);\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate Selection or not\n     *\n     * @param {*} maybeSelection\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSelection',\n    value: function isSelection(maybeSelection) {\n      return !!(maybeSelection && maybeSelection[_modelTypes2.default.SELECTION]);\n    }\n  }]);\n\n  return Selection;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Pseduo-symbol that shows this is a Slate Selection\n */\n\nSelection.prototype[_modelTypes2.default.SELECTION] = true;\n\n/**\n * Mix in some \"move\" convenience methods.\n */\n\nvar MOVE_METHODS = [['move', ''], ['move', 'To'], ['move', 'ToStartOf'], ['move', 'ToEndOf']];\n\nMOVE_METHODS.forEach(function (_ref2) {\n  var _ref3 = _slicedToArray(_ref2, 2),\n      p = _ref3[0],\n      s = _ref3[1];\n\n  Selection.prototype['' + p + s] = function () {\n    var _ref4;\n\n    return (_ref4 = this[p + 'Anchor' + s].apply(this, arguments))[p + 'Focus' + s].apply(_ref4, arguments);\n  };\n});\n\n/**\n * Mix in the \"start\", \"end\" and \"edge\" convenience methods.\n */\n\nvar EDGE_METHODS = [['has', 'AtStartOf', true], ['has', 'AtEndOf', true], ['has', 'Between', true], ['has', 'In', true], ['collapseTo', ''], ['move', ''], ['moveTo', ''], ['move', 'To'], ['move', 'OffsetTo']];\n\nEDGE_METHODS.forEach(function (_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 3),\n      p = _ref6[0],\n      s = _ref6[1],\n      hasEdge = _ref6[2];\n\n  var anchor = p + 'Anchor' + s;\n  var focus = p + 'Focus' + s;\n\n  Selection.prototype[p + 'Start' + s] = function () {\n    return this.isBackward ? this[focus].apply(this, arguments) : this[anchor].apply(this, arguments);\n  };\n\n  Selection.prototype[p + 'End' + s] = function () {\n    return this.isBackward ? this[anchor].apply(this, arguments) : this[focus].apply(this, arguments);\n  };\n\n  if (hasEdge) {\n    Selection.prototype[p + 'Edge' + s] = function () {\n      return this[anchor].apply(this, arguments) || this[focus].apply(this, arguments);\n    };\n  }\n});\n\n/**\n * Mix in some aliases for convenience / parallelism with the browser APIs.\n */\n\nvar ALIAS_METHODS = [['collapseTo', 'moveTo'], ['collapseToAnchor', 'moveToAnchor'], ['collapseToFocus', 'moveToFocus'], ['collapseToStart', 'moveToStart'], ['collapseToEnd', 'moveToEnd'], ['collapseToStartOf', 'moveToStartOf'], ['collapseToEndOf', 'moveToEndOf'], ['extend', 'moveFocus'], ['extendTo', 'moveFocusTo'], ['extendToStartOf', 'moveFocusToStartOf'], ['extendToEndOf', 'moveFocusToEndOf']];\n\nALIAS_METHODS.forEach(function (_ref7) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n      alias = _ref8[0],\n      method = _ref8[1];\n\n  Selection.prototype[alias] = function () {\n    return this[method].apply(this, arguments);\n  };\n});\n\n/**\n * Get the first text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getFirst(node) {\n  return node.kind == 'text' ? node : node.getFirstText();\n}\n\n/**\n * Get the last text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getLast(node) {\n  return node.kind == 'text' ? node : node.getLastText();\n}\n\n/**\n * Export.\n *\n * @type {Selection}\n */\n\nexports.default = Selection;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/selection.js\n// module id = ./node_modules/slate/lib/models/selection.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _core = require('../plugins/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _schema2 = require('./schema');\n\nvar _schema3 = _interopRequireDefault(_schema2);\n\nvar _state = require('./state');\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:stack');\n\n/**\n * Methods that are triggered on events and can change the state.\n *\n * @type {Array}\n */\n\nvar EVENT_HANDLER_METHODS = ['onBeforeInput', 'onBlur', 'onFocus', 'onCopy', 'onCut', 'onDrop', 'onKeyDown', 'onPaste', 'onSelect'];\n\n/**\n * Methods that accumulate an updated state.\n *\n * @type {Array}\n */\n\nvar STATE_ACCUMULATOR_METHODS = ['onBeforeChange', 'onChange'];\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  plugins: [],\n  schema: new _schema3.default()\n};\n\n/**\n * Stack.\n *\n * @type {Stack}\n */\n\nvar Stack = function (_ref) {\n  _inherits(Stack, _ref);\n\n  function Stack() {\n    var _ref2;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Stack);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Stack.__proto__ || Object.getPrototypeOf(Stack)).call.apply(_ref2, [this].concat(args))), _this), _this.render = function (state, editor, props) {\n      debug('render');\n      var plugins = _this.plugins.slice().reverse();\n      var children = void 0;\n\n      for (var i = 0; i < plugins.length; i++) {\n        var plugin = plugins[i];\n        if (!plugin.render) continue;\n        children = plugin.render(props, state, editor);\n        props.children = children;\n      }\n\n      return children;\n    }, _this.renderPortal = function (state, editor) {\n      debug('renderPortal');\n      var portals = [];\n\n      for (var i = 0; i < _this.plugins.length; i++) {\n        var plugin = _this.plugins[i];\n        if (!plugin.renderPortal) continue;\n        var portal = plugin.renderPortal(state, editor);\n        if (portal == null) continue;\n        portals.push(portal);\n      }\n\n      return portals;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Stack, [{\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'stack';\n    }\n\n    /**\n     * Invoke `render` on all of the plugins in reverse, building up a tree of\n     * higher-order components.\n     *\n     * @param {State} state\n     * @param {Editor} editor\n     * @param {Object} children\n     * @param {Object} props\n     * @return {Component}\n     */\n\n    /**\n     * Invoke `renderPortal` on all of the plugins, building a list of portals.\n     *\n     * @param {State} state\n     * @param {Editor} editor\n     * @return {Array}\n     */\n\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Constructor.\n     *\n     * @param {Object} properties\n     *   @property {Array} plugins\n     *   @property {Schema|Object} schema\n     *   @property {Function} ...handlers\n     */\n\n    value: function create(properties) {\n      var plugins = resolvePlugins(properties);\n      var schema = resolveSchema(plugins);\n      return new Stack({ plugins: plugins, schema: schema });\n    }\n  }]);\n\n  return Stack;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Mix in the event handler methods.\n *\n * @param {State} state\n * @param {Editor} editor\n * @param {Mixed} ...args\n * @return {State|Null}\n */\n\nvar _loop = function _loop(i) {\n  var method = EVENT_HANDLER_METHODS[i];\n  Stack.prototype[method] = function (state, editor) {\n    debug(method);\n\n    for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    for (var k = 0; k < this.plugins.length; k++) {\n      var plugin = this.plugins[k];\n      if (!plugin[method]) continue;\n      var next = plugin[method].apply(plugin, args.concat([state, editor]));\n      if (next == null) continue;\n      assertState(next);\n      return next;\n    }\n\n    return state;\n  };\n};\n\nfor (var i = 0; i < EVENT_HANDLER_METHODS.length; i++) {\n  _loop(i);\n}\n\n/**\n * Mix in the state accumulator methods.\n *\n * @param {State} state\n * @param {Editor} editor\n * @param {Mixed} ...args\n * @return {State|Null}\n */\n\nvar _loop2 = function _loop2(i) {\n  var method = STATE_ACCUMULATOR_METHODS[i];\n  Stack.prototype[method] = function (state, editor) {\n    debug(method);\n\n    if (method == 'onChange') {\n      state = this.onBeforeChange(state, editor);\n    }\n\n    for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      args[_key3 - 2] = arguments[_key3];\n    }\n\n    for (var k = 0; k < this.plugins.length; k++) {\n      var plugin = this.plugins[k];\n      if (!plugin[method]) continue;\n      var next = plugin[method].apply(plugin, args.concat([state, editor]));\n      if (next == null) continue;\n      assertState(next);\n      state = next;\n    }\n\n    return state;\n  };\n};\n\nfor (var i = 0; i < STATE_ACCUMULATOR_METHODS.length; i++) {\n  _loop2(i);\n}\n\n/**\n * Assert that a `value` is a state object.\n *\n * @param {Mixed} value\n */\n\nfunction assertState(value) {\n  if (_state2.default.isState(value)) return;\n  throw new Error('A plugin returned an unexpected state value: ' + value);\n}\n\n/**\n * Resolve a schema from a set of `plugins`.\n *\n * @param {Array} plugins\n * @return {Schema}\n */\n\nfunction resolveSchema(plugins) {\n  var rules = [];\n\n  for (var i = 0; i < plugins.length; i++) {\n    var plugin = plugins[i];\n    if (plugin.schema == null) continue;\n    var _schema = _schema3.default.create(plugin.schema);\n    rules = rules.concat(_schema.rules);\n  }\n\n  var schema = _schema3.default.create({ rules: rules });\n  return schema;\n}\n\n/**\n * Resolve an array of plugins from `properties`.\n *\n * In addition to the plugins provided in `properties.plugins`, this will\n * create two other plugins:\n *\n * - A plugin made from the top-level `properties` themselves, which are\n * placed at the beginning of the stack. That way, you can add a `onKeyDown`\n * handler, and it will override all of the existing plugins.\n *\n * - A \"core\" functionality plugin that handles the most basic events in Slate,\n * like deleting characters, splitting blocks, etc.\n *\n * @param {Object} props\n * @return {Array}\n */\n\nfunction resolvePlugins(props) {\n  var _props$plugins = props.plugins,\n      plugins = _props$plugins === undefined ? [] : _props$plugins,\n      overridePlugin = _objectWithoutProperties(props, ['plugins']);\n\n  var corePlugin = (0, _core2.default)(props);\n  return [overridePlugin].concat(_toConsumableArray(plugins), [corePlugin]);\n}\n\n/**\n * Export.\n *\n * @type {Stack}\n */\n\nexports.default = Stack;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/stack.js\n// module id = ./node_modules/slate/lib/models/stack.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _document = require('./document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _core = require('../schemas/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _selection = require('./selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _transform = require('./transform');\n\nvar _transform2 = _interopRequireDefault(_transform);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * History.\n *\n * @type {History}\n */\n\nvar History = new _immutable.Record({\n  undos: new _immutable.Stack(),\n  redos: new _immutable.Stack()\n});\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  document: new _document2.default(),\n  selection: new _selection2.default(),\n  history: new History(),\n  data: new _immutable.Map(),\n  isNative: false\n};\n\n/**\n * State.\n *\n * @type {State}\n */\n\nvar State = function (_ref) {\n  _inherits(State, _ref);\n\n  function State() {\n    _classCallCheck(this, State);\n\n    return _possibleConstructorReturn(this, (State.__proto__ || Object.getPrototypeOf(State)).apply(this, arguments));\n  }\n\n  _createClass(State, [{\n    key: 'transform',\n\n\n    /**\n     * Return a new `Transform` with the current state as a starting point.\n     *\n     * @param {Object} properties\n     * @return {Transform}\n     */\n\n    value: function transform() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var state = this;\n      return new _transform2.default(_extends({}, properties, {\n        state: state\n      }));\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'state';\n    }\n\n    /**\n     * Are there undoable events?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasUndos',\n    get: function get() {\n      return this.history.undos.size > 0;\n    }\n\n    /**\n     * Are there redoable events?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasRedos',\n    get: function get() {\n      return this.history.redos.size > 0;\n    }\n\n    /**\n     * Is the current selection blurred?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlurred',\n    get: function get() {\n      return this.selection.isBlurred;\n    }\n\n    /**\n     * Is the current selection focused?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isFocused',\n    get: function get() {\n      return this.selection.isFocused;\n    }\n\n    /**\n     * Is the current selection collapsed?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCollapsed',\n    get: function get() {\n      return this.selection.isCollapsed;\n    }\n\n    /**\n     * Is the current selection expanded?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get() {\n      return this.selection.isExpanded;\n    }\n\n    /**\n     * Is the current selection backward?\n     *\n     * @return {Boolean} isBackward\n     */\n\n  }, {\n    key: 'isBackward',\n    get: function get() {\n      return this.selection.isBackward;\n    }\n\n    /**\n     * Is the current selection forward?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get() {\n      return this.selection.isForward;\n    }\n\n    /**\n     * Get the current start key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startKey',\n    get: function get() {\n      return this.selection.startKey;\n    }\n\n    /**\n     * Get the current end key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endKey',\n    get: function get() {\n      return this.selection.endKey;\n    }\n\n    /**\n     * Get the current start offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startOffset',\n    get: function get() {\n      return this.selection.startOffset;\n    }\n\n    /**\n     * Get the current end offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endOffset',\n    get: function get() {\n      return this.selection.endOffset;\n    }\n\n    /**\n     * Get the current anchor key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'anchorKey',\n    get: function get() {\n      return this.selection.anchorKey;\n    }\n\n    /**\n     * Get the current focus key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'focusKey',\n    get: function get() {\n      return this.selection.focusKey;\n    }\n\n    /**\n     * Get the current anchor offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'anchorOffset',\n    get: function get() {\n      return this.selection.anchorOffset;\n    }\n\n    /**\n     * Get the current focus offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'focusOffset',\n    get: function get() {\n      return this.selection.focusOffset;\n    }\n\n    /**\n     * Get the current start text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'startBlock',\n    get: function get() {\n      return this.document.getClosestBlock(this.selection.startKey);\n    }\n\n    /**\n     * Get the current end text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'endBlock',\n    get: function get() {\n      return this.document.getClosestBlock(this.selection.endKey);\n    }\n\n    /**\n     * Get the current anchor text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'anchorBlock',\n    get: function get() {\n      return this.document.getClosestBlock(this.selection.anchorKey);\n    }\n\n    /**\n     * Get the current focus text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'focusBlock',\n    get: function get() {\n      return this.document.getClosestBlock(this.selection.focusKey);\n    }\n\n    /**\n     * Get the current start text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'startInline',\n    get: function get() {\n      return this.document.getClosestInline(this.selection.startKey);\n    }\n\n    /**\n     * Get the current end text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'endInline',\n    get: function get() {\n      return this.document.getClosestInline(this.selection.endKey);\n    }\n\n    /**\n     * Get the current anchor text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'anchorInline',\n    get: function get() {\n      return this.document.getClosestInline(this.selection.anchorKey);\n    }\n\n    /**\n     * Get the current focus text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'focusInline',\n    get: function get() {\n      return this.document.getClosestInline(this.selection.focusKey);\n    }\n\n    /**\n     * Get the current start text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'startText',\n    get: function get() {\n      return this.document.getDescendant(this.selection.startKey);\n    }\n\n    /**\n     * Get the current end node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'endText',\n    get: function get() {\n      return this.document.getDescendant(this.selection.endKey);\n    }\n\n    /**\n     * Get the current anchor node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'anchorText',\n    get: function get() {\n      return this.document.getDescendant(this.selection.anchorKey);\n    }\n\n    /**\n     * Get the current focus node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'focusText',\n    get: function get() {\n      return this.document.getDescendant(this.selection.focusKey);\n    }\n\n    /**\n     * Get the characters in the current selection.\n     *\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'characters',\n    get: function get() {\n      return this.document.getCharactersAtRange(this.selection);\n    }\n\n    /**\n     * Get the marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'marks',\n    get: function get() {\n      return this.selection.isUnset ? new _immutable.Set() : this.selection.marks || this.document.getMarksAtRange(this.selection);\n    }\n\n    /**\n     * Get the block nodes in the current selection.\n     *\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'blocks',\n    get: function get() {\n      return this.selection.isUnset ? new _immutable.List() : this.document.getBlocksAtRange(this.selection);\n    }\n\n    /**\n     * Get the fragment of the current selection.\n     *\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fragment',\n    get: function get() {\n      return this.selection.isUnset ? _document2.default.create() : this.document.getFragmentAtRange(this.selection);\n    }\n\n    /**\n     * Get the inline nodes in the current selection.\n     *\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'inlines',\n    get: function get() {\n      return this.selection.isUnset ? new _immutable.List() : this.document.getInlinesAtRange(this.selection);\n    }\n\n    /**\n     * Get the text nodes in the current selection.\n     *\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'texts',\n    get: function get() {\n      return this.selection.isUnset ? new _immutable.List() : this.document.getTextsAtRange(this.selection);\n    }\n\n    /**\n     * Check whether the selection is empty.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      var startOffset = this.startOffset,\n          endOffset = this.endOffset;\n\n\n      if (this.isCollapsed) {\n        return true;\n      }\n\n      if (endOffset != 0 && startOffset != 0) {\n        return false;\n      }\n\n      return this.fragment.text.length == 0;\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `State` with `properties`.\n     *\n     * @param {Object|State} properties\n     * @param {Object} options\n     *   @property {Boolean} normalize\n     * @return {State}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (State.isState(properties)) return properties;\n\n      var document = _document2.default.create(properties.document);\n      var selection = _selection2.default.create(properties.selection);\n      var data = new _immutable.Map();\n\n      if (selection.isUnset) {\n        var text = document.getFirstText();\n        selection = selection.collapseToStartOf(text);\n      }\n\n      // Set default value for `data`.\n      if (options.plugins) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = options.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var plugin = _step.value;\n\n            if (plugin.data) data = data.merge(plugin.data);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      // Then add data provided in `properties`.\n      if (properties.data) data = data.merge(properties.data);\n\n      var state = new State({ document: document, selection: selection, data: data });\n\n      return options.normalize === false ? state : state.transform().normalize(_core2.default).apply({ save: false });\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate State or not\n     *\n     * @param {*} maybeState\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isState',\n    value: function isState(maybeState) {\n      return !!(maybeState && maybeState[_modelTypes2.default.STATE]);\n    }\n  }]);\n\n  return State;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Pseduo-symbol that shows this is a Slate State\n */\n\nState.prototype[_modelTypes2.default.STATE] = true;\n\n/**\n * Export.\n */\n\nexports.default = State;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/state.js\n// module id = ./node_modules/slate/lib/models/state.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _character = require('./character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _mark = require('./mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _range = require('./range');\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _modelTypes = require('../constants/model-types');\n\nvar _modelTypes2 = _interopRequireDefault(_modelTypes);\n\nvar _memoize = require('../utils/memoize');\n\nvar _memoize2 = _interopRequireDefault(_memoize);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  characters: new _immutable.List(),\n  key: null\n};\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nvar Text = function (_ref) {\n  _inherits(Text, _ref);\n\n  function Text() {\n    _classCallCheck(this, Text);\n\n    return _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));\n  }\n\n  _createClass(Text, [{\n    key: 'addMark',\n\n\n    /**\n     * Add a `mark` at `index` and `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n    value: function addMark(index, length, mark) {\n      var characters = this.characters.map(function (char, i) {\n        if (i < index) return char;\n        if (i >= index + length) return char;\n        var _char = char,\n            marks = _char.marks;\n\n        marks = marks.add(mark);\n        char = char.set('marks', marks);\n        return char;\n      });\n\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Derive a set of decorated characters with `decorators`.\n     *\n     * @param {Array} decorators\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'getDecorations',\n    value: function getDecorations(decorators) {\n      var node = this;\n      var characters = node.characters;\n\n      if (characters.size == 0) return characters;\n\n      for (var i = 0; i < decorators.length; i++) {\n        var decorator = decorators[i];\n        var decorateds = decorator(node);\n        characters = characters.merge(decorateds);\n      }\n\n      return characters;\n    }\n\n    /**\n     * Get the decorations for the node from a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getDecorators',\n    value: function getDecorators(schema) {\n      return schema.__getDecorators(this);\n    }\n\n    /**\n     * Get all of the marks on the text.\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarks',\n    value: function getMarks() {\n      var array = this.getMarksAsArray();\n      return new _immutable.OrderedSet(array);\n    }\n\n    /**\n     * Get all of the marks on the text as an array\n     *\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getMarksAsArray',\n    value: function getMarksAsArray() {\n      return this.characters.reduce(function (array, char) {\n        return array.concat(char.marks.toArray());\n      }, []);\n    }\n\n    /**\n     * Get the marks on the text at `index`.\n     *\n     * @param {Number} index\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarksAtIndex',\n    value: function getMarksAtIndex(index) {\n      if (index == 0) return _mark2.default.createSet();\n      var characters = this.characters;\n\n      var char = characters.get(index - 1);\n      if (!char) return _mark2.default.createSet();\n      return char.marks;\n    }\n\n    /**\n     * Get a node by `key`, to parallel other nodes.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode(key) {\n      return this.key == key ? this : null;\n    }\n\n    /**\n     * Derive the ranges for a list of `characters`.\n     *\n     * @param {Array|Void} decorators (optional)\n     * @return {List<Range>}\n     */\n\n  }, {\n    key: 'getRanges',\n    value: function getRanges() {\n      var decorators = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      var characters = this.getDecorations(decorators);\n      var ranges = [];\n\n      // PERF: cache previous values for faster lookup.\n      var prevChar = void 0;\n      var prevRange = void 0;\n\n      // If there are no characters, return one empty range.\n      if (characters.size == 0) {\n        ranges.push({});\n      }\n\n      // Otherwise, loop the characters and build the ranges...\n      else {\n          characters.forEach(function (char, i) {\n            var marks = char.marks,\n                text = char.text;\n\n            // The first one can always just be created.\n\n            if (i == 0) {\n              prevChar = char;\n              prevRange = { text: text, marks: marks };\n              ranges.push(prevRange);\n              return;\n            }\n\n            // Otherwise, compare the current and previous marks.\n            var prevMarks = prevChar.marks;\n            var isSame = (0, _immutable.is)(marks, prevMarks);\n\n            // If the marks are the same, add the text to the previous range.\n            if (isSame) {\n              prevChar = char;\n              prevRange.text += text;\n              return;\n            }\n\n            // Otherwise, create a new range.\n            prevChar = char;\n            prevRange = { text: text, marks: marks };\n            ranges.push(prevRange);\n          }, []);\n        }\n\n      // PERF: convert the ranges to immutable objects after iterating.\n      ranges = new _immutable.List(ranges.map(function (object) {\n        return new _range2.default(object);\n      }));\n\n      // Return the ranges.\n      return ranges;\n    }\n\n    /**\n     * Check if the node has a node by `key`, to parallel other nodes.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode(key) {\n      return !!this.getNode(key);\n    }\n\n    /**\n     * Insert `text` at `index`.\n     *\n     * @param {Numbder} index\n     * @param {String} text\n     * @param {String} marks (optional)\n     * @return {Text}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(index, text, marks) {\n      marks = marks || this.getMarksAtIndex(index);\n      var characters = this.characters;\n\n      var chars = _character2.default.createListFromText(text, marks);\n\n      characters = characters.slice(0, index).concat(chars).concat(characters.slice(index));\n\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Regenerate the node's key.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'regenerateKey',\n    value: function regenerateKey() {\n      var key = (0, _generateKey2.default)();\n      return this.set('key', key);\n    }\n\n    /**\n     * Remove a `mark` at `index` and `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(index, length, mark) {\n      var characters = this.characters.map(function (char, i) {\n        if (i < index) return char;\n        if (i >= index + length) return char;\n        var _char2 = char,\n            marks = _char2.marks;\n\n        marks = marks.remove(mark);\n        char = char.set('marks', marks);\n        return char;\n      });\n\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Remove text from the text node at `index` for `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(index, length) {\n      var characters = this.characters;\n\n      var start = index;\n      var end = index + length;\n      characters = characters.filterNot(function (char, i) {\n        return start <= i && i < end;\n      });\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Update a `mark` at `index` and `length` with `properties`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @param {Mark} newMark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'updateMark',\n    value: function updateMark(index, length, mark, newMark) {\n      var characters = this.characters.map(function (char, i) {\n        if (i < index) return char;\n        if (i >= index + length) return char;\n        var _char3 = char,\n            marks = _char3.marks;\n\n        if (!marks.has(mark)) return char;\n        marks = marks.remove(mark);\n        marks = marks.add(newMark);\n        char = char.set('marks', marks);\n        return char;\n      });\n\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Validate the text node against a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Object|Void}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(schema) {\n      return schema.__validate(this);\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'text';\n    }\n\n    /**\n     * Is the node empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the length of the concatenated text of the node.\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.text.length;\n    }\n\n    /**\n     * Get the concatenated text of the node.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this.characters.reduce(function (string, char) {\n        return string + char.text;\n      }, '');\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Text` with `properties`.\n     *\n     * @param {Object|Text} properties\n     * @return {Text}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Text.isText(properties)) return properties;\n      properties.key = properties.key || (0, _generateKey2.default)();\n      properties.characters = _character2.default.createList(properties.characters);\n      return new Text(properties);\n    }\n\n    /**\n     * Create a new `Text` from a string\n     *\n     * @param {String} text\n     * @param {Set<Mark>} marks (optional)\n     * @return {Text}\n     */\n\n  }, {\n    key: 'createFromString',\n    value: function createFromString(text) {\n      var marks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _immutable.Set)();\n\n      return Text.createFromRanges([_range2.default.create({ text: text, marks: marks })]);\n    }\n\n    /**\n     * Create a new `Text` from a list of ranges\n     *\n     * @param {List<Range>|Array<Range>} ranges\n     * @return {Text}\n     */\n\n  }, {\n    key: 'createFromRanges',\n    value: function createFromRanges(ranges) {\n      return Text.create({\n        characters: ranges.reduce(function (characters, range) {\n          range = _range2.default.create(range);\n          return characters.concat(range.getCharacters());\n        }, _character2.default.createList())\n      });\n    }\n\n    /**\n     * Create a list of `Texts` from an array.\n     *\n     * @param {Array} elements\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.List.isList(elements)) return elements;\n      return new _immutable.List(elements.map(Text.create));\n    }\n\n    /**\n     * Determines if the passed in paramter is a Slate Text or not\n     *\n     * @param {*} maybeText\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isText',\n    value: function isText(maybeText) {\n      return !!(maybeText && maybeText[_modelTypes2.default.TEXT]);\n    }\n  }]);\n\n  return Text;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Pseudo-symbol that shows this is a Slate Text\n */\n\nText.prototype[_modelTypes2.default.TEXT] = true;\n\n/**\n * Memoize read methods.\n */\n\n(0, _memoize2.default)(Text.prototype, ['getMarks', 'getMarksAsArray'], {\n  takesArguments: false\n});\n\n(0, _memoize2.default)(Text.prototype, ['getDecorations', 'getDecorators', 'getMarksAtIndex', 'getRanges', 'validate'], {\n  takesArguments: true\n});\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexports.default = Text;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/text.js\n// module id = ./node_modules/slate/lib/models/text.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _transforms = require('../transforms');\n\nvar _transforms2 = _interopRequireDefault(_transforms);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:transform');\n\n/**\n * Transform.\n *\n * @type {Transform}\n */\n\nvar Transform = function () {\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} properties\n   *   @property {State} state\n   */\n\n  function Transform(properties) {\n    _classCallCheck(this, Transform);\n\n    var state = properties.state;\n\n    this.state = state;\n    this.operations = [];\n  }\n\n  /**\n   * Get the kind.\n   *\n   * @return {String}\n   */\n\n  _createClass(Transform, [{\n    key: 'apply',\n\n\n    /**\n     * Apply the transform and return the new state.\n     *\n     * @param {Object} options\n     *   @property {Boolean} isNative\n     *   @property {Boolean} merge\n     *   @property {Boolean} save\n     * @return {State}\n     */\n\n    value: function apply() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var transform = this;\n      var merge = options.merge,\n          save = options.save,\n          _options$isNative = options.isNative,\n          isNative = _options$isNative === undefined ? false : _options$isNative;\n\n      // Ensure that the selection is normalized.\n\n      transform.normalizeSelection();\n\n      var state = transform.state,\n          operations = transform.operations;\n      var history = state.history;\n      var undos = history.undos;\n\n      var previous = undos.peek();\n\n      // If there are no operations, abort early.\n      if (!operations.length) return state;\n\n      // If there's a previous save point, determine if the new operations should\n      // be merged into the previous ones.\n      if (previous && merge == null) {\n        merge = isOnlySelections(operations) || isContiguousInserts(operations, previous) || isContiguousRemoves(operations, previous);\n      }\n\n      // If the save flag isn't set, determine whether we should save.\n      if (save == null) {\n        save = !isOnlySelections(operations);\n      }\n\n      // Save the new operations.\n      if (save) this.save({ merge: merge });\n\n      // Return the new state with the `isNative` flag set.\n      return this.state.set('isNative', !!isNative);\n    }\n  }, {\n    key: 'kind',\n    get: function get() {\n      return 'transform';\n    }\n  }]);\n\n  return Transform;\n}();\n\n/**\n * Add a transform method for each of the transforms.\n */\n\nObject.keys(_transforms2.default).forEach(function (type) {\n  Transform.prototype[type] = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    debug(type, { args: args });\n    _transforms2.default[type].apply(_transforms2.default, [this].concat(args));\n    return this;\n  };\n});\n\n/**\n * Check whether a list of `operations` only contains selection operations.\n *\n * @param {Array} operations\n * @return {Boolean}\n */\n\nfunction isOnlySelections(operations) {\n  return operations.every(function (op) {\n    return op.type == 'set_selection';\n  });\n}\n\n/**\n * Check whether a list of `operations` and a list of `previous` operations are\n * contiguous text insertions.\n *\n * @param {Array} operations\n * @param {Array} previous\n */\n\nfunction isContiguousInserts(operations, previous) {\n  var edits = operations.filter(function (op) {\n    return op.type != 'set_selection';\n  });\n  var prevEdits = previous.filter(function (op) {\n    return op.type != 'set_selection';\n  });\n  if (!edits.length || !prevEdits.length) return false;\n\n  var onlyInserts = edits.every(function (op) {\n    return op.type == 'insert_text';\n  });\n  var prevOnlyInserts = prevEdits.every(function (op) {\n    return op.type == 'insert_text';\n  });\n  if (!onlyInserts || !prevOnlyInserts) return false;\n\n  var first = edits[0];\n  var last = prevEdits[prevEdits.length - 1];\n  if (first.key != last.key) return false;\n  if (first.offset != last.offset + last.text.length) return false;\n\n  return true;\n}\n\n/**\n * Check whether a list of `operations` and a list of `previous` operations are\n * contiguous text removals.\n *\n * @param {Array} operations\n * @param {Array} previous\n */\n\nfunction isContiguousRemoves(operations, previous) {\n  var edits = operations.filter(function (op) {\n    return op.type != 'set_selection';\n  });\n  var prevEdits = previous.filter(function (op) {\n    return op.type != 'set_selection';\n  });\n  if (!edits.length || !prevEdits.length) return false;\n\n  var onlyRemoves = edits.every(function (op) {\n    return op.type == 'remove_text';\n  });\n  var prevOnlyRemoves = prevEdits.every(function (op) {\n    return op.type == 'remove_text';\n  });\n  if (!onlyRemoves || !prevOnlyRemoves) return false;\n\n  var first = edits[0];\n  var last = prevEdits[prevEdits.length - 1];\n  if (first.key != last.key) return false;\n  if (first.offset + first.length != last.offset) return false;\n\n  return true;\n}\n\n/**\n * Export.\n *\n * @type {Transform}\n */\n\nexports.default = Transform;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/models/transform.js\n// module id = ./node_modules/slate/lib/models/transform.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _content = require('../components/content');\n\nvar _content2 = _interopRequireDefault(_content);\n\nvar _character = require('../models/character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _getPoint = require('../utils/get-point');\n\nvar _getPoint2 = _interopRequireDefault(_getPoint);\n\nvar _placeholder = require('../components/placeholder');\n\nvar _placeholder2 = _interopRequireDefault(_placeholder);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nvar _findDomNode = require('../utils/find-dom-node');\n\nvar _findDomNode2 = _interopRequireDefault(_findDomNode);\n\nvar _environment = require('../constants/environment');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:core');\n\n/**\n * The default plugin.\n *\n * @param {Object} options\n *   @property {Element} placeholder\n *   @property {String} placeholderClassName\n *   @property {Object} placeholderStyle\n * @return {Object}\n */\n\nfunction Plugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var placeholder = options.placeholder,\n      placeholderClassName = options.placeholderClassName,\n      placeholderStyle = options.placeholderStyle;\n\n  /**\n   * On before change, enforce the editor's schema.\n   *\n   * @param {State} state\n   * @param {Editor} schema\n   * @return {State}\n   */\n\n  function onBeforeChange(state, editor) {\n    // Don't normalize with plugins schema when typing text in native mode\n    if (state.isNative) return state;\n\n    var schema = editor.getSchema();\n    var prevState = editor.getState();\n\n    // Since schema can only normalize the document, we avoid creating\n    // a transform and normalize the selection if the document is the same\n    if (prevState && state.document == prevState.document) return state;\n\n    var newState = state.transform().normalize(schema).apply({ merge: true });\n\n    debug('onBeforeChange');\n    return newState;\n  }\n\n  /**\n   * On before input, see if we can let the browser continue with it's native\n   * input behavior, to avoid a re-render for performance.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @param {Editor} editor\n   * @return {State}\n   */\n\n  function onBeforeInput(e, data, state, editor) {\n    var document = state.document,\n        startKey = state.startKey,\n        startBlock = state.startBlock,\n        startOffset = state.startOffset,\n        startInline = state.startInline,\n        startText = state.startText;\n\n    var pText = startBlock.getPreviousText(startKey);\n    var pInline = pText && startBlock.getClosestInline(pText.key);\n    var nText = startBlock.getNextText(startKey);\n    var nInline = nText && startBlock.getClosestInline(nText.key);\n\n    // Determine what the characters would be if natively inserted.\n    var schema = editor.getSchema();\n    var decorators = document.getDescendantDecorators(startKey, schema);\n    var initialChars = startText.getDecorations(decorators);\n    var prevChar = startOffset === 0 ? null : initialChars.get(startOffset - 1);\n    var nextChar = startOffset === initialChars.size ? null : initialChars.get(startOffset);\n    var char = _character2.default.create({\n      text: e.data,\n      // When cursor is at start of a range of marks, without preceding text,\n      // the native behavior is to insert inside the range of marks.\n      marks: prevChar && prevChar.marks || nextChar && nextChar.marks || []\n    });\n\n    var chars = initialChars.insert(startOffset, char);\n\n    var transform = state.transform();\n\n    // COMPAT: In iOS, when choosing from the predictive text suggestions, the\n    // native selection will be changed to span the existing word, so that the word\n    // is replaced. But the `select` event for this change doesn't fire until after\n    // the `beforeInput` event, even though the native selection is updated. So we\n    // need to manually adjust the selection to be in sync. (03/18/2017)\n    var window = (0, _getWindow2.default)(e.target);\n    var native = window.getSelection();\n    var anchorNode = native.anchorNode,\n        anchorOffset = native.anchorOffset,\n        focusNode = native.focusNode,\n        focusOffset = native.focusOffset;\n\n    var anchorPoint = (0, _getPoint2.default)(anchorNode, anchorOffset, state, editor);\n    var focusPoint = (0, _getPoint2.default)(focusNode, focusOffset, state, editor);\n    if (anchorPoint && focusPoint) {\n      var selection = state.selection;\n\n      if (selection.anchorKey !== anchorPoint.key || selection.anchorOffset !== anchorPoint.offset || selection.focusKey !== focusPoint.key || selection.focusOffset !== focusPoint.offset) {\n        transform = transform.select({\n          anchorKey: anchorPoint.key,\n          anchorOffset: anchorPoint.offset,\n          focusKey: focusPoint.key,\n          focusOffset: focusPoint.offset\n        });\n      }\n    }\n\n    // Determine what the characters should be, if not natively inserted.\n    var next = transform.insertText(e.data).apply();\n\n    var nextText = next.startText;\n    var nextChars = nextText.getDecorations(decorators);\n\n    // We do not have to re-render if the current selection is collapsed, the\n    // current node is not empty, there are no marks on the cursor, the cursor\n    // is not at the edge of an inline node, the cursor isn't at the starting\n    // edge of a text node after an inline node, and the natively inserted\n    // characters would be the same as the non-native.\n    var isNative =\n    // If the selection is expanded, we don't know what the edit will look\n    // like so we can't let it happen natively.\n    state.isCollapsed &&\n    // If the selection has marks, then we need to render it non-natively\n    // because we need to create the new marks as well.\n    state.selection.marks == null &&\n    // If the text node in question has no content, browsers might do weird\n    // things so we need to insert it normally instead.\n    state.startText.text != '' && (\n    // COMPAT: Browsers do weird things when typing at the edges of inline\n    // nodes, so we can't let them render natively. (?)\n    !startInline || !state.selection.isAtStartOf(startInline)) && (!startInline || !state.selection.isAtEndOf(startInline)) &&\n    // COMPAT: In Chrome & Safari, it isn't possible to have a selection at\n    // the starting edge of a text node after another inline node. It will\n    // have been automatically changed. So we can't render natively because\n    // the cursor isn't technique in the right spot. (2016/12/01)\n    !(pInline && !pInline.isVoid && startOffset == 0) && !(nInline && !nInline.isVoid && startOffset == startText.length) &&\n    // COMPAT: When inserting a Space character, Chrome will sometimes\n    // split the text node into two adjacent text nodes. See:\n    // https://github.com/ianstormtaylor/slate/issues/938\n    !(e.data === ' ' && _environment.IS_CHROME) &&\n    // If the\n    chars.equals(nextChars);\n\n    // Add the `isNative` flag directly, so we don't have to re-transform.\n    if (isNative) {\n      next = next.set('isNative', isNative);\n    }\n\n    // If not native, prevent default so that the DOM remains untouched.\n    if (!isNative) e.preventDefault();\n\n    debug('onBeforeInput', { data: data, isNative: isNative });\n    return next;\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onBlur(e, data, state) {\n    debug('onBlur', { data: data });\n    return state.transform().blur().apply();\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onCopy(e, data, state) {\n    debug('onCopy', data);\n    onCutOrCopy(e, data, state);\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @param {Editor} editor\n   * @return {State}\n   */\n\n  function onCut(e, data, state, editor) {\n    debug('onCut', data);\n    onCutOrCopy(e, data, state);\n    var window = (0, _getWindow2.default)(e.target);\n\n    // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n    window.requestAnimationFrame(function () {\n      var next = editor.getState().transform().delete().apply();\n\n      editor.onChange(next);\n    });\n  }\n\n  /**\n   * On cut or copy, create a fake selection so that we can add a Base 64\n   * encoded copy of the fragment to the HTML, to decode on future pastes.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onCutOrCopy(e, data, state) {\n    var window = (0, _getWindow2.default)(e.target);\n    var native = window.getSelection();\n    var endBlock = state.endBlock,\n        endInline = state.endInline;\n\n    var isVoidBlock = endBlock && endBlock.isVoid;\n    var isVoidInline = endInline && endInline.isVoid;\n    var isVoid = isVoidBlock || isVoidInline;\n\n    // If the selection is collapsed, and it isn't inside a void node, abort.\n    if (native.isCollapsed && !isVoid) return;\n\n    var fragment = data.fragment;\n\n    var encoded = _base2.default.serializeNode(fragment);\n    var range = native.getRangeAt(0);\n    var contents = range.cloneContents();\n    var attach = contents.childNodes[0];\n\n    // If the end node is a void node, we need to move the end of the range from\n    // the void node's spacer span, to the end of the void node's content.\n    if (isVoid) {\n      var _r = range.cloneRange();\n      var node = (0, _findDomNode2.default)(isVoidBlock ? endBlock : endInline);\n      _r.setEndAfter(node);\n      contents = _r.cloneContents();\n      attach = contents.childNodes[contents.childNodes.length - 1].firstChild;\n    }\n\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    var zws = [].slice.call(contents.querySelectorAll('[data-slate-zero-width]'));\n    zws.forEach(function (zw) {\n      return zw.parentNode.removeChild(zw);\n    });\n\n    // COMPAT: In Chrome and Safari, if the last element in the selection to\n    // copy has `contenteditable=\"false\"` the copy will fail, and nothing will\n    // be put in the clipboard. So we remove them all. (2017/05/04)\n    if (_environment.IS_CHROME || _environment.IS_SAFARI) {\n      var els = [].slice.call(contents.querySelectorAll('[contenteditable=\"false\"]'));\n      els.forEach(function (el) {\n        return el.removeAttribute('contenteditable');\n      });\n    }\n\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (attach.nodeType == 3) {\n      var span = window.document.createElement('span');\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n\n    attach.setAttribute('data-slate-fragment', encoded);\n\n    // Add the phony content to the DOM, and select it, so it will be copied.\n    var body = window.document.querySelector('body');\n    var div = window.document.createElement('div');\n    div.setAttribute('contenteditable', true);\n    div.style.position = 'absolute';\n    div.style.left = '-9999px';\n    div.appendChild(contents);\n    body.appendChild(div);\n\n    // COMPAT: In Firefox, trying to use the terser `native.selectAllChildren`\n    // throws an error, so we use the older `range` equivalent. (2016/06/21)\n    var r = window.document.createRange();\n    r.selectNodeContents(div);\n    native.removeAllRanges();\n    native.addRange(r);\n\n    // Revert to the previous selection right after copying.\n    window.requestAnimationFrame(function () {\n      body.removeChild(div);\n      native.removeAllRanges();\n      native.addRange(range);\n    });\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onDrop(e, data, state) {\n    debug('onDrop', { data: data });\n\n    switch (data.type) {\n      case 'text':\n      case 'html':\n        return onDropText(e, data, state);\n      case 'fragment':\n        return onDropFragment(e, data, state);\n      case 'node':\n        return onDropNode(e, data, state);\n    }\n  }\n\n  /**\n   * On drop node, insert the node wherever it is dropped.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onDropNode(e, data, state) {\n    debug('onDropNode', { data: data });\n\n    var selection = state.selection;\n    var node = data.node,\n        target = data.target,\n        isInternal = data.isInternal;\n\n    // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n\n    if (isInternal && selection.endKey == target.endKey && selection.endOffset < target.endOffset) {\n      target = target.move(selection.startKey == selection.endKey ? 0 - selection.endOffset - selection.startOffset : 0 - selection.endOffset);\n    }\n\n    var transform = state.transform();\n\n    if (isInternal) transform.delete();\n\n    return transform.select(target).insertBlock(node).removeNodeByKey(node.key).apply();\n  }\n\n  /**\n   * On drop fragment.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onDropFragment(e, data, state) {\n    debug('onDropFragment', { data: data });\n\n    var selection = state.selection;\n    var fragment = data.fragment,\n        target = data.target,\n        isInternal = data.isInternal;\n\n    // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n\n    if (isInternal && selection.endKey == target.endKey && selection.endOffset < target.endOffset) {\n      target = target.move(selection.startKey == selection.endKey ? 0 - selection.endOffset - selection.startOffset : 0 - selection.endOffset);\n    }\n\n    var transform = state.transform();\n\n    if (isInternal) transform.delete();\n\n    return transform.select(target).insertFragment(fragment).apply();\n  }\n\n  /**\n   * On drop text, split the blocks at new lines.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onDropText(e, data, state) {\n    debug('onDropText', { data: data });\n\n    var text = data.text,\n        target = data.target;\n    var document = state.document;\n\n    var transform = state.transform().select(target);\n\n    var hasVoidParent = document.hasVoidParent(target.anchorKey);\n\n    // Insert text into nearest text node\n    if (hasVoidParent) {\n      var node = document.getNode(target.anchorKey);\n\n      while (hasVoidParent) {\n        node = document.getNextText(node.key);\n        if (!node) break;\n        hasVoidParent = document.hasVoidParent(node.key);\n      }\n\n      if (node) transform.collapseToStartOf(node);\n    }\n\n    text.split('\\n').forEach(function (line, i) {\n      if (i > 0) transform.splitBlock();\n      transform.insertText(line);\n    });\n\n    return transform.apply();\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDown(e, data, state) {\n    debug('onKeyDown', { data: data });\n\n    switch (data.key) {\n      case 'enter':\n        return onKeyDownEnter(e, data, state);\n      case 'backspace':\n        return onKeyDownBackspace(e, data, state);\n      case 'delete':\n        return onKeyDownDelete(e, data, state);\n      case 'left':\n        return onKeyDownLeft(e, data, state);\n      case 'right':\n        return onKeyDownRight(e, data, state);\n      case 'up':\n        return onKeyDownUp(e, data, state);\n      case 'down':\n        return onKeyDownDown(e, data, state);\n      case 'd':\n        return onKeyDownD(e, data, state);\n      case 'h':\n        return onKeyDownH(e, data, state);\n      case 'k':\n        return onKeyDownK(e, data, state);\n      case 'y':\n        return onKeyDownY(e, data, state);\n      case 'z':\n        return onKeyDownZ(e, data, state);\n    }\n  }\n\n  /**\n   * On `enter` key down, split the current block in half.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownEnter(e, data, state) {\n    var document = state.document,\n        startKey = state.startKey;\n\n    var hasVoidParent = document.hasVoidParent(startKey);\n\n    // For void nodes, we don't want to split. Instead we just move to the start\n    // of the next text node if one exists.\n    if (hasVoidParent) {\n      var text = document.getNextText(startKey);\n      if (!text) return;\n      return state.transform().collapseToStartOf(text).apply();\n    }\n\n    return state.transform().splitBlock().apply();\n  }\n\n  /**\n   * On `backspace` key down, delete backwards.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownBackspace(e, data, state) {\n    var boundary = 'Char';\n    if (data.isWord) boundary = 'Word';\n    if (data.isLine) boundary = 'Line';\n\n    return state.transform()['delete' + boundary + 'Backward']().apply();\n  }\n\n  /**\n   * On `delete` key down, delete forwards.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownDelete(e, data, state) {\n    var boundary = 'Char';\n    if (data.isWord) boundary = 'Word';\n    if (data.isLine) boundary = 'Line';\n\n    return state.transform()['delete' + boundary + 'Forward']().apply();\n  }\n\n  /**\n   * On `left` key down, move backward.\n   *\n   * COMPAT: This is required to make navigating with the left arrow work when\n   * a void node is selected.\n   *\n   * COMPAT: This is also required to solve for the case where an inline node is\n   * surrounded by empty text nodes with zero-width spaces in them. Without this\n   * the zero-width spaces will cause two arrow keys to jump to the next text.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownLeft(e, data, state) {\n    if (data.isCtrl) return;\n    if (data.isAlt) return;\n    if (state.isExpanded) return;\n\n    var document = state.document,\n        startKey = state.startKey,\n        startText = state.startText;\n\n    var hasVoidParent = document.hasVoidParent(startKey);\n\n    // If the current text node is empty, or we're inside a void parent, we're\n    // going to need to handle the selection behavior.\n    if (startText.text == '' || hasVoidParent) {\n      e.preventDefault();\n      var previous = document.getPreviousText(startKey);\n\n      // If there's no previous text node in the document, abort.\n      if (!previous) return;\n\n      // If the previous text is in the current block, and inside a non-void\n      // inline node, move one character into the inline node.\n      var startBlock = state.startBlock;\n\n      var previousBlock = document.getClosestBlock(previous.key);\n      var previousInline = document.getClosestInline(previous.key);\n\n      if (previousBlock === startBlock && previousInline && !previousInline.isVoid) {\n        var extendOrMove = data.isShift ? 'extend' : 'move';\n        return state.transform().collapseToEndOf(previous)[extendOrMove](-1).apply();\n      }\n\n      // Otherwise, move to the end of the previous node.\n      return state.transform().collapseToEndOf(previous).apply();\n    }\n  }\n\n  /**\n   * On `right` key down, move forward.\n   *\n   * COMPAT: This is required to make navigating with the right arrow work when\n   * a void node is selected.\n   *\n   * COMPAT: This is also required to solve for the case where an inline node is\n   * surrounded by empty text nodes with zero-width spaces in them. Without this\n   * the zero-width spaces will cause two arrow keys to jump to the next text.\n   *\n   * COMPAT: In Chrome & Safari, selections that are at the zero offset of\n   * an inline node will be automatically replaced to be at the last offset\n   * of a previous inline node, which screws us up, so we never want to set the\n   * selection to the very start of an inline node here. (2016/11/29)\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownRight(e, data, state) {\n    if (data.isCtrl) return;\n    if (data.isAlt) return;\n    if (state.isExpanded) return;\n\n    var document = state.document,\n        startKey = state.startKey,\n        startText = state.startText;\n\n    var hasVoidParent = document.hasVoidParent(startKey);\n\n    // If the current text node is empty, or we're inside a void parent, we're\n    // going to need to handle the selection behavior.\n    if (startText.text == '' || hasVoidParent) {\n      e.preventDefault();\n      var next = document.getNextText(startKey);\n\n      // If there's no next text node in the document, abort.\n      if (!next) return state;\n\n      // If the next text is inside a void node, move to the end of it.\n      var isInVoid = document.hasVoidParent(next.key);\n\n      if (isInVoid) {\n        return state.transform().collapseToEndOf(next).apply();\n      }\n\n      // If the next text is in the current block, and inside an inline node,\n      // move one character into the inline node.\n      var startBlock = state.startBlock;\n\n      var nextBlock = document.getClosestBlock(next.key);\n      var nextInline = document.getClosestInline(next.key);\n\n      if (nextBlock == startBlock && nextInline) {\n        var extendOrMove = data.isShift ? 'extend' : 'move';\n        return state.transform().collapseToStartOf(next)[extendOrMove](1).apply();\n      }\n\n      // Otherwise, move to the start of the next text node.\n      return state.transform().collapseToStartOf(next).apply();\n    }\n  }\n\n  /**\n   * On `up` key down, for Macs, move the selection to start of the block.\n   *\n   * COMPAT: Certain browsers don't handle the selection updates properly. In\n   * Chrome, option-shift-up doesn't properly extend the selection. And in\n   * Firefox, option-up doesn't properly move the selection.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownUp(e, data, state) {\n    if (!_environment.IS_MAC || data.isCtrl || !data.isAlt) return;\n\n    var transform = data.isShift ? 'extendToStartOf' : 'collapseToStartOf';\n    var selection = state.selection,\n        document = state.document,\n        focusKey = state.focusKey,\n        focusBlock = state.focusBlock;\n\n    var block = selection.hasFocusAtStartOf(focusBlock) ? document.getPreviousBlock(focusKey) : focusBlock;\n\n    if (!block) return;\n    var text = block.getFirstText();\n\n    e.preventDefault();\n    return state.transform()[transform](text).apply();\n  }\n\n  /**\n   * On `down` key down, for Macs, move the selection to end of the block.\n   *\n   * COMPAT: Certain browsers don't handle the selection updates properly. In\n   * Chrome, option-shift-down doesn't properly extend the selection. And in\n   * Firefox, option-down doesn't properly move the selection.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownDown(e, data, state) {\n    if (!_environment.IS_MAC || data.isCtrl || !data.isAlt) return;\n\n    var transform = data.isShift ? 'extendToEndOf' : 'collapseToEndOf';\n    var selection = state.selection,\n        document = state.document,\n        focusKey = state.focusKey,\n        focusBlock = state.focusBlock;\n\n    var block = selection.hasFocusAtEndOf(focusBlock) ? document.getNextBlock(focusKey) : focusBlock;\n\n    if (!block) return;\n    var text = block.getLastText();\n\n    e.preventDefault();\n    return state.transform()[transform](text).apply();\n  }\n\n  /**\n   * On `d` key down, for Macs, delete one character forward.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownD(e, data, state) {\n    if (!_environment.IS_MAC || !data.isCtrl) return;\n    e.preventDefault();\n    return state.transform().deleteCharForward().apply();\n  }\n\n  /**\n   * On `h` key down, for Macs, delete until the end of the line.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownH(e, data, state) {\n    if (!_environment.IS_MAC || !data.isCtrl) return;\n    e.preventDefault();\n    return state.transform().deleteCharBackward().apply();\n  }\n\n  /**\n   * On `k` key down, for Macs, delete until the end of the line.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownK(e, data, state) {\n    if (!_environment.IS_MAC || !data.isCtrl) return;\n    e.preventDefault();\n    return state.transform().deleteLineForward().apply();\n  }\n\n  /**\n   * On `y` key down, redo.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownY(e, data, state) {\n    if (!data.isMod) return;\n\n    return state.transform().redo().apply({ save: false });\n  }\n\n  /**\n   * On `z` key down, undo or redo.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownZ(e, data, state) {\n    if (!data.isMod) return;\n\n    return state.transform()[data.isShift ? 'redo' : 'undo']().apply({ save: false });\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onPaste(e, data, state) {\n    debug('onPaste', { data: data });\n\n    switch (data.type) {\n      case 'fragment':\n        return onPasteFragment(e, data, state);\n      case 'text':\n      case 'html':\n        return onPasteText(e, data, state);\n    }\n  }\n\n  /**\n   * On paste fragment.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onPasteFragment(e, data, state) {\n    debug('onPasteFragment', { data: data });\n\n    return state.transform().insertFragment(data.fragment).apply();\n  }\n\n  /**\n   * On paste text, split blocks at new lines.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onPasteText(e, data, state) {\n    debug('onPasteText', { data: data });\n\n    var transform = state.transform();\n\n    data.text.split('\\n').forEach(function (line, i) {\n      if (i > 0) transform.splitBlock();\n      transform.insertText(line);\n    });\n\n    return transform.apply();\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onSelect(e, data, state) {\n    debug('onSelect', { data: data });\n\n    return state.transform().select(data.selection).apply();\n  }\n\n  /**\n   * Render.\n   *\n   * @param {Object} props\n   * @param {State} state\n   * @param {Editor} editor\n   * @return {Object}\n   */\n\n  function render(props, state, editor) {\n    return _react2.default.createElement(_content2.default, {\n      autoCorrect: props.autoCorrect,\n      autoFocus: props.autoFocus,\n      className: props.className,\n      children: props.children,\n      editor: editor,\n      onBeforeInput: editor.onBeforeInput,\n      onBlur: editor.onBlur,\n      onFocus: editor.onFocus,\n      onChange: editor.onChange,\n      onCopy: editor.onCopy,\n      onCut: editor.onCut,\n      onDrop: editor.onDrop,\n      onKeyDown: editor.onKeyDown,\n      onPaste: editor.onPaste,\n      onSelect: editor.onSelect,\n      readOnly: props.readOnly,\n      role: props.role,\n      schema: editor.getSchema(),\n      spellCheck: props.spellCheck,\n      state: state,\n      style: props.style,\n      tabIndex: props.tabIndex,\n      tagName: props.tagName\n    });\n  }\n\n  /**\n   * A default schema rule to render block nodes.\n   *\n   * @type {Object}\n   */\n\n  var BLOCK_RENDER_RULE = {\n    match: function match(node) {\n      return node.kind == 'block';\n    },\n    render: function render(props) {\n      return _react2.default.createElement(\n        'div',\n        _extends({}, props.attributes, { style: { position: 'relative' } }),\n        props.children,\n        placeholder ? _react2.default.createElement(\n          _placeholder2.default,\n          {\n            className: placeholderClassName,\n            node: props.node,\n            parent: props.state.document,\n            state: props.state,\n            style: placeholderStyle\n          },\n          placeholder\n        ) : null\n      );\n    }\n  };\n\n  /**\n   * A default schema rule to render inline nodes.\n   *\n   * @type {Object}\n   */\n\n  var INLINE_RENDER_RULE = {\n    match: function match(node) {\n      return node.kind == 'inline';\n    },\n    render: function render(props) {\n      return _react2.default.createElement(\n        'span',\n        _extends({}, props.attributes, { style: { position: 'relative' } }),\n        props.children\n      );\n    }\n  };\n\n  /**\n   * Add default rendering rules to the schema.\n   *\n   * @type {Object}\n   */\n\n  var schema = {\n    rules: [BLOCK_RENDER_RULE, INLINE_RENDER_RULE]\n  };\n\n  /**\n   * Return the core plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeChange: onBeforeChange,\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDrop: onDrop,\n    onKeyDown: onKeyDown,\n    onPaste: onPaste,\n    onSelect: onSelect,\n    render: render,\n    schema: schema\n  };\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Plugin;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/plugins/core.js\n// module id = ./node_modules/slate/lib/plugins/core.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _schema = require('../models/schema');\n\nvar _schema2 = _interopRequireDefault(_schema);\n\nvar _text = require('../models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Options object with normalize set to `false`.\n *\n * @type {Object}\n */\n\nvar OPTS = { normalize: false };\n\n/**\n * Define the core schema rules, order-sensitive.\n *\n * @type {Array}\n */\n\nvar rules = [\n\n/**\n * Only allow block nodes in documents.\n *\n * @type {Object}\n */\n\n{\n  match: function match(node) {\n    return node.kind == 'document';\n  },\n  validate: function validate(document) {\n    var invalids = document.nodes.filter(function (n) {\n      return n.kind != 'block';\n    });\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, document, invalids) {\n    invalids.forEach(function (node) {\n      transform.removeNodeByKey(node.key, OPTS);\n    });\n  }\n},\n\n/**\n * Only allow block, inline and text nodes in blocks.\n *\n * @type {Object}\n */\n\n{\n  match: function match(node) {\n    return node.kind == 'block';\n  },\n  validate: function validate(block) {\n    var invalids = block.nodes.filter(function (n) {\n      return n.kind != 'block' && n.kind != 'inline' && n.kind != 'text';\n    });\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, block, invalids) {\n    invalids.forEach(function (node) {\n      transform.removeNodeByKey(node.key, OPTS);\n    });\n  }\n},\n\n/**\n * Only allow inline and text nodes in inlines.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'inline';\n  },\n  validate: function validate(inline) {\n    var invalids = inline.nodes.filter(function (n) {\n      return n.kind != 'inline' && n.kind != 'text';\n    });\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, inline, invalids) {\n    invalids.forEach(function (node) {\n      transform.removeNodeByKey(node.key, OPTS);\n    });\n  }\n},\n\n/**\n * Ensure that block and inline nodes have at least one text child.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    return node.nodes.size == 0;\n  },\n  normalize: function normalize(transform, node) {\n    var text = _text2.default.create();\n    transform.insertNodeByKey(node.key, 0, text, OPTS);\n  }\n},\n\n/**\n * Ensure that void nodes contain a text node with a single space of text.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return (object.kind == 'inline' || object.kind == 'block') && object.isVoid;\n  },\n  validate: function validate(node) {\n    return node.text !== ' ' || node.nodes.size !== 1;\n  },\n  normalize: function normalize(transform, node, result) {\n    var text = _text2.default.createFromString(' ');\n    var index = node.nodes.size;\n\n    transform.insertNodeByKey(node.key, index, text, OPTS);\n\n    node.nodes.forEach(function (child) {\n      transform.removeNodeByKey(child.key, OPTS);\n    });\n  }\n},\n\n/**\n * Ensure that inline nodes are never empty.\n *\n * This rule is applied to all blocks, because when they contain an empty\n * inline, we need to remove the inline from that parent block. If `validate`\n * was to be memoized, it should be against the parent node, not the inline\n * themselves.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block';\n  },\n  validate: function validate(block) {\n    var invalids = block.nodes.filter(function (n) {\n      return n.kind == 'inline' && n.text == '';\n    });\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, block, invalids) {\n    // If all of the block's nodes are invalid, insert an empty text node so\n    // that the selection will be preserved when they are all removed.\n    if (block.nodes.size == invalids.size) {\n      var text = _text2.default.create();\n      transform.insertNodeByKey(block.key, 1, text, OPTS);\n    }\n\n    invalids.forEach(function (node) {\n      transform.removeNodeByKey(node.key, OPTS);\n    });\n  }\n},\n\n/**\n * Ensure that inline void nodes are surrounded by text nodes, by adding extra\n * blank text nodes if necessary.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    var invalids = node.nodes.reduce(function (list, child, index) {\n      if (child.kind !== 'inline') return list;\n\n      var prev = index > 0 ? node.nodes.get(index - 1) : null;\n      var next = node.nodes.get(index + 1);\n      // We don't test if \"prev\" is inline, since it has already been processed in the loop\n      var insertBefore = !prev;\n      var insertAfter = !next || next.kind == 'inline';\n\n      if (insertAfter || insertBefore) {\n        list = list.push({ insertAfter: insertAfter, insertBefore: insertBefore, index: index });\n      }\n\n      return list;\n    }, new _immutable.List());\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, block, invalids) {\n    // Shift for every text node inserted previously.\n    var shift = 0;\n\n    invalids.forEach(function (_ref) {\n      var index = _ref.index,\n          insertAfter = _ref.insertAfter,\n          insertBefore = _ref.insertBefore;\n\n      if (insertBefore) {\n        transform.insertNodeByKey(block.key, shift + index, _text2.default.create(), OPTS);\n        shift++;\n      }\n\n      if (insertAfter) {\n        transform.insertNodeByKey(block.key, shift + index + 1, _text2.default.create(), OPTS);\n        shift++;\n      }\n    });\n  }\n},\n\n/**\n * Join adjacent text nodes.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    var invalids = node.nodes.map(function (child, i) {\n      var next = node.nodes.get(i + 1);\n      if (child.kind != 'text') return;\n      if (!next || next.kind != 'text') return;\n      return [child, next];\n    }).filter(Boolean);\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, node, pairs) {\n    // We reverse the list to handle consecutive joins, since the earlier nodes\n    // will always exist after each join.\n    pairs.reverse().forEach(function (pair) {\n      var _pair = _slicedToArray(pair, 2),\n          first = _pair[0],\n          second = _pair[1];\n\n      return transform.joinNodeByKey(second.key, first.key, OPTS);\n    });\n  }\n},\n\n/**\n * Prevent extra empty text nodes, except when adjacent to inline void nodes.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    var nodes = node.nodes;\n\n    if (nodes.size <= 1) return;\n\n    var invalids = nodes.filter(function (desc, i) {\n      if (desc.kind != 'text') return;\n      if (desc.length > 0) return;\n\n      var prev = i > 0 ? nodes.get(i - 1) : null;\n      var next = nodes.get(i + 1);\n\n      // If it's the first node, and the next is a void, preserve it.\n      if (!prev && next.kind == 'inline') return;\n\n      // It it's the last node, and the previous is an inline, preserve it.\n      if (!next && prev.kind == 'inline') return;\n\n      // If it's surrounded by inlines, preserve it.\n      if (next && prev && next.kind == 'inline' && prev.kind == 'inline') return;\n\n      // Otherwise, remove it.\n      return true;\n    });\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, node, invalids) {\n    invalids.forEach(function (text) {\n      transform.removeNodeByKey(text.key, OPTS);\n    });\n  }\n}];\n\n/**\n * Create the core schema.\n *\n * @type {Schema}\n */\n\nvar SCHEMA = _schema2.default.create({ rules: rules });\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexports.default = SCHEMA;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/schemas/core.js\n// module id = ./node_modules/slate/lib/schemas/core.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raw = require('./raw');\n\nvar _raw2 = _interopRequireDefault(_raw);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Encode a JSON `object` as base-64 `string`.\n *\n * @param {Object} object\n * @return {String}\n */\n\nfunction encode(object) {\n  var string = JSON.stringify(object);\n  var encoded = window.btoa(window.encodeURIComponent(string));\n  return encoded;\n}\n\n/**\n * Decode a base-64 `string` to a JSON `object`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction decode(string) {\n  var decoded = window.decodeURIComponent(window.atob(string));\n  var object = JSON.parse(decoded);\n  return object;\n}\n\n/**\n * Deserialize a State `string`.\n *\n * @param {String} string\n * @return {State}\n */\n\nfunction deserialize(string, options) {\n  var raw = decode(string);\n  var state = _raw2.default.deserialize(raw, options);\n  return state;\n}\n\n/**\n * Deserialize a Node `string`.\n *\n * @param {String} string\n * @return {Node}\n */\n\nfunction deserializeNode(string, options) {\n  var raw = decode(string);\n  var node = _raw2.default.deserializeNode(raw, options);\n  return node;\n}\n\n/**\n * Serialize a `state`.\n *\n * @param {State} state\n * @return {String}\n */\n\nfunction serialize(state, options) {\n  var raw = _raw2.default.serialize(state, options);\n  var encoded = encode(raw);\n  return encoded;\n}\n\n/**\n * Serialize a `node`.\n *\n * @param {Node} node\n * @return {String}\n */\n\nfunction serializeNode(node, options) {\n  var raw = _raw2.default.serializeNode(node, options);\n  var encoded = encode(raw);\n  return encoded;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  deserialize: deserialize,\n  deserializeNode: deserializeNode,\n  serialize: serialize,\n  serializeNode: serializeNode\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/serializers/base-64.js\n// module id = ./node_modules/slate/lib/serializers/base-64.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _raw = require('./raw');\n\nvar _raw2 = _interopRequireDefault(_raw);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _server = require('react-dom/server');\n\nvar _server2 = _interopRequireDefault(_server);\n\nvar _typeOf = require('type-of');\n\nvar _typeOf2 = _interopRequireDefault(_typeOf);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * String.\n *\n * @type {String}\n */\n\nvar String = new _immutable.Record({\n  kind: 'string',\n  text: ''\n});\n\n/**\n * A rule to (de)serialize text nodes. This is automatically added to the HTML\n * serializer so that users don't have to worry about text-level serialization.\n *\n * @type {Object}\n */\n\nvar TEXT_RULE = {\n  deserialize: function deserialize(el) {\n    if (el.tagName == 'br') {\n      return {\n        kind: 'text',\n        text: '\\n'\n      };\n    }\n\n    if (el.nodeName == '#text') {\n      if (el.value && el.value.match(/<!--.*?-->/)) return;\n\n      return {\n        kind: 'text',\n        text: el.value || el.nodeValue\n      };\n    }\n  },\n  serialize: function serialize(obj, children) {\n    if (obj.kind == 'string') {\n      return children.split('\\n').reduce(function (array, text, i) {\n        if (i != 0) array.push(_react2.default.createElement('br', null));\n        array.push(text);\n        return array;\n      }, []);\n    }\n  }\n};\n\n/**\n * HTML serializer.\n *\n * @type {Html}\n */\n\nvar Html =\n\n/**\n * Create a new serializer with `rules`.\n *\n * @param {Object} options\n *   @property {Array} rules\n *   @property {String|Object} defaultBlockType\n *   @property {Function} parseHtml\n */\n\nfunction Html() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  _classCallCheck(this, Html);\n\n  _initialiseProps.call(this);\n\n  this.rules = [].concat(_toConsumableArray(options.rules || []), [TEXT_RULE]);\n\n  this.defaultBlockType = options.defaultBlockType || 'paragraph';\n\n  // Set DOM parser function or fallback to native DOMParser if present.\n  if (typeof options.parseHtml === 'function') {\n    this.parseHtml = options.parseHtml;\n  } else if (typeof DOMParser !== 'undefined') {\n    this.parseHtml = function (html) {\n      var parsed = new DOMParser().parseFromString(html, 'text/html');\n      // Unwrap from <html> and <body>\n      return parsed.childNodes[0].childNodes[1];\n    };\n  } else {\n    throw new Error('Native DOMParser is not present in this environment; you must supply a parse function via options.parseHtml');\n  }\n}\n\n/**\n * Deserialize pasted HTML.\n *\n * @param {String} html\n * @param {Object} options\n *   @property {Boolean} toRaw\n * @return {State}\n */\n\n/**\n * Deserialize an array of DOM elements.\n *\n * @param {Array} elements\n * @return {Array}\n */\n\n/**\n * Deserialize a DOM element.\n *\n * @param {Object} element\n * @return {Any}\n */\n\n/**\n * Deserialize a `mark` object.\n *\n * @param {Object} mark\n * @return {Array}\n */\n\n/**\n * Serialize a `state` object into an HTML string.\n *\n * @param {State} state\n * @param {Object} options\n *   @property {Boolean} render\n * @return {String|Array}\n */\n\n/**\n * Serialize a `node`.\n *\n * @param {Node} node\n * @return {String}\n */\n\n/**\n * Serialize a `range`.\n *\n * @param {Range} range\n * @return {String}\n */\n\n/**\n * Serialize a `string`.\n *\n * @param {String} string\n * @return {String}\n */\n\n/**\n * Filter out cruft newline nodes inserted by the DOM parser.\n *\n * @param {Object} element\n * @return {Boolean}\n */\n\n;\n\n/**\n * Add a unique key to a React `element`.\n *\n * @param {Element} element\n * @return {Element}\n */\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  this.deserialize = function (html) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var children = Array.from(_this.parseHtml(html).childNodes);\n    var nodes = _this.deserializeElements(children);\n\n    var defaultBlockType = _this.defaultBlockType;\n\n    var defaults = typeof defaultBlockType == 'string' ? { type: defaultBlockType } : defaultBlockType;\n\n    // HACK: ensure for now that all top-level inline are wrapped into a block.\n    nodes = nodes.reduce(function (memo, node, i, original) {\n      if (node.kind == 'block') {\n        memo.push(node);\n        return memo;\n      }\n\n      if (i > 0 && original[i - 1].kind != 'block') {\n        var _block = memo[memo.length - 1];\n        _block.nodes.push(node);\n        return memo;\n      }\n\n      var block = _extends({\n        kind: 'block',\n        nodes: [node]\n      }, defaults);\n\n      memo.push(block);\n      return memo;\n    }, []);\n\n    if (nodes.length === 0) {\n      nodes = [_extends({\n        kind: 'block',\n        nodes: []\n      }, defaults)];\n    }\n\n    var raw = {\n      kind: 'state',\n      document: {\n        kind: 'document',\n        nodes: nodes\n      }\n    };\n\n    if (options.toRaw) {\n      return raw;\n    }\n\n    var state = _raw2.default.deserialize(raw, { terse: true });\n    return state;\n  };\n\n  this.deserializeElements = function () {\n    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    var nodes = [];\n\n    elements.filter(_this.cruftNewline).forEach(function (element) {\n      var node = _this.deserializeElement(element);\n      switch ((0, _typeOf2.default)(node)) {\n        case 'array':\n          nodes = nodes.concat(node);\n          break;\n        case 'object':\n          nodes.push(node);\n          break;\n      }\n    });\n\n    return nodes;\n  };\n\n  this.deserializeElement = function (element) {\n    var node = void 0;\n\n    if (!element.tagName) {\n      element.tagName = '';\n    }\n\n    var next = function next(elements) {\n      if (typeof NodeList !== 'undefined' && elements instanceof NodeList) {\n        elements = Array.from(elements);\n      }\n      switch ((0, _typeOf2.default)(elements)) {\n        case 'array':\n          return _this.deserializeElements(elements);\n        case 'object':\n          return _this.deserializeElement(elements);\n        case 'null':\n        case 'undefined':\n          return;\n        default:\n          throw new Error('The `next` argument was called with invalid children: \"' + elements + '\".');\n      }\n    };\n\n    for (var i = 0; i < _this.rules.length; i++) {\n      var rule = _this.rules[i];\n      if (!rule.deserialize) continue;\n      var ret = rule.deserialize(element, next);\n      var type = (0, _typeOf2.default)(ret);\n\n      if (type != 'array' && type != 'object' && type != 'null' && type != 'undefined') {\n        throw new Error('A rule returned an invalid deserialized representation: \"' + node + '\".');\n      }\n\n      if (ret === undefined) continue;\n      if (ret === null) return null;\n\n      node = ret.kind == 'mark' ? _this.deserializeMark(ret) : ret;\n      break;\n    }\n\n    return node || next(element.childNodes);\n  };\n\n  this.deserializeMark = function (mark) {\n    var type = mark.type,\n        data = mark.data;\n\n\n    var applyMark = function applyMark(node) {\n      if (node.kind == 'mark') {\n        return _this.deserializeMark(node);\n      } else if (node.kind == 'text') {\n        if (!node.ranges) node.ranges = [{ text: node.text }];\n        node.ranges = node.ranges.map(function (range) {\n          range.marks = range.marks || [];\n          range.marks.push({ type: type, data: data });\n          return range;\n        });\n      } else {\n        node.nodes = node.nodes.map(applyMark);\n      }\n\n      return node;\n    };\n\n    return mark.nodes.reduce(function (nodes, node) {\n      var ret = applyMark(node);\n      if (Array.isArray(ret)) return nodes.concat(ret);\n      nodes.push(ret);\n      return nodes;\n    }, []);\n  };\n\n  this.serialize = function (state) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var document = state.document;\n\n    var elements = document.nodes.map(_this.serializeNode);\n    if (options.render === false) return elements;\n\n    var html = _server2.default.renderToStaticMarkup(_react2.default.createElement(\n      'body',\n      null,\n      elements\n    ));\n    var inner = html.slice(6, -7);\n    return inner;\n  };\n\n  this.serializeNode = function (node) {\n    if (node.kind == 'text') {\n      var ranges = node.getRanges();\n      return ranges.map(_this.serializeRange);\n    }\n\n    var children = node.nodes.map(_this.serializeNode);\n\n    for (var i = 0; i < _this.rules.length; i++) {\n      var rule = _this.rules[i];\n      if (!rule.serialize) continue;\n      var ret = rule.serialize(node, children);\n      if (ret) return addKey(ret);\n    }\n\n    throw new Error('No serializer defined for node of type \"' + node.type + '\".');\n  };\n\n  this.serializeRange = function (range) {\n    var string = new String({ text: range.text });\n    var text = _this.serializeString(string);\n\n    return range.marks.reduce(function (children, mark) {\n      for (var i = 0; i < _this.rules.length; i++) {\n        var rule = _this.rules[i];\n        if (!rule.serialize) continue;\n        var ret = rule.serialize(mark, children);\n        if (ret) return addKey(ret);\n      }\n\n      throw new Error('No serializer defined for mark of type \"' + mark.type + '\".');\n    }, text);\n  };\n\n  this.serializeString = function (string) {\n    for (var i = 0; i < _this.rules.length; i++) {\n      var rule = _this.rules[i];\n      if (!rule.serialize) continue;\n      var ret = rule.serialize(string, string.text);\n      if (ret) return ret;\n    }\n  };\n\n  this.cruftNewline = function (element) {\n    return !(element.nodeName == '#text' && element.value == '\\n');\n  };\n};\n\nvar key = 0;\n\nfunction addKey(element) {\n  return _react2.default.cloneElement(element, { key: key++ });\n}\n\n/**\n * Export.\n *\n * @type {Html}\n */\n\nexports.default = Html;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/serializers/html.js\n// module id = ./node_modules/slate/lib/serializers/html.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raw = require('../serializers/raw');\n\nvar _raw2 = _interopRequireDefault(_raw);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Deserialize a plain text `string` to a state.\n *\n * @param {String} string\n * @param {Object} options\n *   @property {Boolean} toRaw\n * @return {State}\n */\n\nfunction deserialize(string) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var raw = {\n    kind: 'state',\n    document: {\n      kind: 'document',\n      nodes: string.split('\\n').map(function (line) {\n        return {\n          kind: 'block',\n          type: 'line',\n          nodes: [{\n            kind: 'text',\n            ranges: [{\n              text: line,\n              marks: []\n            }]\n          }]\n        };\n      })\n    }\n  };\n\n  return options.toRaw ? raw : _raw2.default.deserialize(raw);\n}\n\n/**\n * Serialize a `state` to plain text.\n *\n * @param {State} state\n * @return {String}\n */\n\nfunction serialize(state) {\n  return state.document.nodes.map(function (block) {\n    return block.text;\n  }).join('\\n');\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  deserialize: deserialize,\n  serialize: serialize\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/serializers/plain.js\n// module id = ./node_modules/slate/lib/serializers/plain.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _block = require('../models/block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _character = require('../models/character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _document = require('../models/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _inline = require('../models/inline');\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _mark = require('../models/mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _selection = require('../models/selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _state = require('../models/state');\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _text = require('../models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _isEmpty = require('is-empty');\n\nvar _isEmpty2 = _interopRequireDefault(_isEmpty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Raw.\n *\n * @type {Object}\n */\n\nvar Raw = {\n\n  /**\n   * Deserialize a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Block}\n   */\n\n  deserialize: function deserialize(object, options) {\n    return Raw.deserializeState(object, options);\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Block`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Block}\n   */\n\n  deserializeBlock: function deserializeBlock(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyBlock(object);\n\n    return _block2.default.create({\n      key: object.key,\n      type: object.type,\n      data: object.data,\n      isVoid: object.isVoid,\n      nodes: _block2.default.createList(object.nodes.map(function (node) {\n        return Raw.deserializeNode(node, options);\n      }))\n    });\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Document`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Document}\n   */\n\n  deserializeDocument: function deserializeDocument(object, options) {\n    return _document2.default.create({\n      key: object.key,\n      data: object.data,\n      nodes: _block2.default.createList(object.nodes.map(function (node) {\n        return Raw.deserializeNode(node, options);\n      }))\n    });\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing an `Inline`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Inline}\n   */\n\n  deserializeInline: function deserializeInline(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyInline(object);\n\n    return _inline2.default.create({\n      key: object.key,\n      type: object.type,\n      data: object.data,\n      isVoid: object.isVoid,\n      nodes: _inline2.default.createList(object.nodes.map(function (node) {\n        return Raw.deserializeNode(node, options);\n      }))\n    });\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Mark`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Mark}\n   */\n\n  deserializeMark: function deserializeMark(object, options) {\n    return _mark2.default.create(object);\n  },\n\n\n  /**\n   * Deserialize a JSON object representing a `Node`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Node}\n   */\n\n  deserializeNode: function deserializeNode(object, options) {\n    switch (object.kind) {\n      case 'block':\n        return Raw.deserializeBlock(object, options);\n      case 'document':\n        return Raw.deserializeDocument(object, options);\n      case 'inline':\n        return Raw.deserializeInline(object, options);\n      case 'text':\n        return Raw.deserializeText(object, options);\n      default:\n        {\n          throw new Error('Unrecognized node kind \"' + object.kind + '\".');\n        }\n    }\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Range`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {List<Character>}\n   */\n\n  deserializeRange: function deserializeRange(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyRange(object);\n\n    var marks = _mark2.default.createSet(object.marks.map(function (mark) {\n      return Raw.deserializeMark(mark, options);\n    }));\n\n    return _character2.default.createList(object.text.split('').map(function (char) {\n      return _character2.default.create({\n        text: char,\n        marks: marks\n      });\n    }));\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Selection`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {State}\n   */\n\n  deserializeSelection: function deserializeSelection(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return _selection2.default.create({\n      anchorKey: object.anchorKey,\n      anchorOffset: object.anchorOffset,\n      focusKey: object.focusKey,\n      focusOffset: object.focusOffset,\n      isFocused: object.isFocused\n    });\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `State`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {State}\n   */\n\n  deserializeState: function deserializeState(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyState(object);\n\n    var document = Raw.deserializeDocument(object.document, options);\n    var selection = void 0;\n\n    if (object.selection != null) {\n      selection = Raw.deserializeSelection(object.selection, options);\n    }\n\n    return _state2.default.create({ data: object.data, document: document, selection: selection }, options);\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Text`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Text}\n   */\n\n  deserializeText: function deserializeText(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyText(object);\n\n    return _text2.default.create({\n      key: object.key,\n      characters: object.ranges.reduce(function (characters, range) {\n        return characters.concat(Raw.deserializeRange(range, options));\n      }, _character2.default.createList())\n    });\n  },\n\n\n  /**\n   * Serialize a `model`.\n   *\n   * @param {Mixed} model\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serialize: function serialize(model, options) {\n    return Raw.serializeState(model, options);\n  },\n\n\n  /**\n   * Serialize a `block` node.\n   *\n   * @param {Block} block\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeBlock: function serializeBlock(block) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      data: block.data.toJSON(),\n      key: block.key,\n      kind: block.kind,\n      isVoid: block.isVoid,\n      type: block.type,\n      nodes: block.nodes.toArray().map(function (node) {\n        return Raw.serializeNode(node, options);\n      })\n    };\n\n    if (!options.preserveKeys) {\n      delete object.key;\n    }\n\n    return options.terse ? Raw.tersifyBlock(object) : object;\n  },\n\n\n  /**\n   * Serialize a `document`.\n   *\n   * @param {Document} document\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeDocument: function serializeDocument(document) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      data: document.data.toJSON(),\n      key: document.key,\n      kind: document.kind,\n      nodes: document.nodes.toArray().map(function (node) {\n        return Raw.serializeNode(node, options);\n      })\n    };\n\n    if (!options.preserveKeys) {\n      delete object.key;\n    }\n\n    return options.terse ? Raw.tersifyDocument(object) : object;\n  },\n\n\n  /**\n   * Serialize an `inline` node.\n   *\n   * @param {Inline} inline\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeInline: function serializeInline(inline) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      data: inline.data.toJSON(),\n      key: inline.key,\n      kind: inline.kind,\n      isVoid: inline.isVoid,\n      type: inline.type,\n      nodes: inline.nodes.toArray().map(function (node) {\n        return Raw.serializeNode(node, options);\n      })\n    };\n\n    if (!options.preserveKeys) {\n      delete object.key;\n    }\n\n    return options.terse ? Raw.tersifyInline(object) : object;\n  },\n\n\n  /**\n   * Serialize a `mark`.\n   *\n   * @param {Mark} mark\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeMark: function serializeMark(mark) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      data: mark.data.toJSON(),\n      kind: mark.kind,\n      type: mark.type\n    };\n\n    return options.terse ? Raw.tersifyMark(object) : object;\n  },\n\n\n  /**\n   * Serialize a `node`.\n   *\n   * @param {Node} node\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeNode: function serializeNode(node, options) {\n    switch (node.kind) {\n      case 'block':\n        return Raw.serializeBlock(node, options);\n      case 'document':\n        return Raw.serializeDocument(node, options);\n      case 'inline':\n        return Raw.serializeInline(node, options);\n      case 'text':\n        return Raw.serializeText(node, options);\n      default:\n        {\n          throw new Error('Unrecognized node kind \"' + node.kind + '\".');\n        }\n    }\n  },\n\n\n  /**\n   * Serialize a `range`.\n   *\n   * @param {Range} range\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeRange: function serializeRange(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      kind: range.kind,\n      text: range.text,\n      marks: range.marks.toArray().map(function (mark) {\n        return Raw.serializeMark(mark, options);\n      })\n    };\n\n    return options.terse ? Raw.tersifyRange(object) : object;\n  },\n\n\n  /**\n   * Serialize a `selection`.\n   *\n   * @param {Selection} selection\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeSelection: function serializeSelection(selection) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      kind: selection.kind,\n      anchorKey: selection.anchorKey,\n      anchorOffset: selection.anchorOffset,\n      focusKey: selection.focusKey,\n      focusOffset: selection.focusOffset,\n      isBackward: selection.isBackward,\n      isFocused: selection.isFocused\n    };\n\n    return options.terse ? Raw.tersifySelection(object) : object;\n  },\n\n\n  /**\n   * Serialize a `state`.\n   *\n   * @param {State} state\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeState: function serializeState(state) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      document: Raw.serializeDocument(state.document, options),\n      kind: state.kind\n    };\n\n    if (options.preserveSelection) {\n      object.selection = Raw.serializeSelection(state.selection, options);\n    }\n\n    if (options.preserveStateData) {\n      object.data = state.data.toJSON();\n    }\n\n    var ret = options.terse ? Raw.tersifyState(object) : object;\n\n    return ret;\n  },\n\n\n  /**\n   * Serialize a `text` node.\n   *\n   * @param {Text} text\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeText: function serializeText(text) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      key: text.key,\n      kind: text.kind,\n      ranges: text.getRanges().toArray().map(function (range) {\n        return Raw.serializeRange(range, options);\n      })\n    };\n\n    if (!options.preserveKeys) {\n      delete object.key;\n    }\n\n    return options.terse ? Raw.tersifyText(object) : object;\n  },\n\n\n  /**\n   * Create a terse representation of a block `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyBlock: function tersifyBlock(object) {\n    var ret = {};\n    ret.kind = object.kind;\n    ret.type = object.type;\n    if (object.key) ret.key = object.key;\n    if (!object.isVoid) ret.nodes = object.nodes;\n    if (object.isVoid) ret.isVoid = object.isVoid;\n    if (!(0, _isEmpty2.default)(object.data)) ret.data = object.data;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a document `object.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyDocument: function tersifyDocument(object) {\n    var ret = {};\n    ret.nodes = object.nodes;\n    if (object.key) ret.key = object.key;\n    if (!(0, _isEmpty2.default)(object.data)) ret.data = object.data;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a inline `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyInline: function tersifyInline(object) {\n    var ret = {};\n    ret.kind = object.kind;\n    ret.type = object.type;\n    if (object.key) ret.key = object.key;\n    if (!object.isVoid) ret.nodes = object.nodes;\n    if (object.isVoid) ret.isVoid = object.isVoid;\n    if (!(0, _isEmpty2.default)(object.data)) ret.data = object.data;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a mark `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyMark: function tersifyMark(object) {\n    var ret = {};\n    ret.type = object.type;\n    if (!(0, _isEmpty2.default)(object.data)) ret.data = object.data;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a range `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyRange: function tersifyRange(object) {\n    var ret = {};\n    ret.text = object.text;\n    if (!(0, _isEmpty2.default)(object.marks)) ret.marks = object.marks;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a selection `object.`\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifySelection: function tersifySelection(object) {\n    return {\n      anchorKey: object.anchorKey,\n      anchorOffset: object.anchorOffset,\n      focusKey: object.focusKey,\n      focusOffset: object.focusOffset,\n      isFocused: object.isFocused\n    };\n  },\n\n\n  /**\n   * Create a terse representation of a state `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyState: function tersifyState(object) {\n    var data = object.data,\n        document = object.document,\n        selection = object.selection;\n\n    var emptyData = (0, _isEmpty2.default)(data);\n\n    if (!selection && emptyData) {\n      return document;\n    }\n\n    var ret = { document: document };\n    if (!emptyData) ret.data = data;\n    if (selection) ret.selection = selection;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a text `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyText: function tersifyText(object) {\n    var ret = {};\n    ret.kind = object.kind;\n    if (object.key) ret.key = object.key;\n\n    if (object.ranges.length == 1 && object.ranges[0].marks == null) {\n      ret.text = object.ranges[0].text;\n    } else {\n      ret.ranges = object.ranges;\n    }\n\n    return ret;\n  },\n\n\n  /**\n   * Convert a terse representation of a block `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyBlock: function untersifyBlock(object) {\n    if (object.isVoid || !object.nodes || !object.nodes.length) {\n      return {\n        key: object.key,\n        data: object.data,\n        kind: object.kind,\n        type: object.type,\n        isVoid: object.isVoid,\n        nodes: [{\n          kind: 'text',\n          text: ''\n        }]\n      };\n    }\n\n    return object;\n  },\n\n\n  /**\n   * Convert a terse representation of a inline `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyInline: function untersifyInline(object) {\n    if (object.isVoid || !object.nodes || !object.nodes.length) {\n      return {\n        key: object.key,\n        data: object.data,\n        kind: object.kind,\n        type: object.type,\n        isVoid: object.isVoid,\n        nodes: [{\n          kind: 'text',\n          text: ''\n        }]\n      };\n    }\n\n    return object;\n  },\n\n\n  /**\n   * Convert a terse representation of a range `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyRange: function untersifyRange(object) {\n    return {\n      kind: 'range',\n      text: object.text,\n      marks: object.marks || []\n    };\n  },\n\n\n  /**\n   * Convert a terse representation of a selection `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifySelection: function untersifySelection(object) {\n    return {\n      kind: 'selection',\n      anchorKey: object.anchorKey,\n      anchorOffset: object.anchorOffset,\n      focusKey: object.focusKey,\n      focusOffset: object.focusOffset,\n      isBackward: null,\n      isFocused: false\n    };\n  },\n\n\n  /**\n   * Convert a terse representation of a state `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyState: function untersifyState(object) {\n    if (object.document) {\n      return {\n        kind: 'state',\n        data: object.data,\n        document: object.document,\n        selection: object.selection\n      };\n    }\n\n    return {\n      kind: 'state',\n      document: {\n        data: object.data,\n        key: object.key,\n        kind: 'document',\n        nodes: object.nodes\n      }\n    };\n  },\n\n\n  /**\n   * Convert a terse representation of a text `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyText: function untersifyText(object) {\n    if (object.ranges) return object;\n\n    return {\n      key: object.key,\n      kind: object.kind,\n      ranges: [{\n        text: object.text,\n        marks: object.marks || []\n      }]\n    };\n  }\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Raw;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/serializers/raw.js\n// module id = ./node_modules/slate/lib/serializers/raw.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:operation');\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Operations.\n *\n * @type {Object}\n */\n\nvar OPERATIONS = {\n  // Text operations.\n  insert_text: insertText,\n  remove_text: removeText,\n  // Mark operations.\n  add_mark: addMark,\n  remove_mark: removeMark,\n  set_mark: setMark,\n  // Node operations.\n  insert_node: insertNode,\n  join_node: joinNode,\n  move_node: moveNode,\n  remove_node: removeNode,\n  set_node: setNode,\n  split_node: splitNode,\n  // Selection operations.\n  set_selection: setSelection,\n  // State data operations.\n  set_data: setData\n};\n\n/**\n * Apply an `operation` to the current state.\n *\n * @param {Transform} transform\n * @param {Object} operation\n */\n\nTransforms.applyOperation = function (transform, operation) {\n  var state = transform.state,\n      operations = transform.operations;\n  var type = operation.type;\n\n  var fn = OPERATIONS[type];\n\n  if (!fn) {\n    throw new Error('Unknown operation type: \"' + type + '\".');\n  }\n\n  debug(type, operation);\n  transform.state = fn(state, operation);\n  transform.operations = operations.concat([operation]);\n};\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction addMark(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      length = operation.length,\n      mark = operation.mark;\n  var _state = state,\n      document = _state.document;\n\n  var node = document.assertPath(path);\n  node = node.addMark(offset, length, mark);\n  document = document.updateDescendant(node);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction insertNode(state, operation) {\n  var path = operation.path,\n      index = operation.index,\n      node = operation.node;\n  var _state2 = state,\n      document = _state2.document;\n\n  var parent = document.assertPath(path);\n  var isParent = document == parent;\n  parent = parent.insertNode(index, node);\n  document = isParent ? parent : document.updateDescendant(parent);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction insertText(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      text = operation.text,\n      marks = operation.marks;\n  var _state3 = state,\n      document = _state3.document,\n      selection = _state3.selection;\n  var _selection = selection,\n      anchorKey = _selection.anchorKey,\n      focusKey = _selection.focusKey,\n      anchorOffset = _selection.anchorOffset,\n      focusOffset = _selection.focusOffset;\n\n  var node = document.assertPath(path);\n\n  // Update the document\n  node = node.insertText(offset, text, marks);\n  document = document.updateDescendant(node);\n\n  // Update the selection\n  if (anchorKey == node.key && anchorOffset >= offset) {\n    selection = selection.moveAnchor(text.length);\n  }\n  if (focusKey == node.key && focusOffset >= offset) {\n    selection = selection.moveFocus(text.length);\n  }\n\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Join a node by `path` with a node `withPath`.\n *\n * @param {State} state\n * @param {Object} operation\n *   @param {Boolean} operation.deep (optional) Join recursively the\n *   respective last node and first node of the nodes' children. Like a zipper :)\n * @return {State}\n */\n\nfunction joinNode(state, operation) {\n  var path = operation.path,\n      withPath = operation.withPath,\n      _operation$deep = operation.deep,\n      deep = _operation$deep === undefined ? false : _operation$deep;\n  var _state4 = state,\n      document = _state4.document,\n      selection = _state4.selection;\n\n  var first = document.assertPath(withPath);\n  var second = document.assertPath(path);\n\n  document = document.joinNode(first, second, { deep: deep });\n\n  // If the operation is deep, or the nodes are text nodes, it means we will be\n  // merging two text nodes together, so we need to update the selection.\n  if (deep || second.kind == 'text') {\n    var _selection2 = selection,\n        anchorKey = _selection2.anchorKey,\n        anchorOffset = _selection2.anchorOffset,\n        focusKey = _selection2.focusKey,\n        focusOffset = _selection2.focusOffset;\n\n    var firstText = first.kind == 'text' ? first : first.getLastText();\n    var secondText = second.kind == 'text' ? second : second.getFirstText();\n\n    if (anchorKey == secondText.key) {\n      selection = selection.merge({\n        anchorKey: firstText.key,\n        anchorOffset: anchorOffset + firstText.characters.size\n      });\n    }\n\n    if (focusKey == secondText.key) {\n      selection = selection.merge({\n        focusKey: firstText.key,\n        focusOffset: focusOffset + firstText.characters.size\n      });\n    }\n  }\n\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Move a node by `path` to a new parent by `path` and `index`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction moveNode(state, operation) {\n  var path = operation.path,\n      newPath = operation.newPath,\n      newIndex = operation.newIndex;\n  var _state5 = state,\n      document = _state5.document;\n\n  var node = document.assertPath(path);\n  var index = path[path.length - 1];\n  var parentPath = path.slice(0, -1);\n\n  // Remove the node from its current parent\n  var parent = document.getParent(node.key);\n  parent = parent.removeNode(index);\n  document = parent.kind === 'document' ? parent : document.updateDescendant(parent);\n\n  // Check if `parent` is an anchestor of `target`\n  var isAncestor = parentPath.every(function (x, i) {\n    return x === newPath[i];\n  });\n\n  var target = void 0;\n\n  // If `parent` is an ancestor of `target` and their paths have same length,\n  // then `parent` and `target` are equal.\n  if (isAncestor && parentPath.length === newPath.length) {\n    target = parent;\n  }\n\n  // Else if `parent` is an ancestor of `target` and `node` index is less than\n  // the index of the `target` ancestor with the same depth of `node`,\n  // then removing `node` changes the path to `target`.\n  // So we have to adjust `newPath` before picking `target`.\n  else if (isAncestor && index < newPath[parentPath.length]) {\n      newPath[parentPath.length]--;\n      target = document.assertPath(newPath);\n    }\n\n    // Else pick `target`\n    else {\n        target = document.assertPath(newPath);\n      }\n\n  // Insert the new node to its new parent\n  target = target.insertNode(newIndex, node);\n  document = target.kind === 'document' ? target : document.updateDescendant(target);\n\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction removeMark(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      length = operation.length,\n      mark = operation.mark;\n  var _state6 = state,\n      document = _state6.document;\n\n  var node = document.assertPath(path);\n  node = node.removeMark(offset, length, mark);\n  document = document.updateDescendant(node);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Remove a node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction removeNode(state, operation) {\n  var path = operation.path;\n  var _state7 = state,\n      document = _state7.document,\n      selection = _state7.selection;\n  var _selection3 = selection,\n      startKey = _selection3.startKey,\n      endKey = _selection3.endKey;\n\n  var node = document.assertPath(path);\n\n  // If the selection is set, check to see if it needs to be updated.\n  if (selection.isSet) {\n    var hasStartNode = node.hasNode(startKey);\n    var hasEndNode = node.hasNode(endKey);\n\n    // If one of the selection's nodes is being removed, we need to update it.\n    if (hasStartNode) {\n      var prev = document.getPreviousText(startKey);\n      var next = document.getNextText(startKey);\n\n      if (prev) {\n        selection = selection.moveStartTo(prev.key, prev.length);\n      } else if (next) {\n        selection = selection.moveStartTo(next.key, 0);\n      } else {\n        selection = selection.deselect();\n      }\n    }\n\n    if (hasEndNode) {\n      var _prev = document.getPreviousText(endKey);\n      var _next = document.getNextText(endKey);\n\n      if (_prev) {\n        selection = selection.moveEndTo(_prev.key, _prev.length);\n      } else if (_next) {\n        selection = selection.moveEndTo(_next.key, 0);\n      } else {\n        selection = selection.deselect();\n      }\n    }\n  }\n\n  // Remove the node from the document.\n  var parent = document.getParent(node.key);\n  var index = parent.nodes.indexOf(node);\n  var isParent = document == parent;\n  parent = parent.removeNode(index);\n  document = isParent ? parent : document.updateDescendant(parent);\n\n  // Update the document and selection.\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction removeText(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      length = operation.length;\n\n  var rangeOffset = offset + length;\n  var _state8 = state,\n      document = _state8.document,\n      selection = _state8.selection;\n  var _selection4 = selection,\n      anchorKey = _selection4.anchorKey,\n      focusKey = _selection4.focusKey,\n      anchorOffset = _selection4.anchorOffset,\n      focusOffset = _selection4.focusOffset;\n\n  var node = document.assertPath(path);\n\n  // Update the selection\n  if (anchorKey == node.key && anchorOffset >= rangeOffset) {\n    selection = selection.moveAnchor(-length);\n  }\n  if (focusKey == node.key && focusOffset >= rangeOffset) {\n    selection = selection.moveFocus(-length);\n  }\n\n  node = node.removeText(offset, length);\n  document = document.updateDescendant(node);\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Set `data` on `state`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction setData(state, operation) {\n  var properties = operation.properties;\n  var _state9 = state,\n      data = _state9.data;\n\n\n  data = data.merge(properties);\n  state = state.set('data', data);\n  return state;\n}\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction setMark(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      length = operation.length,\n      mark = operation.mark,\n      newMark = operation.newMark;\n  var _state10 = state,\n      document = _state10.document;\n\n  var node = document.assertPath(path);\n  node = node.updateMark(offset, length, mark, newMark);\n  document = document.updateDescendant(node);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction setNode(state, operation) {\n  var path = operation.path,\n      properties = operation.properties;\n  var _state11 = state,\n      document = _state11.document;\n\n  var node = document.assertPath(path);\n\n  // Deprecate the ability to overwite a node's children.\n  if (properties.nodes && properties.nodes != node.nodes) {\n    (0, _warn2.default)('Updating a Node\\'s `nodes` property via `setNode()` is not allowed. Use the appropriate insertion and removal operations instead. The opeartion in question was:', operation);\n    delete properties.nodes;\n  }\n\n  // Deprecate the ability to change a node's key.\n  if (properties.key && properties.key != node.key) {\n    (0, _warn2.default)('Updating a Node\\'s `key` property via `setNode()` is not allowed. There should be no reason to do this. The opeartion in question was:', operation);\n    delete properties.key;\n  }\n\n  node = node.merge(properties);\n  document = node.kind === 'document' ? node : document.updateDescendant(node);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Set `properties` on the selection.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction setSelection(state, operation) {\n  var properties = _extends({}, operation.properties);\n  var _state12 = state,\n      document = _state12.document,\n      selection = _state12.selection;\n\n\n  if (properties.anchorPath !== undefined) {\n    properties.anchorKey = properties.anchorPath === null ? null : document.assertPath(properties.anchorPath).key;\n    delete properties.anchorPath;\n  }\n\n  if (properties.focusPath !== undefined) {\n    properties.focusKey = properties.focusPath === null ? null : document.assertPath(properties.focusPath).key;\n    delete properties.focusPath;\n  }\n\n  selection = selection.merge(properties);\n  selection = selection.normalize(document);\n  state = state.set('selection', selection);\n  return state;\n}\n\n/**\n * Split a node by `path` at `offset`.\n *\n * @param {State} state\n * @param {Object} operation\n *   @param {Array} operation.path The path of the node to split\n *   @param {Number} operation.offset (optional) Split using a relative offset\n *   @param {Number} operation.count (optional) Split after `count`\n *   children. Cannot be used in combination with offset.\n * @return {State}\n */\n\nfunction splitNode(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      count = operation.count;\n  var _state13 = state,\n      document = _state13.document,\n      selection = _state13.selection;\n\n  // If there's no offset, it's using the `count` instead.\n\n  if (offset == null) {\n    document = document.splitNodeAfter(path, count);\n    state = state.set('document', document);\n    return state;\n  }\n\n  // Otherwise, split using the `offset`, but calculate a few things first.\n  var node = document.assertPath(path);\n  var text = node.kind == 'text' ? node : node.getTextAtOffset(offset);\n  var textOffset = node.kind == 'text' ? offset : offset - node.getOffset(text.key);\n  var _selection5 = selection,\n      anchorKey = _selection5.anchorKey,\n      anchorOffset = _selection5.anchorOffset,\n      focusKey = _selection5.focusKey,\n      focusOffset = _selection5.focusOffset;\n\n\n  document = document.splitNode(path, offset);\n\n  // Determine whether we need to update the selection.\n  var splitAnchor = text.key == anchorKey && textOffset <= anchorOffset;\n  var splitFocus = text.key == focusKey && textOffset <= focusOffset;\n\n  // If either the anchor of focus was after the split, we need to update them.\n  if (splitFocus || splitAnchor) {\n    var nextText = document.getNextText(text.key);\n\n    if (splitAnchor) {\n      selection = selection.merge({\n        anchorKey: nextText.key,\n        anchorOffset: anchorOffset - textOffset\n      });\n    }\n\n    if (splitFocus) {\n      selection = selection.merge({\n        focusKey: nextText.key,\n        focusOffset: focusOffset - textOffset\n      });\n    }\n  }\n\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/apply-operation.js\n// module id = ./node_modules/slate/lib/transforms/apply-operation.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Transform} transform\n * @param {Mark} mark\n */\n\nTransforms.addMark = function (transform, mark) {\n  mark = _normalize2.default.mark(mark);\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n\n  if (selection.isExpanded) {\n    transform.addMarkAtRange(selection, mark);\n    return;\n  }\n\n  if (selection.marks) {\n    var _marks = selection.marks.add(mark);\n    var _sel = selection.set('marks', _marks);\n    transform.select(_sel);\n    return;\n  }\n\n  var marks = document.getMarksAtRange(selection).add(mark);\n  var sel = selection.set('marks', marks);\n  transform.select(sel);\n};\n\n/**\n * Delete at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.delete = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  if (selection.isCollapsed) return;\n\n  transform.snapshotSelection().deleteAtRange(selection)\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes this isn't guaranteed.\n  .collapseToStart().snapshotSelection();\n};\n\n/**\n * Delete backward `n` characters at the current selection.\n *\n * @param {Transform} transform\n * @param {Number} n (optional)\n */\n\nTransforms.deleteBackward = function (transform) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteBackwardAtRange(selection, n);\n};\n\n/**\n * Delete backward until the character boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteCharBackward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteCharBackwardAtRange(selection);\n};\n\n/**\n * Delete backward until the line boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteLineBackward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteLineBackwardAtRange(selection);\n};\n\n/**\n * Delete backward until the word boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteWordBackward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteWordBackwardAtRange(selection);\n};\n\n/**\n * Delete forward `n` characters at the current selection.\n *\n * @param {Transform} transform\n * @param {Number} n (optional)\n */\n\nTransforms.deleteForward = function (transform) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteForwardAtRange(selection, n);\n};\n\n/**\n * Delete forward until the character boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteCharForward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteCharForwardAtRange(selection);\n};\n\n/**\n * Delete forward until the line boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteLineForward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteLineForwardAtRange(selection);\n};\n\n/**\n * Delete forward until the word boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteWordForward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteWordForwardAtRange(selection);\n};\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Transform} transform\n * @param {String|Object|Block} block\n */\n\nTransforms.insertBlock = function (transform, block) {\n  block = _normalize2.default.block(block);\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.insertBlockAtRange(selection, block);\n\n  // If the node was successfully inserted, update the selection.\n  var node = transform.state.document.getNode(block.key);\n  if (node) transform.collapseToEndOf(node);\n};\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Transform} transform\n * @param {Document} fragment\n */\n\nTransforms.insertFragment = function (transform, fragment) {\n  var state = transform.state;\n  var _state = state,\n      document = _state.document,\n      selection = _state.selection;\n\n\n  if (!fragment.nodes.size) return;\n\n  var _state2 = state,\n      startText = _state2.startText,\n      endText = _state2.endText;\n\n  var lastText = fragment.getLastText();\n  var lastInline = fragment.getClosestInline(lastText.key);\n  var keys = document.getTexts().map(function (text) {\n    return text.key;\n  });\n  var isAppending = selection.hasEdgeAtEndOf(endText) || selection.hasEdgeAtStartOf(startText);\n\n  transform.deselect();\n  transform.insertFragmentAtRange(selection, fragment);\n  state = transform.state;\n  document = state.document;\n\n  var newTexts = document.getTexts().filter(function (n) {\n    return !keys.includes(n.key);\n  });\n  var newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first();\n  var after = void 0;\n\n  if (newText && lastInline) {\n    after = selection.collapseToEndOf(newText);\n  } else if (newText) {\n    after = selection.collapseToStartOf(newText).move(lastText.length);\n  } else {\n    after = selection.collapseToStart().move(lastText.length);\n  }\n\n  transform.select(after);\n};\n\n/**\n * Insert a `inline` at the current selection.\n *\n * @param {Transform} transform\n * @param {String|Object|Block} inline\n */\n\nTransforms.insertInline = function (transform, inline) {\n  inline = _normalize2.default.inline(inline);\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.insertInlineAtRange(selection, inline);\n\n  // If the node was successfully inserted, update the selection.\n  var node = transform.state.document.getNode(inline.key);\n  if (node) transform.collapseToEndOf(node);\n};\n\n/**\n * Insert a `text` string at the current selection.\n *\n * @param {Transform} transform\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nTransforms.insertText = function (transform, text, marks) {\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  marks = marks || selection.marks;\n  transform.insertTextAtRange(selection, text, marks);\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != transform.state.document) {\n    transform.select({ marks: null });\n  }\n};\n\n/**\n * Set `properties` of the block nodes in the current selection.\n *\n * @param {Transform} transform\n * @param {Object} properties\n */\n\nTransforms.setBlock = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.setBlockAtRange(selection, properties);\n};\n\n/**\n * Set `properties` of the inline nodes in the current selection.\n *\n * @param {Transform} transform\n * @param {Object} properties\n */\n\nTransforms.setInline = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.setInlineAtRange(selection, properties);\n};\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Transform} transform\n * @param {Number} depth (optional)\n */\n\nTransforms.splitBlock = function (transform) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.snapshotSelection().splitBlockAtRange(selection, depth).collapseToEnd().snapshotSelection();\n};\n\n/**\n * Split the inline nodes at the current selection, to optional `depth`.\n *\n * @param {Transform} transform\n * @param {Number} depth (optional)\n */\n\nTransforms.splitInline = function (transform) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.snapshotSelection().splitInlineAtRange(selection, depth).snapshotSelection();\n};\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Transform} transform\n * @param {Mark} mark\n */\n\nTransforms.removeMark = function (transform, mark) {\n  mark = _normalize2.default.mark(mark);\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n\n  if (selection.isExpanded) {\n    transform.removeMarkAtRange(selection, mark);\n    return;\n  }\n\n  if (selection.marks) {\n    var _marks2 = selection.marks.remove(mark);\n    var _sel2 = selection.set('marks', _marks2);\n    transform.select(_sel2);\n    return;\n  }\n\n  var marks = document.getMarksAtRange(selection).remove(mark);\n  var sel = selection.set('marks', marks);\n  transform.select(sel);\n};\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Transform} transform\n * @param {Mark} mark\n */\n\nTransforms.toggleMark = function (transform, mark) {\n  mark = _normalize2.default.mark(mark);\n  var state = transform.state;\n\n  var exists = state.marks.some(function (m) {\n    return m.equals(mark);\n  });\n\n  if (exists) {\n    transform.removeMark(mark);\n  } else {\n    transform.addMark(mark);\n  }\n};\n\n/**\n * Unwrap the current selection from a block parent with `properties`.\n *\n * @param {Transform} transform\n * @param {Object|String} properties\n */\n\nTransforms.unwrapBlock = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.unwrapBlockAtRange(selection, properties);\n};\n\n/**\n * Unwrap the current selection from an inline parent with `properties`.\n *\n * @param {Transform} transform\n * @param {Object|String} properties\n */\n\nTransforms.unwrapInline = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.unwrapInlineAtRange(selection, properties);\n};\n\n/**\n * Wrap the block nodes in the current selection with a new block node with\n * `properties`.\n *\n * @param {Transform} transform\n * @param {Object|String} properties\n */\n\nTransforms.wrapBlock = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.wrapBlockAtRange(selection, properties);\n};\n\n/**\n * Wrap the current selection in new inline nodes with `properties`.\n *\n * @param {Transform} transform\n * @param {Object|String} properties\n */\n\nTransforms.wrapInline = function (transform, properties) {\n  var state = transform.state;\n  var _state3 = state,\n      document = _state3.document,\n      selection = _state3.selection;\n\n  var after = void 0;\n\n  var startKey = selection.startKey;\n\n\n  transform.deselect();\n  transform.wrapInlineAtRange(selection, properties);\n  state = transform.state;\n  document = state.document;\n\n  // Determine what the selection should be after wrapping.\n  if (selection.isCollapsed) {\n    after = selection;\n  } else if (selection.startOffset == 0) {\n    // Find the inline that has been inserted.\n    // We want to handle multiple wrap, so we need to take the highest parent\n    var inline = document.getAncestors(startKey).find(function (parent) {\n      return parent.kind == 'inline' && parent.getOffset(startKey) == 0;\n    });\n\n    var start = inline ? document.getPreviousText(inline.getFirstText().key) : document.getFirstText();\n    var end = document.getNextText(inline ? inline.getLastText().key : start.key);\n\n    // Move selection to wrap around the inline\n    after = selection.moveAnchorToEndOf(start).moveFocusToStartOf(end);\n  } else if (selection.startKey == selection.endKey) {\n    var text = document.getNextText(selection.startKey);\n    after = selection.moveToRangeOf(text);\n  } else {\n    var anchor = document.getNextText(selection.anchorKey);\n    var focus = document.getDescendant(selection.focusKey);\n    after = selection.merge({\n      anchorKey: anchor.key,\n      anchorOffset: 0,\n      focusKey: focus.key,\n      focusOffset: selection.focusOffset\n    });\n  }\n\n  after = after.normalize(document);\n  transform.select(after);\n};\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Transform} transform\n * @param {String} prefix\n * @param {String} suffix\n */\n\nTransforms.wrapText = function (transform, prefix) {\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.wrapTextAtRange(selection, prefix, suffix);\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    transform.moveStart(0 - prefix.length);\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  transform.moveEnd(0 - suffix.length);\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != transform.state.selection.isForward) {\n    transform.flip();\n  }\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/at-current-range.js\n// module id = ./node_modules/slate/lib/transforms/at-current-range.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _string = require('../utils/string');\n\nvar _string2 = _interopRequireDefault(_string);\n\nvar _core = require('../schemas/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\n/* eslint no-console: 0 */\n\nvar Transforms = {};\n\n/**\n * An options object with normalize set to `false`.\n *\n * @type {Object}\n */\n\nvar OPTS = {\n  normalize: false\n};\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.addMarkAtRange = function (transform, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  var _options$normalize = options.normalize,\n      normalize = _options$normalize === undefined ? true : _options$normalize;\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n  var texts = document.getTextsAtRange(range);\n\n  texts.forEach(function (text) {\n    var key = text.key;\n\n    var index = 0;\n    var length = text.length;\n\n    if (key == startKey) index = startOffset;\n    if (key == endKey) length = endOffset;\n    if (key == startKey && key == endKey) length = endOffset - startOffset;\n\n    transform.addMarkByKey(key, index, length, mark, { normalize: normalize });\n  });\n};\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteAtRange = function (transform, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (range.isCollapsed) return;\n\n  var _options$normalize2 = options.normalize,\n      normalize = _options$normalize2 === undefined ? true : _options$normalize2;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n  // If the start and end key are the same, we can just remove text.\n\n  if (startKey == endKey) {\n    var index = startOffset;\n    var length = endOffset - startOffset;\n    transform.removeTextByKey(startKey, index, length, { normalize: normalize });\n    return;\n  }\n\n  // Split at the range edges within a common ancestor, without normalizing.\n  var state = transform.state;\n  var _state = state,\n      document = _state.document;\n\n  var ancestor = document.getCommonAncestor(startKey, endKey);\n  var startChild = ancestor.getFurthestAncestor(startKey);\n  var endChild = ancestor.getFurthestAncestor(endKey);\n  var startOff = (startChild.kind == 'text' ? 0 : startChild.getOffset(startKey)) + startOffset;\n  var endOff = (endChild.kind == 'text' ? 0 : endChild.getOffset(endKey)) + endOffset;\n\n  transform.splitNodeByKey(startChild.key, startOff, OPTS);\n  transform.splitNodeByKey(endChild.key, endOff, OPTS);\n\n  // Refresh variables.\n  state = transform.state;\n  document = state.document;\n  ancestor = document.getCommonAncestor(startKey, endKey);\n  startChild = ancestor.getFurthestAncestor(startKey);\n  endChild = ancestor.getFurthestAncestor(endKey);\n  var startIndex = ancestor.nodes.indexOf(startChild);\n  var endIndex = ancestor.nodes.indexOf(endChild);\n  var middles = ancestor.nodes.slice(startIndex + 1, endIndex + 1);\n\n  // Remove all of the middle nodes, between the splits.\n  if (middles.size) {\n    middles.forEach(function (child) {\n      transform.removeNodeByKey(child.key, OPTS);\n    });\n  }\n\n  // If the start and end block are different, move all of the nodes from the\n  // end block into the start block.\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(document.getNextText(endKey).key);\n\n  if (startBlock.key !== endBlock.key) {\n    endBlock.nodes.forEach(function (child, i) {\n      var newKey = startBlock.key;\n      var newIndex = startBlock.nodes.size + i;\n      transform.moveNodeByKey(child.key, newKey, newIndex, OPTS);\n    });\n\n    // Remove parents of endBlock as long as they have a single child\n    var lonely = document.getFurthestOnlyChildAncestor(endBlock.key) || endBlock;\n    transform.removeNodeByKey(lonely.key, OPTS);\n  }\n\n  if (normalize) {\n    transform.normalizeNodeByKey(ancestor.key, _core2.default);\n  }\n};\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteCharBackwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = _string2.default.getCharOffsetBackward(text, o);\n  transform.deleteBackwardAtRange(range, n, options);\n};\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteLineBackwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  transform.deleteBackwardAtRange(range, o, options);\n};\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteWordBackwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = _string2.default.getWordOffsetBackward(text, o);\n  transform.deleteBackwardAtRange(range, n, options);\n};\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteBackwardAtRange = function (transform, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize3 = options.normalize,\n      normalize = _options$normalize3 === undefined ? true : _options$normalize3;\n  var state = transform.state;\n  var document = state.document;\n  var _range = range,\n      startKey = _range.startKey,\n      focusOffset = _range.focusOffset;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  var block = document.getClosestBlock(startKey);\n  // If the closest block is void, delete it.\n  if (block && block.isVoid) {\n    transform.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n  // If the closest is not void, but empty, remove it\n  if (block && !block.isVoid && block.isEmpty && document.nodes.size !== 1) {\n    transform.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n\n  // If the closest inline is void, delete it.\n  var inline = document.getClosestInline(startKey);\n  if (inline && inline.isVoid) {\n    transform.removeNodeByKey(inline.key, { normalize: normalize });\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtStartOf(document)) {\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(startKey);\n  if (range.isAtStartOf(text)) {\n    var prev = document.getPreviousText(text.key);\n    var prevBlock = document.getClosestBlock(prev.key);\n    var prevInline = document.getClosestInline(prev.key);\n\n    // If the previous block is void, remove it.\n    if (prevBlock && prevBlock.isVoid) {\n      transform.removeNodeByKey(prevBlock.key, { normalize: normalize });\n      return;\n    }\n\n    // If the previous inline is void, remove it.\n    if (prevInline && prevInline.isVoid) {\n      transform.removeNodeByKey(prevInline.key, { normalize: normalize });\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to join the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.merge({\n        anchorKey: prev.key,\n        anchorOffset: prev.length\n      });\n\n      transform.deleteAtRange(range, { normalize: normalize });\n      return;\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset - n,\n      isBackward: true\n    });\n\n    transform.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  var node = text;\n  var offset = 0;\n  var traversed = focusOffset;\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key);\n    var next = traversed + node.length;\n    if (n <= next) {\n      offset = next - n;\n      break;\n    } else {\n      traversed = next;\n    }\n  }\n\n  // If the focus node is inside a void, go up until right after it.\n  if (document.hasVoidParent(node.key)) {\n    var parent = document.getClosestVoid(node.key);\n    node = document.getNextText(parent.key);\n    offset = 0;\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n    isBackward: true\n  });\n\n  transform.deleteAtRange(range, { normalize: normalize });\n};\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteCharForwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = _string2.default.getCharOffsetForward(text, o);\n  transform.deleteForwardAtRange(range, n, options);\n};\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteLineForwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  transform.deleteForwardAtRange(range, o, options);\n};\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteWordForwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = _string2.default.getWordOffsetForward(text, o);\n  transform.deleteForwardAtRange(range, n, options);\n};\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteForwardAtRange = function (transform, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize4 = options.normalize,\n      normalize = _options$normalize4 === undefined ? true : _options$normalize4;\n  var state = transform.state;\n  var document = state.document;\n  var _range2 = range,\n      startKey = _range2.startKey,\n      focusOffset = _range2.focusOffset;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  var block = document.getClosestBlock(startKey);\n  // If the closest block is void, delete it.\n  if (block && block.isVoid) {\n    transform.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n  // If the closest is not void, but empty, remove it\n  if (block && !block.isVoid && block.isEmpty && document.nodes.size !== 1) {\n    transform.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n\n  // If the closest inline is void, delete it.\n  var inline = document.getClosestInline(startKey);\n  if (inline && inline.isVoid) {\n    transform.removeNodeByKey(inline.key, { normalize: normalize });\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtEndOf(document)) {\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(startKey);\n  if (range.isAtEndOf(text)) {\n    var next = document.getNextText(text.key);\n    var nextBlock = document.getClosestBlock(next.key);\n    var nextInline = document.getClosestInline(next.key);\n\n    // If the previous block is void, remove it.\n    if (nextBlock && nextBlock.isVoid) {\n      transform.removeNodeByKey(nextBlock.key, { normalize: normalize });\n      return;\n    }\n\n    // If the previous inline is void, remove it.\n    if (nextInline && nextInline.isVoid) {\n      transform.removeNodeByKey(nextInline.key, { normalize: normalize });\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to join the two blocks together.\n    if (n == 1 && nextBlock != block) {\n      range = range.merge({\n        focusKey: next.key,\n        focusOffset: 0\n      });\n\n      transform.deleteAtRange(range, { normalize: normalize });\n      return;\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.length - focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset + n\n    });\n\n    transform.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  var node = text;\n  var offset = focusOffset;\n  var traversed = text.length - focusOffset;\n\n  while (n > traversed) {\n    node = document.getNextText(node.key);\n    var _next = traversed + node.length;\n    if (n <= _next) {\n      offset = n - traversed;\n      break;\n    } else {\n      traversed = _next;\n    }\n  }\n\n  // If the focus node is inside a void, go up until right before it.\n  if (document.hasVoidParent(node.key)) {\n    var parent = document.getClosestVoid(node.key);\n    node = document.getPreviousText(parent.key);\n    offset = node.length;\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset\n  });\n\n  transform.deleteAtRange(range, { normalize: normalize });\n};\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Block|String|Object} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertBlockAtRange = function (transform, range, block) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  block = _normalize2.default.block(block);\n  var _options$normalize5 = options.normalize,\n      normalize = _options$normalize5 === undefined ? true : _options$normalize5;\n\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range);\n    range = range.collapseToStart();\n  }\n\n  var state = transform.state;\n  var document = state.document;\n  var _range3 = range,\n      startKey = _range3.startKey,\n      startOffset = _range3.startOffset;\n\n  var startText = document.assertDescendant(startKey);\n  var startBlock = document.getClosestBlock(startKey);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n\n  if (startBlock.isVoid) {\n    transform.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  } else if (startBlock.isEmpty) {\n    transform.removeNodeByKey(startBlock.key);\n    transform.insertNodeByKey(parent.key, index, block, { normalize: normalize });\n  } else if (range.isAtStartOf(startBlock)) {\n    transform.insertNodeByKey(parent.key, index, block, { normalize: normalize });\n  } else if (range.isAtEndOf(startBlock)) {\n    transform.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  } else {\n    var offset = startBlock.getOffset(startText.key) + startOffset;\n    transform.splitNodeByKey(startBlock.key, offset, { normalize: normalize });\n    transform.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  }\n\n  if (normalize) {\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Document} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertFragmentAtRange = function (transform, range, fragment) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize6 = options.normalize,\n      normalize = _options$normalize6 === undefined ? true : _options$normalize6;\n\n  // If the range is expanded, delete it first.\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, OPTS);\n    range = range.collapseToStart();\n  }\n\n  // If the fragment is empty, there's nothing to do after deleting.\n  if (!fragment.nodes.size) return;\n\n  // Regenerate the keys for all of the fragments nodes, so that they're\n  // guaranteed not to collide with the existing keys in the document. Otherwise\n  // they will be rengerated automatically and we won't have an easy way to\n  // reference them.\n  fragment = fragment.mapDescendants(function (child) {\n    return child.regenerateKey();\n  });\n\n  // Calculate a few things...\n  var _range4 = range,\n      startKey = _range4.startKey,\n      startOffset = _range4.startOffset;\n  var state = transform.state;\n  var _state2 = state,\n      document = _state2.document;\n\n  var startText = document.getDescendant(startKey);\n  var startBlock = document.getClosestBlock(startText.key);\n  var startChild = startBlock.getFurthestAncestor(startText.key);\n  var isAtStart = range.isAtStartOf(startBlock);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n  var offset = startChild == startText ? startOffset : startChild.getOffset(startText.key) + startOffset;\n\n  var blocks = fragment.getBlocks();\n  var firstBlock = blocks.first();\n  var lastBlock = blocks.last();\n\n  // If the fragment only contains a void block, use `insertBlock` instead.\n  if (firstBlock == lastBlock && firstBlock.isVoid) {\n    transform.insertBlockAtRange(range, firstBlock, options);\n    return;\n  }\n\n  // If the first and last block aren't the same, we need to insert all of the\n  // nodes after the fragment's first block at the index.\n  if (firstBlock != lastBlock) {\n    var lonelyParent = fragment.getFurthest(firstBlock.key, function (p) {\n      return p.nodes.size == 1;\n    });\n    var lonelyChild = lonelyParent || firstBlock;\n    var startIndex = parent.nodes.indexOf(startBlock);\n    fragment = fragment.removeDescendant(lonelyChild.key);\n\n    fragment.nodes.forEach(function (node, i) {\n      var newIndex = startIndex + i + 1;\n      transform.insertNodeByKey(parent.key, newIndex, node, OPTS);\n    });\n  }\n\n  // Check if we need to split the node.\n  if (startOffset != 0) {\n    transform.splitNodeByKey(startChild.key, offset, OPTS);\n  }\n\n  // Update our variables with the new state.\n  state = transform.state;\n  document = state.document;\n  startText = document.getDescendant(startKey);\n  startBlock = document.getClosestBlock(startKey);\n  startChild = startBlock.getFurthestAncestor(startText.key);\n\n  // If the first and last block aren't the same, we need to move any of the\n  // starting block's children after the split into the last block of the\n  // fragment, which has already been inserted.\n  if (firstBlock != lastBlock) {\n    var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);\n    var nextNodes = nextChild ? startBlock.nodes.skipUntil(function (n) {\n      return n.key == nextChild.key;\n    }) : (0, _immutable.List)();\n    var lastIndex = lastBlock.nodes.size;\n\n    nextNodes.forEach(function (node, i) {\n      var newIndex = lastIndex + i;\n      transform.moveNodeByKey(node.key, lastBlock.key, newIndex, OPTS);\n    });\n  }\n\n  // If the starting block is empty, we replace it entirely with the first block\n  // of the fragment, since this leads to a more expected behavior for the user.\n  if (startBlock.isEmpty) {\n    transform.removeNodeByKey(startBlock.key, OPTS);\n    transform.insertNodeByKey(parent.key, index, firstBlock, OPTS);\n  }\n\n  // Otherwise, we maintain the starting block, and insert all of the first\n  // block's inline nodes into it at the split point.\n  else {\n      var inlineChild = startBlock.getFurthestAncestor(startText.key);\n      var inlineIndex = startBlock.nodes.indexOf(inlineChild);\n\n      firstBlock.nodes.forEach(function (inline, i) {\n        var o = startOffset == 0 ? 0 : 1;\n        var newIndex = inlineIndex + i + o;\n        transform.insertNodeByKey(startBlock.key, newIndex, inline, OPTS);\n      });\n    }\n\n  // Normalize if requested.\n  if (normalize) {\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Inline|String|Object} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertInlineAtRange = function (transform, range, inline) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize7 = options.normalize,\n      normalize = _options$normalize7 === undefined ? true : _options$normalize7;\n\n  inline = _normalize2.default.inline(inline);\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, OPTS);\n    range = range.collapseToStart();\n  }\n\n  var state = transform.state;\n  var document = state.document;\n  var _range5 = range,\n      startKey = _range5.startKey,\n      startOffset = _range5.startOffset;\n\n  var parent = document.getParent(startKey);\n  var startText = document.assertDescendant(startKey);\n  var index = parent.nodes.indexOf(startText);\n\n  if (parent.isVoid) return;\n\n  transform.splitNodeByKey(startKey, startOffset, OPTS);\n  transform.insertNodeByKey(parent.key, index + 1, inline, OPTS);\n\n  if (normalize) {\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertTextAtRange = function (transform, range, text, marks) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var normalize = options.normalize;\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var parent = document.getParent(startKey);\n\n  if (parent.isVoid) return;\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, OPTS);\n  }\n\n  // PERF: Unless specified, don't normalize if only inserting text.\n  if (normalize !== undefined) {\n    normalize = range.isExpanded;\n  }\n\n  transform.insertTextByKey(startKey, startOffset, text, marks, { normalize: normalize });\n};\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Mark|String} mark (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.removeMarkAtRange = function (transform, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  var _options$normalize8 = options.normalize,\n      normalize = _options$normalize8 === undefined ? true : _options$normalize8;\n  var state = transform.state;\n  var document = state.document;\n\n  var texts = document.getTextsAtRange(range);\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  texts.forEach(function (text) {\n    var key = text.key;\n\n    var index = 0;\n    var length = text.length;\n\n    if (key == startKey) index = startOffset;\n    if (key == endKey) length = endOffset;\n    if (key == startKey && key == endKey) length = endOffset - startOffset;\n\n    transform.removeMarkByKey(key, index, length, mark, { normalize: normalize });\n  });\n};\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.setBlockAtRange = function (transform, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize9 = options.normalize,\n      normalize = _options$normalize9 === undefined ? true : _options$normalize9;\n  var state = transform.state;\n  var document = state.document;\n\n  var blocks = document.getBlocksAtRange(range);\n\n  blocks.forEach(function (block) {\n    transform.setNodeByKey(block.key, properties, { normalize: normalize });\n  });\n};\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.setInlineAtRange = function (transform, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize10 = options.normalize,\n      normalize = _options$normalize10 === undefined ? true : _options$normalize10;\n  var state = transform.state;\n  var document = state.document;\n\n  var inlines = document.getInlinesAtRange(range);\n\n  inlines.forEach(function (inline) {\n    transform.setNodeByKey(inline.key, properties, { normalize: normalize });\n  });\n};\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.splitBlockAtRange = function (transform, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize11 = options.normalize,\n      normalize = _options$normalize11 === undefined ? true : _options$normalize11;\n\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, { normalize: normalize });\n    range = range.collapseToStart();\n  }\n\n  var _range6 = range,\n      startKey = _range6.startKey,\n      startOffset = _range6.startOffset;\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertDescendant(startKey);\n  var parent = document.getClosestBlock(node.key);\n  var offset = startOffset;\n  var h = 0;\n\n  while (parent && parent.kind == 'block' && h < height) {\n    offset += parent.getOffset(node.key);\n    node = parent;\n    parent = document.getClosestBlock(parent.key);\n    h++;\n  }\n\n  transform.splitNodeByKey(node.key, offset, { normalize: normalize });\n};\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.splitInlineAtRange = function (transform, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize12 = options.normalize,\n      normalize = _options$normalize12 === undefined ? true : _options$normalize12;\n\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, { normalize: normalize });\n    range = range.collapseToStart();\n  }\n\n  var _range7 = range,\n      startKey = _range7.startKey,\n      startOffset = _range7.startOffset;\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertDescendant(startKey);\n  var parent = document.getClosestInline(node.key);\n  var offset = startOffset;\n  var h = 0;\n\n  while (parent && parent.kind == 'inline' && h < height) {\n    offset += parent.getOffset(node.key);\n    node = parent;\n    parent = document.getClosestInline(parent.key);\n    h++;\n  }\n\n  transform.splitNodeByKey(node.key, offset, { normalize: normalize });\n};\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.toggleMarkAtRange = function (transform, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  mark = _normalize2.default.mark(mark);\n\n  var _options$normalize13 = options.normalize,\n      normalize = _options$normalize13 === undefined ? true : _options$normalize13;\n  var state = transform.state;\n  var document = state.document;\n\n  var marks = document.getMarksAtRange(range);\n  var exists = marks.some(function (m) {\n    return m.equals(mark);\n  });\n\n  if (exists) {\n    transform.removeMarkAtRange(range, mark, { normalize: normalize });\n  } else {\n    transform.addMarkAtRange(range, mark, { normalize: normalize });\n  }\n};\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapBlockAtRange = function (transform, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = _normalize2.default.nodeProperties(properties);\n\n  var _options$normalize14 = options.normalize,\n      normalize = _options$normalize14 === undefined ? true : _options$normalize14;\n  var state = transform.state;\n  var _state3 = state,\n      document = _state3.document;\n\n  var blocks = document.getBlocksAtRange(range);\n  var wrappers = blocks.map(function (block) {\n    return document.getClosest(block.key, function (parent) {\n      if (parent.kind != 'block') return false;\n      if (properties.type != null && parent.type != properties.type) return false;\n      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  wrappers.forEach(function (block) {\n    var first = block.nodes.first();\n    var last = block.nodes.last();\n    var parent = document.getParent(block.key);\n    var index = parent.nodes.indexOf(block);\n\n    var children = block.nodes.filter(function (child) {\n      return blocks.some(function (b) {\n        return child == b || child.hasDescendant(b.key);\n      });\n    });\n\n    var firstMatch = children.first();\n    var lastMatch = children.last();\n\n    if (first == firstMatch && last == lastMatch) {\n      block.nodes.forEach(function (child, i) {\n        transform.moveNodeByKey(child.key, parent.key, index + i, OPTS);\n      });\n\n      transform.removeNodeByKey(block.key, OPTS);\n    } else if (last == lastMatch) {\n      block.nodes.skipUntil(function (n) {\n        return n == firstMatch;\n      }).forEach(function (child, i) {\n        transform.moveNodeByKey(child.key, parent.key, index + 1 + i, OPTS);\n      });\n    } else if (first == firstMatch) {\n      block.nodes.takeUntil(function (n) {\n        return n == lastMatch;\n      }).push(lastMatch).forEach(function (child, i) {\n        transform.moveNodeByKey(child.key, parent.key, index + i, OPTS);\n      });\n    } else {\n      var offset = block.getOffset(firstMatch.key);\n\n      transform.splitNodeByKey(block.key, offset, OPTS);\n      state = transform.state;\n      document = state.document;\n\n      children.forEach(function (child, i) {\n        if (i == 0) {\n          var extra = child;\n          child = document.getNextBlock(child.key);\n          transform.removeNodeByKey(extra.key, OPTS);\n        }\n\n        transform.moveNodeByKey(child.key, parent.key, index + 1 + i, OPTS);\n      });\n    }\n  });\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    transform.normalizeDocument(_core2.default);\n  }\n};\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapInlineAtRange = function (transform, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = _normalize2.default.nodeProperties(properties);\n\n  var _options$normalize15 = options.normalize,\n      normalize = _options$normalize15 === undefined ? true : _options$normalize15;\n  var state = transform.state;\n  var document = state.document;\n\n  var texts = document.getTextsAtRange(range);\n  var inlines = texts.map(function (text) {\n    return document.getClosest(text.key, function (parent) {\n      if (parent.kind != 'inline') return false;\n      if (properties.type != null && parent.type != properties.type) return false;\n      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  inlines.forEach(function (inline) {\n    var parent = transform.state.document.getParent(inline.key);\n    var index = parent.nodes.indexOf(inline);\n\n    inline.nodes.forEach(function (child, i) {\n      transform.moveNodeByKey(child.key, parent.key, index + i, OPTS);\n    });\n  });\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    transform.normalizeDocument(_core2.default);\n  }\n};\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Block|Object|String} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapBlockAtRange = function (transform, range, block) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  block = _normalize2.default.block(block);\n  block = block.set('nodes', block.nodes.clear());\n\n  var _options$normalize16 = options.normalize,\n      normalize = _options$normalize16 === undefined ? true : _options$normalize16;\n  var state = transform.state;\n  var document = state.document;\n\n\n  var blocks = document.getBlocksAtRange(range);\n  var firstblock = blocks.first();\n  var lastblock = blocks.last();\n  var parent = void 0,\n      siblings = void 0,\n      index = void 0;\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key);\n    siblings = blocks;\n  }\n\n  // Determine closest shared parent to all blocks in selection.\n  else {\n      parent = document.getClosest(firstblock.key, function (p1) {\n        return !!document.getClosest(lastblock.key, function (p2) {\n          return p1 == p2;\n        });\n      });\n    }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document;\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    var indexes = parent.nodes.reduce(function (ind, node, i) {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i;\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i;\n      return ind;\n    }, []);\n\n    index = indexes[0];\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first());\n  }\n\n  // Inject the new block node into the parent.\n  transform.insertNodeByKey(parent.key, index, block, OPTS);\n\n  // Move the sibling nodes into the new block node.\n  siblings.forEach(function (node, i) {\n    transform.moveNodeByKey(node.key, block.key, i, OPTS);\n  });\n\n  if (normalize) {\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Inline|Object|String} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapInlineAtRange = function (transform, range, inline) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var state = transform.state;\n  var _state4 = state,\n      document = _state4.document;\n  var _options$normalize17 = options.normalize,\n      normalize = _options$normalize17 === undefined ? true : _options$normalize17;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    var inlineParent = document.getClosestInline(startKey);\n    if (!inlineParent.isVoid) {\n      return;\n    }\n\n    return transform.wrapInlineByKey(inlineParent.key, inline, options);\n  }\n\n  inline = _normalize2.default.inline(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n\n  var blocks = document.getBlocksAtRange(range);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey);\n  var startChild = startBlock.getFurthestAncestor(startKey);\n  var endChild = endBlock.getFurthestAncestor(endKey);\n  var startIndex = startBlock.nodes.indexOf(startChild);\n  var endIndex = endBlock.nodes.indexOf(endChild);\n\n  var startOff = startChild.key == startKey ? startOffset : startChild.getOffset(startKey) + startOffset;\n\n  var endOff = endChild.key == endKey ? endOffset : endChild.getOffset(endKey) + endOffset;\n\n  if (startBlock == endBlock) {\n    if (endOff != endChild.length) {\n      transform.splitNodeByKey(endChild.key, endOff, OPTS);\n    }\n\n    if (startOff != 0) {\n      transform.splitNodeByKey(startChild.key, startOff, OPTS);\n    }\n\n    state = transform.state;\n    document = state.document;\n    startBlock = document.getClosestBlock(startKey);\n    startChild = startBlock.getFurthestAncestor(startKey);\n\n    var startInner = startOff == 0 ? startChild : document.getNextSibling(startChild.key);\n\n    var startInnerIndex = startBlock.nodes.indexOf(startInner);\n\n    var endInner = startKey == endKey ? startInner : startBlock.getFurthestAncestor(endKey);\n    var inlines = startBlock.nodes.skipUntil(function (n) {\n      return n == startInner;\n    }).takeUntil(function (n) {\n      return n == endInner;\n    }).push(endInner);\n\n    var node = inline.regenerateKey();\n\n    transform.insertNodeByKey(startBlock.key, startInnerIndex, node, OPTS);\n\n    inlines.forEach(function (child, i) {\n      transform.moveNodeByKey(child.key, node.key, i, OPTS);\n    });\n\n    if (normalize) {\n      transform.normalizeNodeByKey(startBlock.key, _core2.default);\n    }\n  } else {\n    transform.splitNodeByKey(startChild.key, startOff, OPTS);\n    transform.splitNodeByKey(endChild.key, endOff, OPTS);\n\n    state = transform.state;\n    document = state.document;\n    startBlock = document.getDescendant(startBlock.key);\n    endBlock = document.getDescendant(endBlock.key);\n\n    var startInlines = startBlock.nodes.slice(startIndex + 1);\n    var endInlines = endBlock.nodes.slice(0, endIndex + 1);\n    var startNode = inline.regenerateKey();\n    var endNode = inline.regenerateKey();\n\n    transform.insertNodeByKey(startBlock.key, startIndex - 1, startNode, OPTS);\n    transform.insertNodeByKey(endBlock.key, endIndex, endNode, OPTS);\n\n    startInlines.forEach(function (child, i) {\n      transform.moveNodeByKey(child.key, startNode.key, i, OPTS);\n    });\n\n    endInlines.forEach(function (child, i) {\n      transform.moveNodeByKey(child.key, endNode.key, i, OPTS);\n    });\n\n    if (normalize) {\n      transform.normalizeNodeByKey(startBlock.key, _core2.default).normalizeNodeByKey(endBlock.key, _core2.default);\n    }\n\n    blocks.slice(1, -1).forEach(function (block) {\n      var node = inline.regenerateKey();\n      transform.insertNodeByKey(block.key, 0, node, OPTS);\n\n      block.nodes.forEach(function (child, i) {\n        transform.moveNodeByKey(child.key, node.key, i, OPTS);\n      });\n\n      if (normalize) {\n        transform.normalizeNodeByKey(block.key, _core2.default);\n      }\n    });\n  }\n};\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapTextAtRange = function (transform, range, prefix) {\n  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prefix;\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var _options$normalize18 = options.normalize,\n      normalize = _options$normalize18 === undefined ? true : _options$normalize18;\n  var startKey = range.startKey,\n      endKey = range.endKey;\n\n  var start = range.collapseToStart();\n  var end = range.collapseToEnd();\n\n  if (startKey == endKey) {\n    end = end.move(prefix.length);\n  }\n\n  transform.insertTextAtRange(start, prefix, [], { normalize: normalize });\n  transform.insertTextAtRange(end, suffix, [], { normalize: normalize });\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/at-range.js\n// module id = ./node_modules/slate/lib/transforms/at-range.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _core = require('../schemas/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Add mark to text at `offset` and `length` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.addMarkByKey = function (transform, key, offset, length, mark) {\n  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  mark = _normalize2.default.mark(mark);\n  var _options$normalize = options.normalize,\n      normalize = _options$normalize === undefined ? true : _options$normalize;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.addMarkOperation(path, offset, length, mark);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Insert a `node` at `index` in a node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} index\n * @param {Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertNodeByKey = function (transform, key, index, node) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var _options$normalize2 = options.normalize,\n      normalize = _options$normalize2 === undefined ? true : _options$normalize2;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.insertNodeOperation(path, index, node);\n\n  if (normalize) {\n    transform.normalizeNodeByKey(key, _core2.default);\n  }\n};\n\n/**\n * Insert `text` at `offset` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertTextByKey = function (transform, key, offset, text, marks) {\n  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var _options$normalize3 = options.normalize,\n      normalize = _options$normalize3 === undefined ? true : _options$normalize3;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.insertTextOperation(path, offset, text, marks);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Join a node by `key` with a node `withKey`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {String} withKey\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.joinNodeByKey = function (transform, key, withKey) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize4 = options.normalize,\n      normalize = _options$normalize4 === undefined ? true : _options$normalize4;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n  var withPath = document.getPath(withKey);\n\n  transform.joinNodeOperation(path, withPath);\n\n  if (normalize) {\n    var parent = document.getCommonAncestor(key, withKey);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Move a node by `key` to a new parent by `newKey` and `index`.\n * `newKey` is the key of the container (it can be the document itself)\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {String} newKey\n * @param {Number} index\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.moveNodeByKey = function (transform, key, newKey, newIndex) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var _options$normalize5 = options.normalize,\n      normalize = _options$normalize5 === undefined ? true : _options$normalize5;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n  var newPath = document.getPath(newKey);\n\n  transform.moveNodeOperation(path, newPath, newIndex);\n\n  if (normalize) {\n    var parent = document.getCommonAncestor(key, newKey);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Remove mark from text at `offset` and `length` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.removeMarkByKey = function (transform, key, offset, length, mark) {\n  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  mark = _normalize2.default.mark(mark);\n  var _options$normalize6 = options.normalize,\n      normalize = _options$normalize6 === undefined ? true : _options$normalize6;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.removeMarkOperation(path, offset, length, mark);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Remove a node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.removeNodeByKey = function (transform, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$normalize7 = options.normalize,\n      normalize = _options$normalize7 === undefined ? true : _options$normalize7;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.removeNodeOperation(path);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Remove text at `offset` and `length` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.removeTextByKey = function (transform, key, offset, length) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var _options$normalize8 = options.normalize,\n      normalize = _options$normalize8 === undefined ? true : _options$normalize8;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.removeTextOperation(path, offset, length);\n\n  if (normalize) {\n    var block = document.getClosestBlock(key);\n    transform.normalizeNodeByKey(block.key, _core2.default);\n  }\n};\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.setMarkByKey = function (transform, key, offset, length, mark, properties) {\n  var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n  mark = _normalize2.default.mark(mark);\n  properties = _normalize2.default.markProperties(properties);\n  var _options$normalize9 = options.normalize,\n      normalize = _options$normalize9 === undefined ? true : _options$normalize9;\n\n  var newMark = mark.merge(properties);\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.setMarkOperation(path, offset, length, mark, newMark);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Set `properties` on a node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.setNodeByKey = function (transform, key, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = _normalize2.default.nodeProperties(properties);\n  var _options$normalize10 = options.normalize,\n      normalize = _options$normalize10 === undefined ? true : _options$normalize10;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.setNodeOperation(path, properties);\n\n  if (normalize) {\n    var node = key === document.key ? document : document.getParent(key);\n    transform.normalizeNodeByKey(node.key, _core2.default);\n  }\n};\n\n/**\n * Split a node by `key` at `offset`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.splitNodeByKey = function (transform, key, offset) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize11 = options.normalize,\n      normalize = _options$normalize11 === undefined ? true : _options$normalize11;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.splitNodeAtOffsetOperation(path, offset);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapInlineByKey = function (transform, key, properties, options) {\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  var node = document.assertDescendant(key);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOf(first, last);\n  transform.unwrapInlineAtRange(range, properties, options);\n};\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapBlockByKey = function (transform, key, properties, options) {\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  var node = document.assertDescendant(key);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOf(first, last);\n  transform.unwrapBlockAtRange(range, properties, options);\n};\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapNodeByKey = function (transform, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$normalize12 = options.normalize,\n      normalize = _options$normalize12 === undefined ? true : _options$normalize12;\n  var state = transform.state;\n  var document = state.document;\n\n  var parent = document.getParent(key);\n  var node = parent.getChild(key);\n\n  var index = parent.nodes.indexOf(node);\n  var isFirst = index === 0;\n  var isLast = index === parent.nodes.size - 1;\n\n  var parentParent = document.getParent(parent.key);\n  var parentIndex = parentParent.nodes.indexOf(parent);\n\n  if (parent.nodes.size === 1) {\n    transform.moveNodeByKey(key, parentParent.key, parentIndex, { normalize: false });\n    transform.removeNodeByKey(parent.key, options);\n  } else if (isFirst) {\n    // Just move the node before its parent.\n    transform.moveNodeByKey(key, parentParent.key, parentIndex, options);\n  } else if (isLast) {\n    // Just move the node after its parent.\n    transform.moveNodeByKey(key, parentParent.key, parentIndex + 1, options);\n  } else {\n    var parentPath = document.getPath(parent.key);\n    // Split the parent.\n    transform.splitNodeOperation(parentPath, index);\n    // Extract the node in between the splitted parent.\n    transform.moveNodeByKey(key, parentParent.key, parentIndex + 1, { normalize: false });\n\n    if (normalize) {\n      transform.normalizeNodeByKey(parentParent.key, _core2.default);\n    }\n  }\n};\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Transform} transform\n * @param {String} key The node to wrap\n * @param {Block|Object|String} inline The wrapping inline (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapInlineByKey = function (transform, key, inline, options) {\n  inline = _normalize2.default.inline(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n\n  var document = transform.state.document;\n\n  var node = document.assertDescendant(key);\n  var parent = document.getParent(node.key);\n  var index = parent.nodes.indexOf(node);\n\n  transform.insertNodeByKey(parent.key, index, inline, { normalize: false });\n  transform.moveNodeByKey(node.key, inline.key, 0, options);\n};\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Transform} transform\n * @param {String} key The node to wrap\n * @param {Block|Object|String} block The wrapping block (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapBlockByKey = function (transform, key, block, options) {\n  block = _normalize2.default.block(block);\n  block = block.set('nodes', block.nodes.clear());\n\n  var document = transform.state.document;\n\n  var node = document.assertDescendant(key);\n  var parent = document.getParent(node.key);\n  var index = parent.nodes.indexOf(node);\n\n  transform.insertNodeByKey(parent.key, index, block, { normalize: false });\n  transform.moveNodeByKey(node.key, block.key, 0, options);\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/by-key.js\n// module id = ./node_modules/slate/lib/transforms/by-key.js\n// module chunks = 0 2","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Call a `fn` as if it was a core transform. This is a convenience method to\n * make using non-core transforms easier to read and chain.\n *\n * @param {Transform} transform\n * @param {Function} fn\n * @param {Mixed} ...args\n */\n\nTransforms.call = function (transform, fn) {\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  fn.apply(undefined, [transform].concat(args));\n  return;\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/call.js\n// module id = ./node_modules/slate/lib/transforms/call.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _applyOperation = require('./apply-operation');\n\nvar _applyOperation2 = _interopRequireDefault(_applyOperation);\n\nvar _atCurrentRange = require('./at-current-range');\n\nvar _atCurrentRange2 = _interopRequireDefault(_atCurrentRange);\n\nvar _atRange = require('./at-range');\n\nvar _atRange2 = _interopRequireDefault(_atRange);\n\nvar _byKey = require('./by-key');\n\nvar _byKey2 = _interopRequireDefault(_byKey);\n\nvar _call = require('./call');\n\nvar _call2 = _interopRequireDefault(_call);\n\nvar _normalize = require('./normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _onHistory = require('./on-history');\n\nvar _onHistory2 = _interopRequireDefault(_onHistory);\n\nvar _onSelection = require('./on-selection');\n\nvar _onSelection2 = _interopRequireDefault(_onSelection);\n\nvar _operations = require('./operations');\n\nvar _operations2 = _interopRequireDefault(_operations);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = _extends({}, _applyOperation2.default, _atCurrentRange2.default, _atRange2.default, _byKey2.default, _call2.default, _normalize2.default, _onHistory2.default, _onSelection2.default, _operations2.default);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/index.js\n// module id = ./node_modules/slate/lib/transforms/index.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _schema = require('../models/schema');\n\nvar _schema2 = _interopRequireDefault(_schema);\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Normalize the document and selection with a `schema`.\n *\n * @param {Transform} transform\n * @param {Schema} schema\n */\n\nTransforms.normalize = function (transform, schema) {\n  transform.normalizeDocument(schema);\n  transform.normalizeSelection(schema);\n};\n\n/**\n * Normalize the document with a `schema`.\n *\n * @param {Transform} transform\n * @param {Schema} schema\n */\n\nTransforms.normalizeDocument = function (transform, schema) {\n  var state = transform.state;\n  var document = state.document;\n\n  transform.normalizeNodeByKey(document.key, schema);\n};\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Transform} transform\n * @param {Node|String} key\n * @param {Schema} schema\n */\n\nTransforms.normalizeNodeByKey = function (transform, key, schema) {\n  assertSchema(schema);\n\n  // If the schema has no validation rules, there's nothing to normalize.\n  if (!schema.hasValidators) return;\n\n  key = _normalize2.default.key(key);\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertNode(key);\n\n  normalizeNodeAndChildren(transform, node, schema);\n};\n\n/**\n * Normalize the selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.normalizeSelection = function (transform) {\n  var state = transform.state;\n  var _state = state,\n      document = _state.document,\n      selection = _state.selection;\n\n  // If document is empty, return\n\n  if (document.nodes.size === 0) {\n    return;\n  }\n\n  selection = selection.normalize(document);\n\n  // If the selection is unset, or the anchor or focus key in the selection are\n  // pointing to nodes that no longer exist, warn (if not unset) and reset the selection.\n  if (selection.isUnset || !document.hasDescendant(selection.anchorKey) || !document.hasDescendant(selection.focusKey)) {\n    if (!selection.isUnset) {\n      (0, _warn2.default)('The selection was invalid and was reset to start of the document. The selection in question was:', selection);\n    }\n\n    var firstText = document.getFirstText();\n    selection = selection.merge({\n      anchorKey: firstText.key,\n      anchorOffset: 0,\n      focusKey: firstText.key,\n      focusOffset: 0,\n      isBackward: false\n    });\n  }\n\n  state = state.set('selection', selection);\n  transform.state = state;\n};\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Transform} transform\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNodeAndChildren(transform, node, schema) {\n  if (node.kind == 'text') {\n    normalizeNode(transform, node, schema);\n    return;\n  }\n\n  // We can't just loop the children and normalize them, because in the process\n  // of normalizing one child, we might end up creating another. Instead, we\n  // have to normalize one at a time, and check for new children along the way.\n  // PERF: use a mutable array here instead of an immutable stack.\n  var keys = node.nodes.toArray().map(function (n) {\n    return n.key;\n  });\n\n  // While there is still a child key that hasn't been normalized yet...\n\n  var _loop = function _loop() {\n    var ops = transform.operations.length;\n    var key = void 0;\n\n    // PERF: use a mutable set here since we'll be add to it a lot.\n    var set = new _immutable.Set().asMutable();\n\n    // Unwind the stack, normalizing every child and adding it to the set.\n    while (key = keys[0]) {\n      var child = node.getChild(key);\n      normalizeNodeAndChildren(transform, child, schema);\n      set.add(key);\n      keys.shift();\n    }\n\n    // Turn the set immutable to be able to compare against it.\n    set = set.asImmutable();\n\n    // PERF: Only re-find the node and re-normalize any new children if\n    // operations occured that might have changed it.\n    if (transform.operations.length != ops) {\n      node = refindNode(transform, node);\n\n      // Add any new children back onto the stack.\n      node.nodes.forEach(function (n) {\n        if (set.has(n.key)) return;\n        keys.unshift(n.key);\n      });\n    }\n  };\n\n  while (keys.length) {\n    _loop();\n  }\n\n  // Normalize the node itself if it still exists.\n  if (node) {\n    normalizeNode(transform, node, schema);\n  }\n}\n\n/**\n * Re-find a reference to a node that may have been modified or removed\n * entirely by a transform.\n *\n * @param {Transform} transform\n * @param {Node} node\n * @return {Node}\n */\n\nfunction refindNode(transform, node) {\n  var state = transform.state;\n  var document = state.document;\n\n  return node.kind == 'document' ? document : document.getDescendant(node.key);\n}\n\n/**\n * Normalize a `node` with a `schema`, but not its children.\n *\n * @param {Transform} transform\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNode(transform, node, schema) {\n  var max = schema.rules.length;\n  var iterations = 0;\n\n  function iterate(t, n) {\n    var failure = n.validate(schema);\n    if (!failure) return;\n\n    // Run the `normalize` function for the rule with the invalid value.\n    var value = failure.value,\n        rule = failure.rule;\n\n    rule.normalize(t, n, value);\n\n    // Re-find the node reference, in case it was updated. If the node no longer\n    // exists, we're done for this branch.\n    n = refindNode(t, n);\n    if (!n) return;\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `validate` or\n    // `normalize` function of a schema rule to be written incorrectly and for\n    // an infinite invalid loop to occur.\n    iterations++;\n\n    if (iterations > max) {\n      throw new Error('A schema rule could not be validated after sufficient iterations. This is usually due to a `rule.validate` or `rule.normalize` function of a schema being incorrectly written, causing an infinite loop.');\n    }\n\n    // Otherwise, iterate again.\n    iterate(t, n);\n  }\n\n  iterate(transform, node);\n}\n\n/**\n * Assert that a `schema` exists.\n *\n * @param {Schema} schema\n */\n\nfunction assertSchema(schema) {\n  if (_schema2.default.isSchema(schema)) {\n    return;\n  } else if (schema == null) {\n    throw new Error('You must pass a `schema` object.');\n  } else {\n    throw new Error('You passed an invalid `schema` object: ' + schema + '.');\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/normalize.js\n// module id = ./node_modules/slate/lib/transforms/normalize.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Redo to the next state in the history.\n *\n * @param {Transform} transform\n */\n\nTransforms.redo = function (transform) {\n  var state = transform.state;\n  var _state = state,\n      history = _state.history;\n  var _history = history,\n      undos = _history.undos,\n      redos = _history.redos;\n\n  // If there's no next snapshot, abort.\n\n  var next = redos.peek();\n  if (!next) return;\n\n  // Shift the next state into the undo stack.\n  redos = redos.pop();\n  undos = undos.push(next);\n\n  // Replay the next operations.\n  next.forEach(function (op) {\n    transform.applyOperation(op);\n  });\n\n  // Update the history.\n  state = transform.state;\n  history = history.set('undos', undos).set('redos', redos);\n  state = state.set('history', history);\n\n  // Update the transform.\n  transform.state = state;\n};\n\n/**\n * Save the operations into the history.\n *\n * @param {Transform} transform\n * @param {Object} options\n */\n\nTransforms.save = function (transform) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$merge = options.merge,\n      merge = _options$merge === undefined ? false : _options$merge;\n  var state = transform.state,\n      operations = transform.operations;\n  var _state2 = state,\n      history = _state2.history;\n  var _history2 = history,\n      undos = _history2.undos,\n      redos = _history2.redos;\n\n  var previous = undos.peek();\n\n  // If there are no operations, abort.\n  if (!operations.length) return;\n\n  // Create a new save point or merge the operations into the previous one.\n  if (merge && previous) {\n    undos = undos.pop();\n    previous = previous.concat(operations);\n    undos = undos.push(previous);\n  } else {\n    undos = undos.push(operations);\n  }\n\n  // Clear the redo stack and constrain the undos stack.\n  if (undos.size > 100) undos = undos.take(100);\n  redos = redos.clear();\n\n  // Update the state.\n  history = history.set('undos', undos).set('redos', redos);\n  state = state.set('history', history);\n\n  // Update the transform.\n  transform.state = state;\n};\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Transform} transform\n */\n\nTransforms.undo = function (transform) {\n  var state = transform.state;\n  var _state3 = state,\n      history = _state3.history;\n  var _history3 = history,\n      undos = _history3.undos,\n      redos = _history3.redos;\n\n  // If there's no previous snapshot, abort.\n\n  var previous = undos.peek();\n  if (!previous) return;\n\n  // Shift the previous operations into the redo stack.\n  undos = undos.pop();\n  redos = redos.push(previous);\n\n  // Replay the inverse of the previous operations.\n  previous.slice().reverse().forEach(function (op) {\n    op.inverse.forEach(function (inv) {\n      transform.applyOperation(inv);\n    });\n  });\n\n  // Update the history.\n  state = transform.state;\n  history = history.set('undos', undos).set('redos', redos);\n  state = state.set('history', history);\n\n  // Update the transform.\n  transform.state = state;\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/on-history.js\n// module id = ./node_modules/slate/lib/transforms/on-history.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Transform} transform\n * @param {Object} properties\n */\n\nTransforms.select = function (transform, properties) {\n  transform.setSelectionOperation(properties);\n};\n\n/**\n * Selects the whole selection.\n *\n * @param {Transform} transform\n * @param {Object} properties\n */\n\nTransforms.selectAll = function (transform) {\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  var next = selection.moveToRangeOf(document);\n  transform.setSelectionOperation(next);\n};\n\n/**\n * Snapshot the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.snapshotSelection = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.setSelectionOperation(selection, { snapshot: true });\n};\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Mixed} ...args\n * @param {Transform} transform\n */\n\nTransforms.moveTo = function (transform, properties) {\n  (0, _warn2.default)('The `moveTo()` transform is deprecated, please use `select()` instead.');\n  transform.select(properties);\n};\n\n/**\n * Unset the selection's marks.\n *\n * @param {Transform} transform\n */\n\nTransforms.unsetMarks = function (transform) {\n  (0, _warn2.default)('The `unsetMarks()` transform is deprecated.');\n  transform.setSelectionOperation({ marks: null });\n};\n\n/**\n * Unset the selection, removing an association to a node.\n *\n * @param {Transform} transform\n */\n\nTransforms.unsetSelection = function (transform) {\n  (0, _warn2.default)('The `unsetSelection()` transform is deprecated, please use `deselect()` instead.');\n  transform.setSelectionOperation({\n    anchorKey: null,\n    anchorOffset: 0,\n    focusKey: null,\n    focusOffset: 0,\n    isFocused: false,\n    isBackward: false\n  });\n};\n\n/**\n * Mix in selection transforms that are just a proxy for the selection method.\n */\n\nvar PROXY_TRANSFORMS = ['blur', 'collapseTo', 'collapseToAnchor', 'collapseToEnd', 'collapseToEndOf', 'collapseToFocus', 'collapseToStart', 'collapseToStartOf', 'extend', 'extendTo', 'extendToEndOf', 'extendToStartOf', 'flip', 'focus', 'move', 'moveAnchor', 'moveAnchorOffsetTo', 'moveAnchorTo', 'moveAnchorToEndOf', 'moveAnchorToStartOf', 'moveEnd', 'moveEndOffsetTo', 'moveEndTo', 'moveFocus', 'moveFocusOffsetTo', 'moveFocusTo', 'moveFocusToEndOf', 'moveFocusToStartOf', 'moveOffsetsTo', 'moveStart', 'moveStartOffsetTo', 'moveStartTo',\n// 'moveTo', Commented out for now, since it conflicts with a deprecated one.\n'moveToEnd', 'moveToEndOf', 'moveToRangeOf', 'moveToStart', 'moveToStartOf', 'deselect'];\n\nPROXY_TRANSFORMS.forEach(function (method) {\n  Transforms[method] = function (transform) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var normalize = method != 'deselect';\n    var state = transform.state;\n    var document = state.document,\n        selection = state.selection;\n\n    var next = selection[method].apply(selection, args);\n    if (normalize) next = next.normalize(document);\n    transform.setSelectionOperation(next);\n  };\n});\n\n/**\n * Mix in node-related transforms.\n */\n\nvar PREFIXES = ['moveTo', 'collapseTo', 'extendTo'];\n\nvar DIRECTIONS = ['Next', 'Previous'];\n\nvar KINDS = ['Block', 'Inline', 'Text'];\n\nPREFIXES.forEach(function (prefix) {\n  var edges = ['Start', 'End'];\n\n  if (prefix == 'moveTo') {\n    edges.push('Range');\n  }\n\n  edges.forEach(function (edge) {\n    DIRECTIONS.forEach(function (direction) {\n      KINDS.forEach(function (kind) {\n        var get = 'get' + direction + kind;\n        var getAtRange = 'get' + kind + 'sAtRange';\n        var index = direction == 'Next' ? 'last' : 'first';\n        var method = '' + prefix + edge + 'Of';\n        var name = '' + method + direction + kind;\n\n        Transforms[name] = function (transform) {\n          var state = transform.state;\n          var document = state.document,\n              selection = state.selection;\n\n          var nodes = document[getAtRange](selection);\n          var node = nodes[index]();\n          var target = document[get](node.key);\n          if (!target) return;\n          var next = selection[method](target);\n          transform.setSelectionOperation(next);\n        };\n      });\n    });\n  });\n});\n\n/**\n * Mix in deprecated transforms with a warning.\n */\n\nvar DEPRECATED_TRANSFORMS = [['extendBackward', 'extend', 'The `extendBackward(n)` transform is deprecated, please use `extend(n)` instead with a negative offset.'], ['extendForward', 'extend', 'The `extendForward(n)` transform is deprecated, please use `extend(n)` instead.'], ['moveBackward', 'move', 'The `moveBackward(n)` transform is deprecated, please use `move(n)` instead with a negative offset.'], ['moveForward', 'move', 'The `moveForward(n)` transform is deprecated, please use `move(n)` instead.'], ['moveStartOffset', 'moveStart', 'The `moveStartOffset(n)` transform is deprecated, please use `moveStart(n)` instead.'], ['moveEndOffset', 'moveEnd', 'The `moveEndOffset(n)` transform is deprecated, please use `moveEnd()` instead.'], ['moveToOffsets', 'moveOffsetsTo', 'The `moveToOffsets()` transform is deprecated, please use `moveOffsetsTo()` instead.'], ['flipSelection', 'flip', 'The `flipSelection()` transform is deprecated, please use `flip()` instead.']];\n\nDEPRECATED_TRANSFORMS.forEach(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      old = _ref2[0],\n      current = _ref2[1],\n      warning = _ref2[2];\n\n  Transforms[old] = function (transform) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    (0, _warn2.default)(warning);\n    var state = transform.state;\n    var document = state.document,\n        selection = state.selection;\n\n    var sel = selection[current].apply(selection, args).normalize(document);\n    transform.setSelectionOperation(sel);\n  };\n});\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/on-selection.js\n// module id = ./node_modules/slate/lib/transforms/on-selection.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n */\n\nTransforms.addMarkOperation = function (transform, path, offset, length, mark) {\n  var inverse = [{\n    type: 'remove_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark\n  }];\n\n  var operation = {\n    type: 'add_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n */\n\nTransforms.insertNodeOperation = function (transform, path, index, node) {\n  var inversePath = path.slice().concat([index]);\n  var inverse = [{\n    type: 'remove_node',\n    path: inversePath\n  }];\n\n  var operation = {\n    type: 'insert_node',\n    path: path,\n    index: index,\n    node: node,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nTransforms.insertTextOperation = function (transform, path, offset, text, marks) {\n  var inverseLength = text.length;\n  var inverse = [{\n    type: 'remove_text',\n    path: path,\n    offset: offset,\n    length: inverseLength\n  }];\n\n  var operation = {\n    type: 'insert_text',\n    path: path,\n    offset: offset,\n    text: text,\n    marks: marks,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Join a node by `path` with a node `withPath`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Array} withPath\n */\n\nTransforms.joinNodeOperation = function (transform, path, withPath) {\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertPath(withPath);\n\n  var inverse = void 0;\n  if (node.kind === 'text') {\n    var offset = node.length;\n\n    inverse = [{\n      type: 'split_node',\n      path: withPath,\n      offset: offset\n    }];\n  } else {\n    // The number of children after which we split\n    var count = node.nodes.count();\n\n    inverse = [{\n      type: 'split_node',\n      path: withPath,\n      count: count\n    }];\n  }\n\n  var operation = {\n    type: 'join_node',\n    path: path,\n    withPath: withPath,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Move a node by `path` to a `newPath` and `newIndex`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Array} newPath\n * @param {Number} newIndex\n */\n\nTransforms.moveNodeOperation = function (transform, path, newPath, newIndex) {\n  var parentPath = path.slice(0, -1);\n  var parentIndex = path[path.length - 1];\n  var inversePath = newPath.slice().concat([newIndex]);\n\n  var inverse = [{\n    type: 'move_node',\n    path: inversePath,\n    newPath: parentPath,\n    newIndex: parentIndex\n  }];\n\n  var operation = {\n    type: 'move_node',\n    path: path,\n    newPath: newPath,\n    newIndex: newIndex,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\nTransforms.removeMarkOperation = function (transform, path, offset, length, mark) {\n  var inverse = [{\n    type: 'add_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark\n  }];\n\n  var operation = {\n    type: 'remove_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Remove a node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n */\n\nTransforms.removeNodeOperation = function (transform, path) {\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertPath(path);\n  var inversePath = path.slice(0, -1);\n  var inverseIndex = path[path.length - 1];\n\n  var inverse = [{\n    type: 'insert_node',\n    path: inversePath,\n    index: inverseIndex,\n    node: node\n  }];\n\n  var operation = {\n    type: 'remove_node',\n    path: path,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n */\n\nTransforms.removeTextOperation = function (transform, path, offset, length) {\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertPath(path);\n  var ranges = node.getRanges();\n  var inverse = [];\n\n  // Loop the ranges of text in the node, creating inverse insert operations for\n  // each of the ranges that overlap with the remove operation. This is\n  // necessary because insert's can only have a single set of marks associated\n  // with them, but removes can remove many.\n  ranges.reduce(function (start, range) {\n    var text = range.text,\n        marks = range.marks;\n\n    var end = start + text.length;\n    if (start > offset + length) return end;\n    if (end <= offset) return end;\n\n    var endOffset = Math.min(end, offset + length);\n    var string = text.slice(offset - start, endOffset - start);\n\n    inverse.push({\n      type: 'insert_text',\n      path: path,\n      offset: offset,\n      text: string,\n      marks: marks\n    });\n\n    return end;\n  }, 0);\n\n  var operation = {\n    type: 'remove_text',\n    path: path,\n    offset: offset,\n    length: length,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Merge `properties` into state `data`.\n *\n * @param {Transform} transform\n * @param {Object} properties\n */\n\nTransforms.setDataOperation = function (transform, properties) {\n  var state = transform.state;\n  var data = state.data;\n\n  var inverseProps = {};\n\n  for (var k in properties) {\n    inverseProps[k] = data[k];\n  }\n\n  var inverse = [{\n    type: 'set_data',\n    properties: inverseProps\n  }];\n\n  var operation = {\n    type: 'set_data',\n    properties: properties,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Mark} newMark\n */\n\nTransforms.setMarkOperation = function (transform, path, offset, length, mark, newMark) {\n  var inverse = [{\n    type: 'set_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: newMark,\n    newMark: mark\n  }];\n\n  var operation = {\n    type: 'set_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark,\n    newMark: newMark,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Object} properties\n */\n\nTransforms.setNodeOperation = function (transform, path, properties) {\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertPath(path);\n  var inverseProps = {};\n\n  for (var k in properties) {\n    inverseProps[k] = node[k];\n  }\n\n  var inverse = [{\n    type: 'set_node',\n    path: path,\n    properties: inverseProps\n  }];\n\n  var operation = {\n    type: 'set_node',\n    path: path,\n    properties: properties,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Set the selection to a new `selection`.\n *\n * @param {Transform} transform\n * @param {Mixed} selection\n */\n\nTransforms.setSelectionOperation = function (transform, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  properties = _normalize2.default.selectionProperties(properties);\n\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  var prevProps = {};\n  var props = {};\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (var k in properties) {\n    if (!options.snapshot && properties[k] == selection[k]) continue;\n    props[k] = properties[k];\n    prevProps[k] = selection[k];\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // does change the marks in some way\n  var moved = ['anchorKey', 'anchorOffset', 'focusKey', 'focusOffset'].some(function (p) {\n    return props.hasOwnProperty(p);\n  });\n\n  if (selection.marks && properties.marks == selection.marks && moved) {\n    props.marks = null;\n  }\n\n  // Resolve the selection keys into paths.\n  if (props.anchorKey) {\n    props.anchorPath = document.getPath(props.anchorKey);\n    delete props.anchorKey;\n  }\n\n  if (prevProps.anchorKey) {\n    prevProps.anchorPath = document.getPath(prevProps.anchorKey);\n    delete prevProps.anchorKey;\n  }\n\n  if (props.focusKey) {\n    props.focusPath = document.getPath(props.focusKey);\n    delete props.focusKey;\n  }\n\n  if (prevProps.focusKey) {\n    prevProps.focusPath = document.getPath(prevProps.focusKey);\n    delete prevProps.focusKey;\n  }\n\n  // Define an inverse of the operation for undoing.\n  var inverse = [{\n    type: 'set_selection',\n    properties: prevProps\n  }];\n\n  // Define the operation.\n  var operation = {\n    type: 'set_selection',\n    properties: props,\n    inverse: inverse\n  };\n\n  // Apply the operation.\n  transform.applyOperation(operation);\n};\n\n/**\n * Split a node by `path` at `offset`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n */\n\nTransforms.splitNodeAtOffsetOperation = function (transform, path, offset) {\n  var inversePath = path.slice();\n  inversePath[path.length - 1] += 1;\n\n  var inverse = [{\n    type: 'join_node',\n    path: inversePath,\n    withPath: path,\n    // We will split down to the text nodes, so we must join nodes recursively.\n    deep: true\n  }];\n\n  var operation = {\n    type: 'split_node',\n    path: path,\n    offset: offset,\n    count: null,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Split a node by `path` after its 'count' child.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} count\n */\n\nTransforms.splitNodeOperation = function (transform, path, count) {\n  var inversePath = path.slice();\n  inversePath[path.length - 1] += 1;\n\n  var inverse = [{\n    type: 'join_node',\n    path: inversePath,\n    withPath: path,\n    deep: false\n  }];\n\n  var operation = {\n    type: 'split_node',\n    path: path,\n    offset: null,\n    count: count,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/transforms/operations.js\n// module id = ./node_modules/slate/lib/transforms/operations.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Extends the given selection to a given node and offset\n *\n * @param {Selection} selection Selection instance\n * @param {Element} el Node to extend to\n * @param {Number} offset Text offset to extend to\n * @returns {Selection} Mutated Selection instance\n */\n\nfunction extendSelection(selection, el, offset) {\n  // Use native method when possible\n  if (typeof selection.extend === 'function') return selection.extend(el, offset);\n\n  // See https://gist.github.com/tyler-johnson/0a3e8818de3f115b2a2dc47468ac0099\n  var range = document.createRange();\n  var anchor = document.createRange();\n  anchor.setStart(selection.anchorNode, selection.anchorOffset);\n\n  var focus = document.createRange();\n  focus.setStart(el, offset);\n\n  var v = focus.compareBoundaryPoints(Range.START_TO_START, anchor);\n  if (v >= 0) {\n    // Focus is after anchor\n    range.setStart(selection.anchorNode, selection.anchorOffset);\n    range.setEnd(el, offset);\n  } else {\n    // Anchor is after focus\n    range.setStart(el, offset);\n    range.setEnd(selection.anchorNode, selection.anchorOffset);\n  }\n\n  selection.removeAllRanges();\n  selection.addRange(range);\n\n  return selection;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = extendSelection;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/extend-selection.js\n// module id = ./node_modules/slate/lib/utils/extend-selection.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Find the closest ancestor of a DOM `element` that matches a given selector.\n *\n * @param {Element} node\n * @param {String} selector\n * @return {Element}\n */\n\nfunction findClosestNode(node, selector) {\n  if (typeof node.closest === 'function') return node.closest(selector);\n\n  // See https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\n  var matches = (node.document || node.ownerDocument).querySelectorAll(selector);\n  var i = void 0;\n  var parentNode = node;\n  do {\n    i = matches.length;\n    while (--i >= 0 && matches.item(i) !== parentNode) {}\n  } while (i < 0 && (parentNode = parentNode.parentElement));\n\n  return parentNode;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = findClosestNode;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/find-closest-node.js\n// module id = ./node_modules/slate/lib/utils/find-closest-node.js\n// module chunks = 0 2","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Find the deepest descendant of a DOM `element`.\n *\n * @param {Element} node\n * @return {Element}\n */\n\nfunction findDeepestNode(element) {\n  return element.firstChild ? findDeepestNode(element.firstChild) : element;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = findDeepestNode;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/find-deepest-node.js\n// module id = ./node_modules/slate/lib/utils/find-deepest-node.js\n// module chunks = 0 2","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Find the DOM node for a `node`.\n *\n * @param {Node} node\n * @return {Element}\n */\n\nfunction findDOMNode(node) {\n  var el = window.document.querySelector(\"[data-key=\\\"\" + node.key + \"\\\"]\");\n\n  if (!el) {\n    throw new Error(\"Unable to find a DOM node for \\\"\" + node.key + \"\\\". This is\\noften because of forgetting to add `props.attributes` to a component\\nreturned from `renderNode`.\");\n  }\n\n  return el;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = findDOMNode;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/find-dom-node.js\n// module id = ./node_modules/slate/lib/utils/find-dom-node.js\n// module chunks = 0 2","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nvar n = void 0;\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nvar generate = void 0;\n\n/**\n * Generate a key.\n *\n * @return {String}\n */\n\nfunction generateKey() {\n  return generate();\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setKeyGenerator(func) {\n  generate = func;\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetKeyGenerator() {\n  n = 0;\n  generate = function generate() {\n    return \"\" + n++;\n  };\n}\n\n/**\n * Set the initial state.\n */\n\nresetKeyGenerator();\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = generateKey;\nexports.setKeyGenerator = setKeyGenerator;\nexports.resetKeyGenerator = resetKeyGenerator;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/generate-key.js\n// module id = ./node_modules/slate/lib/utils/generate-key.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _reactDom = require('react-dom');\n\n/**\n * Get clipboard HTML data by capturing the HTML inserted by the browser's\n * native paste action. To make this work, `preventDefault()` may not be\n * called on the `onPaste` event. As this method is asynchronous, a callback\n * is needed to return the HTML content. This solution was adapted from\n * http://stackoverflow.com/a/6804718.\n *\n * @param {React.Component} component\n * @param {Function} callback\n */\n\nfunction getHtmlFromNativePaste(component, callback) {\n  var el = (0, _reactDom.findDOMNode)(component);\n\n  // Clone contentedible element, move out of screen and set focus.\n  var clone = el.cloneNode();\n  clone.setAttribute('class', '');\n  clone.setAttribute('style', 'position: fixed; left: -9999px');\n  el.parentNode.insertBefore(clone, el);\n  clone.focus();\n\n  // Clear call stack to let native paste behaviour occur on cloned element,\n  // then get what was pasted from the DOM and remove cloned element.\n  setTimeout(function () {\n    if (clone.childElementCount > 0) {\n      // If the node contains any child nodes, that is the HTML content.\n      var html = clone.innerHTML;\n      clone.parentNode.removeChild(clone);\n\n      callback(html);\n    } else {\n      // Only plain text, no HTML.\n      callback();\n    }\n  }, 0);\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = getHtmlFromNativePaste;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/get-html-from-native-paste.js\n// module id = ./node_modules/slate/lib/utils/get-html-from-native-paste.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offsetKey = require('./offset-key');\n\nvar _offsetKey2 = _interopRequireDefault(_offsetKey);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Get a point from a native selection's DOM `element` and `offset`.\n *\n * @param {Element} element\n * @param {Number} offset\n * @param {State} state\n * @param {Editor} editor\n * @return {Object}\n */\n\nfunction getPoint(element, offset, state, editor) {\n  var document = state.document;\n\n  var schema = editor.getSchema();\n\n  // If we can't find an offset key, we can't get a point.\n  var offsetKey = _offsetKey2.default.findKey(element, offset);\n  if (!offsetKey) return null;\n\n  // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires two, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n  var key = offsetKey.key;\n\n  var node = document.getDescendant(key);\n  if (!node) return null;\n\n  var decorators = document.getDescendantDecorators(key, schema);\n  var ranges = node.getRanges(decorators);\n  var point = _offsetKey2.default.findPoint(offsetKey, ranges);\n  return point;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = getPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/get-point.js\n// module id = ./node_modules/slate/lib/utils/get-point.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _transferTypes = require('../constants/transfer-types');\n\nvar _transferTypes2 = _interopRequireDefault(_transferTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nvar FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/;\n\n/**\n * Get the data and type from a native data `transfer`.\n *\n * @param {DataTransfer} transfer\n * @return {Object}\n */\n\nfunction getTransferData(transfer) {\n  var fragment = getType(transfer, _transferTypes2.default.FRAGMENT);\n  var node = getType(transfer, _transferTypes2.default.NODE);\n  var html = getType(transfer, 'text/html');\n  var rich = getType(transfer, 'text/rtf');\n  var text = getType(transfer, 'text/plain');\n  var files = void 0;\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf(' data-slate-fragment=\"')) {\n    var matches = FRAGMENT_MATCHER.exec(html);\n\n    var _matches = _slicedToArray(matches, 2),\n        full = _matches[0],\n        encoded = _matches[1]; // eslint-disable-line no-unused-vars\n\n\n    if (encoded) fragment = encoded;\n  }\n\n  // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n  if (text) {\n    var embeddedTypes = getEmbeddedTypes(text);\n\n    if (embeddedTypes[_transferTypes2.default.FRAGMENT]) fragment = embeddedTypes[_transferTypes2.default.FRAGMENT];\n    if (embeddedTypes[_transferTypes2.default.NODE]) node = embeddedTypes[_transferTypes2.default.NODE];\n    if (embeddedTypes['text/plain']) text = embeddedTypes['text/plain'];\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = _base2.default.deserializeNode(fragment);\n  if (node) node = _base2.default.deserializeNode(node);\n\n  // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items).map(function (item) {\n        return item.kind == 'file' ? item.getAsFile() : null;\n      }).filter(function (exists) {\n        return exists;\n      });\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  }\n\n  // Determine the type of the data.\n  var data = { files: files, fragment: fragment, html: html, node: node, rich: rich, text: text };\n  data.type = getTransferType(data);\n  return data;\n}\n\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\nfunction getEmbeddedTypes(text) {\n  var prefix = 'SLATE-DATA-EMBED::';\n\n  if (text.substring(0, prefix.length) !== prefix) {\n    return { 'text/plain': text };\n  }\n\n  // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n  try {\n    return JSON.parse(text.substring(prefix.length));\n  } catch (err) {\n    throw new Error('Unable to parse custom embedded drag data');\n  }\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment';\n  if (data.node) return 'node';\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html';\n  if (data.rich && data.text) return 'text';\n\n  if (data.files && data.files.length) return 'files';\n  if (data.html) return 'html';\n  if (data.text) return 'text';\n  return 'unknown';\n}\n\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type === 'text/plain' ? transfer.getData('Text') || null : null;\n  }\n\n  return transfer.types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = getTransferData;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/get-transfer-data.js\n// module id = ./node_modules/slate/lib/utils/get-transfer-data.js\n// module chunks = 0 2","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Check if an `index` of a `text` node is in a `range`.\n *\n * @param {Number} index\n * @param {Text} text\n * @param {Selection} range\n * @return {Boolean}\n */\n\nfunction isInRange(index, text, range) {\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  if (text.key == startKey && text.key == endKey) {\n    return startOffset <= index && index < endOffset;\n  } else if (text.key == startKey) {\n    return startOffset <= index;\n  } else if (text.key == endKey) {\n    return index < endOffset;\n  } else {\n    return true;\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = isInRange;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/is-in-range.js\n// module id = ./node_modules/slate/lib/utils/is-in-range.js\n// module chunks = 0 2","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Check if an `object` is a React component.\n *\n * @param {Object} object\n * @return {Boolean}\n */\n\nfunction isReactComponent(object) {\n  return object && object.prototype && object.prototype.isReactComponent;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = isReactComponent;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/is-react-component.js\n// module id = ./node_modules/slate/lib/utils/is-react-component.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.__enable = exports.__clear = exports.default = undefined;\n\nvar _es6Map = require('es6-map');\n\nvar _es6Map2 = _interopRequireDefault(_es6Map);\n\nvar _isDev = require('../constants/is-dev');\n\nvar _isDev2 = _interopRequireDefault(_isDev);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * GLOBAL: True if memoization should is enabled. Only effective when `IS_DEV`.\n *\n * @type {Boolean}\n */\n\nvar ENABLED = true;\n\n/**\n * GLOBAL: Changing this cache key will clear all previous cached results.\n * Only effective when `IS_DEV`.\n *\n * @type {Number}\n */\n\nvar CACHE_KEY = 0;\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Object}\n */\n\nvar LEAF = {};\n\n/**\n * A value to represent a memoized undefined value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Object}\n */\n\nvar UNDEFINED = {};\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nvar UNSET = undefined;\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$takesArgumen = options.takesArguments,\n      takesArguments = _options$takesArgumen === undefined ? true : _options$takesArgumen;\n\n  var _loop = function _loop(i) {\n    var property = properties[i];\n    var original = object[property];\n\n    if (!original) {\n      throw new Error('Object does not have a property named \"' + property + '\".');\n    }\n\n    object[property] = function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (_isDev2.default) {\n        // If memoization is disabled, call into the original method.\n        if (!ENABLED) return original.apply(this, args);\n\n        // If the cache key is different, previous caches must be cleared.\n        if (CACHE_KEY !== this.__cache_key) {\n          this.__cache_key = CACHE_KEY;\n          this.__cache = new _es6Map2.default();\n        }\n      }\n\n      if (!this.__cache) {\n        this.__cache = new _es6Map2.default();\n      }\n\n      var cachedValue = void 0;\n      var keys = void 0;\n\n      if (takesArguments) {\n        keys = [property].concat(args);\n        cachedValue = getIn(this.__cache, keys);\n      } else {\n        cachedValue = this.__cache.get(property);\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue;\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      var value = original.apply(this, args);\n      var v = value === undefined ? UNDEFINED : value;\n\n      if (takesArguments) {\n        this.__cache = setIn(this.__cache, keys, v);\n      } else {\n        this.__cache.set(property, v);\n      }\n\n      return value;\n    };\n  };\n\n  for (var i = 0; i < properties.length; i++) {\n    _loop(i);\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    map = map.get(key);\n    if (map === UNSET) return UNSET;\n  }\n\n  return map.get(LEAF);\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  var parent = map;\n  var child = void 0;\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    child = parent.get(key);\n\n    // If the path was not created yet...\n    if (child === UNSET) {\n      child = new _es6Map2.default();\n      parent.set(key, child);\n    }\n\n    parent = child;\n  }\n\n  // The whole path has been created, so set the value to the bottom most map.\n  child.set(LEAF, value);\n  return map;\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction __clear() {\n  CACHE_KEY++;\n\n  if (CACHE_KEY >= Number.MAX_SAFE_INTEGER) {\n    CACHE_KEY = 0;\n  }\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction __enable(enabled) {\n  ENABLED = enabled;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = memoize;\nexports.__clear = __clear;\nexports.__enable = __enable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/memoize.js\n// module id = ./node_modules/slate/lib/utils/memoize.js\n// module chunks = 0 2","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Noop.\n *\n * @return {Void}\n */\n\nfunction noop() {}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = noop;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/noop.js\n// module id = ./node_modules/slate/lib/utils/noop.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType == 1 && node.childNodes.length) {\n    var isLast = offset == node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild(node, index, direction);\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType == 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, direction);\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0;\n  }\n\n  // Return the node and offset.\n  return { node: node, offset: offset };\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  var childNodes = parent.childNodes;\n\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (child.nodeType == 8 || child.nodeType == 1 && child.childNodes.length == 0 || child.nodeType == 1 && child.getAttribute('contenteditable') == 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction == 'forward') i++;\n    if (direction == 'backward') i--;\n  }\n\n  return child || null;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = normalizeNodeAndOffset;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/normalize-node-and-offset.js\n// module id = ./node_modules/slate/lib/utils/normalize-node-and-offset.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _block = require('../models/block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _document = require('../models/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _inline = require('../models/inline');\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _data = require('../models/data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _mark = require('../models/mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _selection = require('../models/selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _text = require('../models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _warn = require('./warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nvar _typeOf = require('type-of');\n\nvar _typeOf2 = _interopRequireDefault(_typeOf);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Normalize a block argument `value`.\n *\n * @param {Block|String|Object} value\n * @return {Block}\n */\n\nfunction block(value) {\n  if (_block2.default.isBlock(value)) return value;\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n    case 'object':\n      return _block2.default.create(nodeProperties(value));\n\n    default:\n      throw new Error('Invalid `block` argument! It must be a block, an object, or a string. You passed: \"' + value + '\".');\n  }\n}\n\n/**\n * Normalize an inline argument `value`.\n *\n * @param {Inline|String|Object} value\n * @return {Inline}\n */\n\nfunction inline(value) {\n  if (_inline2.default.isInline(value)) return value;\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n    case 'object':\n      return _inline2.default.create(nodeProperties(value));\n\n    default:\n      throw new Error('Invalid `inline` argument! It must be an inline, an object, or a string. You passed: \"' + value + '\".');\n  }\n}\n\n/**\n * Normalize a key argument `value`.\n *\n * @param {String|Node} value\n * @return {String}\n */\n\nfunction key(value) {\n  if ((0, _typeOf2.default)(value) == 'string') return value;\n\n  (0, _warn2.default)('An object was passed to a Node method instead of a `key` string. This was previously supported, but is being deprecated because it can have a negative impact on performance. The object in question was:', value);\n  if (_block2.default.isBlock(value)) return value.key;\n  if (_document2.default.isDocument(value)) return value.key;\n  if (_inline2.default.isInline(value)) return value.key;\n  if (_text2.default.isText(value)) return value.key;\n\n  throw new Error('Invalid `key` argument! It must be either a block, an inline, a text, or a string. You passed: \"' + value + '\".');\n}\n\n/**\n * Normalize a mark argument `value`.\n *\n * @param {Mark|String|Object} value\n * @return {Mark}\n */\n\nfunction mark(value) {\n  if (_mark2.default.isMark(value)) return value;\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n    case 'object':\n      return _mark2.default.create(markProperties(value));\n\n    default:\n      throw new Error('Invalid `mark` argument! It must be a mark, an object, or a string. You passed: \"' + value + '\".');\n  }\n}\n\n/**\n * Normalize a mark properties argument `value`.\n *\n * @param {String|Object|Mark} value\n * @return {Object}\n */\n\nfunction markProperties() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var ret = {};\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n      ret.type = value;\n      break;\n\n    case 'object':\n      for (var k in value) {\n        if (k == 'data') {\n          if (value[k] !== undefined) ret[k] = _data2.default.create(value[k]);\n        } else {\n          ret[k] = value[k];\n        }\n      }\n      break;\n\n    default:\n      throw new Error('Invalid mark `properties` argument! It must be an object, a string or a mark. You passed: \"' + value + '\".');\n  }\n\n  return ret;\n}\n\n/**\n * Normalize a node properties argument `value`.\n *\n * @param {String|Object|Node} value\n * @return {Object}\n */\n\nfunction nodeProperties() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var ret = {};\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n      ret.type = value;\n      break;\n\n    case 'object':\n      if (value.isVoid !== undefined) ret.isVoid = !!value.isVoid;\n      for (var k in value) {\n        if (k == 'data') {\n          if (value[k] !== undefined) ret[k] = _data2.default.create(value[k]);\n        } else {\n          ret[k] = value[k];\n        }\n      }\n      break;\n\n    default:\n      throw new Error('Invalid node `properties` argument! It must be an object, a string or a node. You passed: \"' + value + '\".');\n  }\n\n  return ret;\n}\n\n/**\n * Normalize a selection argument `value`.\n *\n * @param {Selection|Object} value\n * @return {Selection}\n */\n\nfunction selection(value) {\n  if (_selection2.default.isSelection(value)) return value;\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'object':\n      return _selection2.default.create(value);\n\n    default:\n      throw new Error('Invalid `selection` argument! It must be a selection or an object. You passed: \"' + value + '\".');\n  }\n}\n\n/**\n * Normalize a selection properties argument `value`.\n *\n * @param {Object|Selection} value\n * @return {Object}\n */\n\nfunction selectionProperties() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var ret = {};\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'object':\n      if (value.anchorKey !== undefined) ret.anchorKey = value.anchorKey;\n      if (value.anchorOffset !== undefined) ret.anchorOffset = value.anchorOffset;\n      if (value.focusKey !== undefined) ret.focusKey = value.focusKey;\n      if (value.focusOffset !== undefined) ret.focusOffset = value.focusOffset;\n      if (value.isBackward !== undefined) ret.isBackward = !!value.isBackward;\n      if (value.isFocused !== undefined) ret.isFocused = !!value.isFocused;\n      if (value.marks !== undefined) ret.marks = value.marks;\n      break;\n\n    default:\n      throw new Error('Invalid selection `properties` argument! It must be an object or a selection. You passed: \"' + value + '\".');\n  }\n\n  return ret;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  block: block,\n  inline: inline,\n  key: key,\n  mark: mark,\n  markProperties: markProperties,\n  nodeProperties: nodeProperties,\n  selection: selection,\n  selectionProperties: selectionProperties\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/normalize.js\n// module id = ./node_modules/slate/lib/utils/normalize.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _normalizeNodeAndOffset = require('./normalize-node-and-offset');\n\nvar _normalizeNodeAndOffset2 = _interopRequireDefault(_normalizeNodeAndOffset);\n\nvar _findClosestNode = require('./find-closest-node');\n\nvar _findClosestNode2 = _interopRequireDefault(_findClosestNode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nvar PARSER = /^(\\w+)(?:-(\\d+))?$/;\n\n/**\n * Offset key attribute name.\n *\n * @type {String}\n */\n\nvar ATTRIBUTE = 'data-offset-key';\n\n/**\n * Offset key attribute selector.\n *\n * @type {String}\n */\n\nvar SELECTOR = '[' + ATTRIBUTE + ']';\n\n/**\n * Void node selection.\n *\n * @type {String}\n */\n\nvar VOID_SELECTOR = '[data-slate-void]';\n\n/**\n * Find the start and end bounds from an `offsetKey` and `ranges`.\n *\n * @param {Number} index\n * @param {List<Range>} ranges\n * @return {Object}\n */\n\nfunction findBounds(index, ranges) {\n  var range = ranges.get(index);\n  var start = ranges.slice(0, index).reduce(function (memo, r) {\n    return memo += r.text.length;\n  }, 0);\n\n  return {\n    start: start,\n    end: start + range.text.length\n  };\n}\n\n/**\n * From a DOM node, find the closest parent's offset key.\n *\n * @param {Element} rawNode\n * @param {Number} rawOffset\n * @return {Object}\n */\n\nfunction findKey(rawNode, rawOffset) {\n  var _normalizeNodeAndOffs = (0, _normalizeNodeAndOffset2.default)(rawNode, rawOffset),\n      node = _normalizeNodeAndOffs.node,\n      offset = _normalizeNodeAndOffs.offset;\n\n  var parentNode = node.parentNode;\n\n  // Find the closest parent with an offset key attribute.\n\n  var closest = (0, _findClosestNode2.default)(parentNode, SELECTOR);\n\n  // For void nodes, the element with the offset key will be a cousin, not an\n  // ancestor, so find it by going down from the nearest void parent.\n  if (!closest) {\n    var closestVoid = (0, _findClosestNode2.default)(parentNode, VOID_SELECTOR);\n    if (!closestVoid) return null;\n    closest = closestVoid.querySelector(SELECTOR);\n    offset = closest.textContent.length;\n  }\n\n  // Get the string value of the offset key attribute.\n  var offsetKey = closest.getAttribute(ATTRIBUTE);\n\n  // If we still didn't find an offset key, abort.\n  if (!offsetKey) return null;\n\n  // Return the parsed the offset key.\n  var parsed = parse(offsetKey);\n  return {\n    key: parsed.key,\n    index: parsed.index,\n    offset: offset\n  };\n}\n\n/**\n * Find the selection point from an `offsetKey` and `ranges`.\n *\n * @param {Object} offsetKey\n * @param {List<Range>} ranges\n * @return {Object}\n */\n\nfunction findPoint(offsetKey, ranges) {\n  var key = offsetKey.key,\n      index = offsetKey.index,\n      offset = offsetKey.offset;\n\n  var _findBounds = findBounds(index, ranges),\n      start = _findBounds.start,\n      end = _findBounds.end;\n\n  // Don't let the offset be outside of the start and end bounds.\n\n\n  offset = start + offset;\n  offset = Math.max(offset, start);\n  offset = Math.min(offset, end);\n\n  return {\n    key: key,\n    index: index,\n    start: start,\n    end: end,\n    offset: offset\n  };\n}\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  var matches = PARSER.exec(string);\n  if (!matches) throw new Error('Invalid offset key string \"' + string + '\".');\n\n  var _matches = _slicedToArray(matches, 3),\n      original = _matches[0],\n      key = _matches[1],\n      index = _matches[2]; // eslint-disable-line no-unused-vars\n\n\n  return {\n    key: key,\n    index: parseInt(index, 10)\n  };\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n  return object.key + '-' + object.index;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  findBounds: findBounds,\n  findKey: findKey,\n  findPoint: findPoint,\n  parse: parse,\n  stringify: stringify\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/offset-key.js\n// module id = ./node_modules/slate/lib/utils/offset-key.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _block = require('../models/block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _character = require('../models/character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _document = require('../models/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _inline = require('../models/inline');\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _mark = require('../models/mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _range = require('../models/range');\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _schema = require('../models/schema');\n\nvar _schema2 = _interopRequireDefault(_schema);\n\nvar _selection = require('../models/selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _state = require('../models/state');\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _text = require('../models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * HOC Function that takes in a predicate prop type function, and allows an isRequired chain\n *\n * @param {Function} predicate\n * @return {Function}\n */\n\nfunction createChainablePropType(predicate) {\n  function propType(props, propName, componentName) {\n    if (props[propName] == null) return;\n\n    return predicate(props, propName, componentName);\n  }\n\n  propType.isRequired = function (props, propName, componentName) {\n    if (props[propName] == null) return new Error('Required prop `' + propName + '` was not specified in `' + componentName + '`.');\n\n    return predicate(props, propName, componentName);\n  };\n\n  return propType;\n}\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate Block\n *\n * @type {Function}\n */\n\nvar block = createChainablePropType(function (props, propName, componentName) {\n  return !_block2.default.isBlock(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate Block') : null;\n});\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate Character\n *\n * @type {Function}\n */\n\nvar character = createChainablePropType(function (props, propName, componentName) {\n  return !_character2.default.isCharacter(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate Character') : null;\n});\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate Document\n *\n * @type {Function}\n */\n\nvar document = createChainablePropType(function (props, propName, componentName) {\n  return !_document2.default.isDocument(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate Document') : null;\n});\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate Inline\n *\n * @type {Function}\n */\n\nvar inline = createChainablePropType(function (props, propName, componentName) {\n  return !_inline2.default.isInline(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate Inline') : null;\n});\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate Mark\n *\n * @type {Function}\n */\n\nvar mark = createChainablePropType(function (props, propName, componentName) {\n  return !_mark2.default.isMark(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate Mark') : null;\n});\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate Range\n *\n * @type {Function}\n */\n\nvar range = createChainablePropType(function (props, propName, componentName) {\n  return !_range2.default.isRange(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate Range') : null;\n});\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate Schema\n *\n * @type {Function}\n */\n\nvar schema = createChainablePropType(function (props, propName, componentName) {\n  return !_schema2.default.isSchema(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate Schema') : null;\n});\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate Selection\n *\n * @type {Function}\n */\n\nvar selection = createChainablePropType(function (props, propName, componentName) {\n  return !_selection2.default.isSelection(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate Selection') : null;\n});\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate State\n *\n * @type {Function}\n */\n\nvar state = createChainablePropType(function (props, propName, componentName) {\n  return !_state2.default.isState(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate State ' + props[propName]) : null;\n});\n\n/**\n * Exported Slate proptype that checks if a prop is a Slate Text\n *\n * @type {Function}\n */\n\nvar text = createChainablePropType(function (props, propName, componentName) {\n  return !_text2.default.isText(props[propName]) ? new Error(propName + ' in ' + componentName + ' is not a Slate Text') : null;\n});\n\n/**\n * Exported Slate proptypes\n *\n * @type {Object}\n */\n\nexports.default = {\n  block: block,\n  character: character,\n  document: document,\n  inline: inline,\n  mark: mark,\n  range: range,\n  schema: schema,\n  selection: selection,\n  state: state,\n  text: text\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/prop-types.js\n// module id = ./node_modules/slate/lib/utils/prop-types.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nvar _selectionIsBackward = require('selection-is-backward');\n\nvar _selectionIsBackward2 = _interopRequireDefault(_selectionIsBackward);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  if (!selection.anchorNode) return;\n\n  var window = (0, _getWindow2.default)(selection.anchorNode);\n  var backward = (0, _selectionIsBackward2.default)(selection);\n  var range = selection.getRangeAt(0);\n  var rect = range.getBoundingClientRect();\n  var innerWidth = window.innerWidth,\n      innerHeight = window.innerHeight,\n      pageYOffset = window.pageYOffset,\n      pageXOffset = window.pageXOffset;\n\n  var top = (backward ? rect.top : rect.bottom) + pageYOffset;\n  var left = (backward ? rect.left : rect.right) + pageXOffset;\n\n  var x = left < pageXOffset || innerWidth + pageXOffset < left ? left - innerWidth / 2 : pageXOffset;\n\n  var y = top < pageYOffset || innerHeight + pageYOffset < top ? top - innerHeight / 2 : pageYOffset;\n\n  window.scrollTo(x, y);\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = scrollToSelection;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/scroll-to-selection.js\n// module id = ./node_modules/slate/lib/utils/scroll-to-selection.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Set data on dataTransfer\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {DataTransfer} dataTransfer\n * @param {String} type\n * @param {String} content\n */\n\nfunction setTransferData(dataTransfer, type, content) {\n  try {\n    dataTransfer.setData(type, content);\n  } catch (err) {\n    var prefix = 'SLATE-DATA-EMBED::';\n    var obj = {};\n    var text = dataTransfer.getData('text/plain');\n\n    // If prefixed, assume embedded drag data\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length));\n      } catch (err2) {\n        throw new Error('Unable to parse custom embedded drag data');\n      }\n    } else {\n      obj['text/plain'] = text;\n    }\n\n    obj[type] = content;\n\n    dataTransfer.setData('text/plain', '' + prefix + JSON.stringify(obj));\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = setTransferData;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/set-transfer-data.js\n// module id = ./node_modules/slate/lib/utils/set-transfer-data.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _esrever = require('esrever');\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nvar SURROGATE_START = 0xD800;\nvar SURROGATE_END = 0xDFFF;\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nvar SPACE = /\\s/;\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nvar CHAMELEON = /['\\u2018\\u2019]/;\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false;\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharLength(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n    if (isWord(next, rest)) return true;\n  }\n\n  if (PUNCTUATION.test(char)) return false;\n  return true;\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1;\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  var char = text.charAt(0);\n  return getCharLength(char);\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = (0, _esrever.reverse)(text);\n  return getCharOffset(text);\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset);\n  return getCharOffset(text);\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char = void 0;\n\n  while (char = text.charAt(i)) {\n    var l = getCharLength(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWord(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = (0, _esrever.reverse)(text);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  getCharOffsetForward: getCharOffsetForward,\n  getCharOffsetBackward: getCharOffsetBackward,\n  getWordOffsetBackward: getWordOffsetBackward,\n  getWordOffsetForward: getWordOffsetForward\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/string.js\n// module id = ./node_modules/slate/lib/utils/string.js\n// module chunks = 0 2","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isDev = require('../constants/is-dev');\n\nvar _isDev2 = _interopRequireDefault(_isDev);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Log a development warning.\n *\n * @param {String} message\n * @param {Any} ...args\n */\n\nfunction warn(message) {\n  if (!_isDev2.default) {\n    return;\n  }\n\n  if (typeof console !== 'undefined') {\n    var _console;\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console).warn.apply(_console, ['Warning: ' + message].concat(args)); // eslint-disable-line no-console\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = warn;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/slate/lib/utils/warn.js\n// module id = ./node_modules/slate/lib/utils/warn.js\n// module chunks = 0 2","var toString = Object.prototype.toString\r\n\r\nmodule.exports = function(val){\r\n  switch (toString.call(val)) {\r\n    case '[object Function]': return 'function'\r\n    case '[object Date]': return 'date'\r\n    case '[object RegExp]': return 'regexp'\r\n    case '[object Arguments]': return 'arguments'\r\n    case '[object Array]': return 'array'\r\n    case '[object String]': return 'string'\r\n  }\r\n\r\n  if (typeof val == 'object' && val && typeof val.length == 'number') {\r\n    try {\r\n      if (typeof val.callee == 'function') return 'arguments';\r\n    } catch (ex) {\r\n      if (ex instanceof TypeError) {\r\n        return 'arguments';\r\n      }\r\n    }\r\n  }\r\n\r\n  if (val === null) return 'null'\r\n  if (val === undefined) return 'undefined'\r\n  if (val && val.nodeType === 1) return 'element'\r\n  if (val === Object(val)) return 'object'\r\n\r\n  return typeof val\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/type-of/index.js\n// module id = ./node_modules/type-of/index.js\n// module chunks = 0 2","/**\n * Copyright Morpheo Org. 2017\n *\n * contact@morpheo.co\n *\n * This software is part of the Morpheo project, an open-source machine\n * learning platform.\n *\n * This software is governed by the CeCILL license, compatible with the\n * GNU GPL, under French law and abiding by the rules of distribution of\n * free software. You can  use, modify and/ or redistribute the software\n * under the terms of the CeCILL license as circulated by CEA, CNRS and\n * INRIA at the following URL \"http://www.cecill.info\".\n *\n * As a counterpart to the access to the source code and  rights to copy,\n * modify and redistribute granted by the license, users are provided only\n * with a limited warranty  and the software's author,  the holder of the\n * economic rights,  and the successive licensors  have only  limited\n * liability.\n *\n * In this respect, the user's attention is drawn to the risks associated\n * with loading,  using,  modifying and/or developing or reproducing the\n * software by the user in light of its specific status of free software,\n * that may mean  that it is complicated to manipulate,  and  that  also\n * therefore means  that it is reserved for developers  and  experienced\n * professionals having in-depth computer knowledge. Users are therefore\n * encouraged to load and test the software's suitability as regards their\n * requirements in conditions enabling the security of their systems and/or\n * data to be ensured and,  more generally, to use and operate it in the\n * same conditions as regards security.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL license and that you accept its terms.\n */\n\nimport {createAction} from 'redux-actions';\n\nimport createRequestActionTypes from '../../actions/createRequestActionTypes';\n\nexport const actionTypes = {\n    create: createRequestActionTypes('KERNEL::CREATE'),\n    connect: createRequestActionTypes('KERNEL::CONNECT'),\n    close: createRequestActionTypes('KERNEL::CLOSE', ['REQUEST', 'SUCCESS']),\n    message: createRequestActionTypes('KERNEL::MESSAGE', ['ERROR', 'RECEIVE', 'SEND']),\n};\n\nexport const create = {\n    request: createAction(actionTypes.create.REQUEST),\n    success: createAction(actionTypes.create.SUCCESS),\n    failure: createAction(actionTypes.create.FAILURE),\n};\n\nexport const connect = {\n    request: createAction(actionTypes.connect.REQUEST),\n    success: createAction(actionTypes.connect.SUCCESS),\n    failure: createAction(actionTypes.connect.FAILURE),\n};\n\nexport const close = {\n    request: createAction(actionTypes.close.REQUEST),\n    success: createAction(actionTypes.close.SUCCESS),\n};\n\nexport const message = {\n    error: createAction(actionTypes.message.ERROR),\n    receive: createAction(actionTypes.message.RECEIVE),\n    send: createAction(actionTypes.message.SEND),\n};\n\nexport default {\n    create,\n    connect,\n    close,\n    message,\n};\n\n\n\n// WEBPACK FOOTER //\n// src/client/js/business/kernel/actions.js","/**\n * Copyright Morpheo Org. 2017\n *\n * contact@morpheo.co\n *\n * This software is part of the Morpheo project, an open-source machine\n * learning platform.\n *\n * This software is governed by the CeCILL license, compatible with the\n * GNU GPL, under French law and abiding by the rules of distribution of\n * free software. You can  use, modify and/ or redistribute the software\n * under the terms of the CeCILL license as circulated by CEA, CNRS and\n * INRIA at the following URL \"http://www.cecill.info\".\n *\n * As a counterpart to the access to the source code and  rights to copy,\n * modify and redistribute granted by the license, users are provided only\n * with a limited warranty  and the software's author,  the holder of the\n * economic rights,  and the successive licensors  have only  limited\n * liability.\n *\n * In this respect, the user's attention is drawn to the risks associated\n * with loading,  using,  modifying and/or developing or reproducing the\n * software by the user in light of its specific status of free software,\n * that may mean  that it is complicated to manipulate,  and  that  also\n * therefore means  that it is reserved for developers  and  experienced\n * professionals having in-depth computer knowledge. Users are therefore\n * encouraged to load and test the software's suitability as regards their\n * requirements in conditions enabling the security of their systems and/or\n * data to be ensured and,  more generally, to use and operate it in the\n * same conditions as regards security.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL license and that you accept its terms.\n */\n\nimport {createAction} from 'redux-actions';\nimport createRequestActionTypes from '../../actions/createRequestActionTypes';\n\nconst prefix = 'MORPHEO';\n\nexport const actionTypes = {\n    save: createRequestActionTypes(`${prefix}__CELL_AVE`),\n\n    SET: `${prefix}_CELL_SET`,\n    SET_LANGUAGE: `${prefix}_CELL_SET_LANGUAGE`,\n    SET_ACTIVE: `${prefix}_CELL_SET_ACTIVE`,\n    SET_SLATE: `${prefix}_CELL_SET_SLATE`,\n    ADD: `${prefix}_CELL_ADD`,\n    REMOVE: `${prefix}_CELL_REMOVE`,\n    INSERT_AFTER: `${prefix}_CELL_INSERT_AFTER`,\n    INSERT_BEFORE: `${prefix}_CELL_INSERT_BEFORE`,\n};\n\nexport default {\n    save: {\n        request: createAction(actionTypes.save.REQUEST),\n        success: createAction(actionTypes.save.SUCCESS),\n        failure: createAction(actionTypes.save.FAILURE),\n    },\n\n    set: createAction(actionTypes.SET),\n    setLanguage: createAction(actionTypes.SET_LANGUAGE),\n    setActive: createAction(actionTypes.SET_ACTIVE),\n    setSlate: createAction(actionTypes.SET_SLATE),\n    add: createAction(actionTypes.ADD),\n    remove: createAction(actionTypes.REMOVE),\n    insertAfter: createAction(actionTypes.INSERT_AFTER),\n    insertBefore: createAction(actionTypes.INSERT_BEFORE),\n};\n\n\n\n// WEBPACK FOOTER //\n// src/client/js/business/notebook/actions.js","/**\n * Copyright Morpheo Org. 2017\n *\n * contact@morpheo.co\n *\n * This software is part of the Morpheo project, an open-source machine\n * learning platform.\n *\n * This software is governed by the CeCILL license, compatible with the\n * GNU GPL, under French law and abiding by the rules of distribution of\n * free software. You can  use, modify and/ or redistribute the software\n * under the terms of the CeCILL license as circulated by CEA, CNRS and\n * INRIA at the following URL \"http://www.cecill.info\".\n *\n * As a counterpart to the access to the source code and  rights to copy,\n * modify and redistribute granted by the license, users are provided only\n * with a limited warranty  and the software's author,  the holder of the\n * economic rights,  and the successive licensors  have only  limited\n * liability.\n *\n * In this respect, the user's attention is drawn to the risks associated\n * with loading,  using,  modifying and/or developing or reproducing the\n * software by the user in light of its specific status of free software,\n * that may mean  that it is complicated to manipulate,  and  that  also\n * therefore means  that it is reserved for developers  and  experienced\n * professionals having in-depth computer knowledge. Users are therefore\n * encouraged to load and test the software's suitability as regards their\n * requirements in conditions enabling the security of their systems and/or\n * data to be ensured and,  more generally, to use and operate it in the\n * same conditions as regards security.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL license and that you accept its terms.\n */\n\n// define supported languages\n\nexport default ['python', 'r', 'julia'];\n\n\n\n// WEBPACK FOOTER //\n// src/client/js/business/notebook/components/Editor/languages.js","/**\n * Copyright Morpheo Org. 2017\n *\n * contact@morpheo.co\n *\n * This software is part of the Morpheo project, an open-source machine\n * learning platform.\n *\n * This software is governed by the CeCILL license, compatible with the\n * GNU GPL, under French law and abiding by the rules of distribution of\n * free software. You can  use, modify and/ or redistribute the software\n * under the terms of the CeCILL license as circulated by CEA, CNRS and\n * INRIA at the following URL \"http://www.cecill.info\".\n *\n * As a counterpart to the access to the source code and  rights to copy,\n * modify and redistribute granted by the license, users are provided only\n * with a limited warranty  and the software's author,  the holder of the\n * economic rights,  and the successive licensors  have only  limited\n * liability.\n *\n * In this respect, the user's attention is drawn to the risks associated\n * with loading,  using,  modifying and/or developing or reproducing the\n * software by the user in light of its specific status of free software,\n * that may mean  that it is complicated to manipulate,  and  that  also\n * therefore means  that it is reserved for developers  and  experienced\n * professionals having in-depth computer knowledge. Users are therefore\n * encouraged to load and test the software's suitability as regards their\n * requirements in conditions enabling the security of their systems and/or\n * data to be ensured and,  more generally, to use and operate it in the\n * same conditions as regards security.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL license and that you accept its terms.\n */\n\nimport {actionTypes} from '../actions';\nimport {actionTypes as kernelActionTypes} from '../../kernel/actions';\n\n\nexport const getContent = (content, type) => {\n    switch (type) {\n    case 'stream':\n        return content.text;\n    case 'display_data':\n        return content.data['image/svg+xml'] || content.data['text/plain'] || content.data['image/png'];\n    case 'error':\n        return content;\n    default:\n        return undefined;\n    }\n};\n\nconst getType = (content, type) => {\n    switch (type) {\n    case 'stream':\n        return 'text';\n    case 'display_data':\n        return content.data['image/svg+xml'] ? 'text' : 'img';\n    case 'error':\n        return 'error';\n    default:\n        return undefined;\n    }\n};\n\nconst initialState = {\n    results: [],\n};\n\nexport default (state = initialState, {type, payload}) => {\n    const index = state.results.findIndex(o => o.isActive);\n    switch (type) {\n    case actionTypes.ADD:\n        return {\n            ...state,\n            results: [...state.results, payload],\n        };\n    case actionTypes.REMOVE:\n        return {\n            ...state,\n            results: state.results.filter(o => o.id !== payload),\n        };\n    case actionTypes.SET: {\n        // exists ?\n        const exists = state.results.find(o => o.parent_id === payload.id);\n\n        return {\n            ...state,\n            results: exists ? state.results.reduce((p, c) => [\n                ...p, c.parent_id === payload.id ? {\n                    ...c,\n                    parent_id: payload.id,\n                    value: payload.value,\n                } : c],\n            []) :\n                [\n                    ...state.results,\n                    {\n                        parent_id: payload.id,\n                        value: payload.value,\n                    }],\n        };\n    }\n    case actionTypes.INSERT_AFTER:\n        return {\n            ...state,\n            results: [\n                ...state.results.slice(0, index),\n                {...state.results[index]},\n                {...payload},\n                ...state.results.slice(index + 1, state.results.length),\n            ],\n        };\n\n    case actionTypes.INSERT_BEFORE:\n        return {\n            ...state,\n            results: [\n                ...state.results.slice(0, index),\n                {...payload},\n                {...state.results[index]},\n                ...state.results.slice(index + 1, state.results.length),\n            ],\n        };\n    case kernelActionTypes.message.RECEIVE: {\n        if (!['stream', 'error', 'display_data'].includes(payload.msg_type)) {\n            return state;\n        }\n\n\n        const key = parseInt(payload.parent_header.msg_id.split('-')[0], 10);\n\n        // exists ?\n        const exists = state.results.find(o => o.parent_id === key);\n\n        return {\n            ...state,\n            results: exists ? state.results.reduce((p, c) =>\n                ([...p, c.parent_id === key ? {\n                    ...c,\n                    id: payload.parent_header.msg_id,\n                    parent_id: key,\n                    content: getContent(payload.content, payload.msg_type),\n                    type: getType(payload.content, payload.msg_type),\n                    status: payload.msg_type === 'error' ? 'ERROR' : 'DONE',\n                } : c]),\n            []) :\n                [\n                    ...state.results,\n                    {\n                        id: payload.parent_header.msg_id,\n                        parent_id: key,\n                        content: getContent(payload.content, payload.msg_type),\n                        type: getType(payload.content, payload.msg_type),\n                        status: payload.msg_type === 'error' ? 'ERROR' : 'DONE',\n                    }],\n        };\n    }\n    default:\n        return state;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// src/client/js/business/notebook/reducers/cells.js","/**\n * Created by guillaume on 6/27/17.\n */\n\nimport slate from './slate';\nimport cells from './cells';\n\nexport default {\n    slate,\n    cells,\n};\n\n\n\n// WEBPACK FOOTER //\n// src/client/js/business/notebook/reducers/index.js","/**\n * Copyright Morpheo Org. 2017\n *\n * contact@morpheo.co\n *\n * This software is part of the Morpheo project, an open-source machine\n * learning platform.\n *\n * This software is governed by the CeCILL license, compatible with the\n * GNU GPL, under French law and abiding by the rules of distribution of\n * free software. You can  use, modify and/ or redistribute the software\n * under the terms of the CeCILL license as circulated by CEA, CNRS and\n * INRIA at the following URL \"http://www.cecill.info\".\n *\n * As a counterpart to the access to the source code and  rights to copy,\n * modify and redistribute granted by the license, users are provided only\n * with a limited warranty  and the software's author,  the holder of the\n * economic rights,  and the successive licensors  have only  limited\n * liability.\n *\n * In this respect, the user's attention is drawn to the risks associated\n * with loading,  using,  modifying and/or developing or reproducing the\n * software by the user in light of its specific status of free software,\n * that may mean  that it is complicated to manipulate,  and  that  also\n * therefore means  that it is reserved for developers  and  experienced\n * professionals having in-depth computer knowledge. Users are therefore\n * encouraged to load and test the software's suitability as regards their\n * requirements in conditions enabling the security of their systems and/or\n * data to be ensured and,  more generally, to use and operate it in the\n * same conditions as regards security.\n *\n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL license and that you accept its terms.\n */\n\nimport {State, Document} from 'slate';\n\nimport {actionTypes} from '../actions';\nimport {actionTypes as kernelActionTypes} from '../../kernel/actions';\nimport languages from '../components/Editor/languages';\nimport {getContent} from './cells';\n\nconst initialState = {\n    state: State.create({\n        document: Document.create({\n            nodes: [\n                {\n                    kind: 'block',\n                    type: 'code_block',\n                    data: {syntax: languages[0]},\n                    nodes: [\n                        {\n                            type: 'code_line',\n                            nodes: [{\n                                type: 'text',\n                                text: '',\n                            }],\n                        },\n                    ],\n                },\n            ],\n        }),\n        // selection: Selection.create(),\n    }),\n    language: null,\n    loading: false,\n    version: null,\n    error: null,\n};\n\nexport default (state = initialState, {type, payload}) => {\n    switch (type) {\n    case actionTypes.SET_LANGUAGE:\n        return {\n            ...state,\n            language: payload.language,\n            state: payload.state,\n        };\n    case actionTypes.SET_SLATE:\n        return {\n            ...state,\n            state: payload.state,\n        };\n    case actionTypes.save.REQUEST:\n        return {\n            ...state,\n            loading: true,\n        };\n    case actionTypes.save.SUCCESS:\n        return {\n            ...state,\n            version: payload.version,\n            loading: false,\n        };\n    case actionTypes.save.FAILURE:\n        return {\n            ...state,\n            loading: false,\n            error: payload.error,\n        };\n    case kernelActionTypes.message.RECEIVE:\n        return {\n            ...state,\n            output: getContent(payload.content, payload.msg_type),\n            state: state.state.transform().focus().apply(),\n        };\n    default:\n        return state;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// src/client/js/business/notebook/reducers/slate.js"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/CA;AACA;AACA;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACPA;AACA;AACA;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvGA;AACA;AACA;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1DA;AACA;AACA;AACA;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACl3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxFA;AACA;AACA;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC99DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACx+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3gCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5yBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACr4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACOA;AACA;AACA;AACA;;;;;AAtCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AAJA;;;;;;;;;;AA9BA;AACA;AAMA;AACA;AAKA;AACA;AAKA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AAAA;AACA;;;;;AArCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AACA;AAYA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;;;;;;;;;;AAbA;AACA;AAHA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;;AArCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AAAA;AACA;;;AArCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AADA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAEA;AAAA;AAAA;AAFA;AAIA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AAHA;AADA;AAUA;AACA;AAFA;AAXA;AAgBA;AACA;AACA;AAEA;AAFA;AACA;AASA;AACA;AAEA;AAFA;AASA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AANA;AADA;AAaA;AACA;AACA;AACA;AACA;AALA;AAdA;AAsBA;AACA;AACA;AAxFA;AA0FA;AACA;;;;;;;;;;AA3HA;AACA;AAYA;AACA;AAYA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AACA;;;AAAA;AACA;;;;;AANA;;;;AAOA;AACA;AACA;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4BA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;AAAA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAFA;AAFA;AALA;AAFA;AAkBA;AAnBA;AAqBA;AACA;AACA;AACA;AAzBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAHA;AAKA;AACA;AAEA;AAFA;AAIA;AACA;AAEA;AAFA;AAIA;AACA;AAEA;AACA;AAHA;AAKA;AACA;AAEA;AACA;AAHA;AAKA;AACA;AAEA;AACA;AAHA;AAKA;AACA;AApCA;AAsCA;AACA;;;;;;;;;;AApEA;AACA;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}